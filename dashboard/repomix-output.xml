This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    ci.yml
backend/
  src/
    config/
      db.js
      index.js
    lib/
      logger.js
    middleware/
      auth.js
      csrf.js
      error.middleware.js
      errorHandler.js
      logSanitizer.js
      rateLimit.middleware.js
      validate.js
    migrations/
      000_enable_extensions.sql
      001_create_users.sql
      002_create_refresh_tokens.sql
      003_create_organizations.sql
      004_create_questions.sql
      005_create_question_responses.sql
      006_create_captcha_sites.sql
      007_add_analytics_indexes.sql
      008_create_tenants.sql
      009_create_tenant_api_keys.sql
      010_create_surveys_table.sql
      011_create_survey_analytics_cache.sql
      012_create_webhook_logs.sql
      013_create_export_jobs.sql
      014_migrate_captcha_to_microsurvey.sql
      015_finalize_captcha_cleanup.sql
      016_create_billing_tables.sql
      017_enhance_auth_security.sql
      018_enhance_survey_snapshots.sql
      019_create_survey_events.sql
      run.js
    modules/
      analytics/
        analytics.controller.js
        analytics.routes.js
        analytics.service.js
      auth/
        auth.controller.js
        auth.middleware.js
        auth.routes.js
        auth.service.js
        auth.validation.js
        auth.validators.js
        email.utils.js
        jwt.utils.js
        password.utils.js
        README.md
        tokens.utils.js
      billing/
        admin.billing.controller.js
        admin.billing.routes.js
        admin.billing.service.js
      embed/
        embed.controller.js
        embed.routes.js
      integration/
        integration.controller.js
        integration.routes.js
        integration.service.js
      organizations/
        organizations.controller.js
        organizations.routes.js
        organizations.service.js
        organizations.validation.js
      questions/
        questions.controller.js
        questions.routes.js
        questions.service.js
        questions.validation.js
      surveys/
        snapshots.service.js
        surveys.controller.js
        surveys.routes.js
        surveys.service.js
        surveys.validation.js
        surveys.validators.js
      tenants/
        tenants.controller.js
        tenants.routes.js
        tenants.service.js
        tenants.validation.js
      webhooks/
        webhooks.controller.js
        webhooks.routes.js
        webhooks.service.js
    routes/
      index.js
    services/
      apiKeyService.js
      imageService.js
      microSurveyClient.js
    utils/
      ApiError.js
      ApiResponse.js
      asyncHandler.js
      bcrypt.js
      jwt.js
      logger.js
    workers/
      analytics.worker.js
      imageWorker.js
      responseQueue.js
      surveyWorker.js
    app.js
    server.js
  tests/
    auth.integration.test.js
    auth.test.js
    auth.unit.test.js
    batching.test.js
    imageUpload.test.js
    setup.js
  .env.example
  complete_backend_fix.sh
  docker-compose.yml
  Dockerfile
  Dockerfile.nosharp
  package.json
  README.md
frontend/
  src/
    components/
      layout/
        DashboardLayout.jsx
        Sidebar.jsx
        Topbar.jsx
      questions/
        QuestionEditor.jsx
        QuestionForm.jsx
        QuestionList.jsx
      ui/
        ErrorBoundary.jsx
        LoadingSpinner.jsx
      Layout.jsx
      ProtectedRoute.jsx
    context/
      AuthContext.jsx
    hooks/
      useAuth.js
    pages/
      dashboard/
        analytics/
          AnalyticsOverview.jsx
      errors/
        NotFound.jsx
        Unauthorized.jsx
      Analytics.jsx
      Dashboard.jsx
      ForgotPassword.jsx
      Login.jsx
      Organizations.jsx
      QuestionBuilder.jsx
      QuestionList.jsx
      Register.jsx
      ResetPassword.jsx
    services/
      api.js
    App.jsx
    index.css
    main.jsx
  Dockerfile
  index.html
  nginx.conf
  package.json
  postcss.config.js
  tailwind.config.js
  vite.config.js
microsurvey-mock/
  index.js
public/
  widget.js
.env.example
.gitignore
docker-compose.yml
Makefile
package.json
smoke.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/src/config/db.js">
import pg from "pg";
import { config } from "./index.js";

const { Pool } = pg;

const pool = new Pool({
  connectionString: config.database.url,
  max: config.database.poolMax,
  min: config.database.poolMin,
  idleTimeoutMillis: config.database.idleTimeout,
  connectionTimeoutMillis: config.database.connectionTimeout,
});

pool.on("error", (err) => {
  console.error("Unexpected database pool error:", err);
});

export async function query(text, params) {
  const start = Date.now();
  try {
    const result = await pool.query(text, params);
    const duration = Date.now() - start;
    
    if (config.nodeEnv === "development") {
      console.log(`[DB] ${text.substring(0, 50)}... (${duration}ms, ${result.rowCount} rows)`);
    }
    
    return result;
  } catch (error) {
    console.error("[DB ERROR]", error.message);
    throw error;
  }
}

export async function transaction(callback) {
  const client = await pool.connect();
  try {
    await client.query("BEGIN");
    const result = await callback(client);
    await client.query("COMMIT");
    return result;
  } catch (error) {
    await client.query("ROLLBACK");
    throw error;
  } finally {
    client.release();
  }
}

export async function testConnection() {
  try {
    const result = await pool.query("SELECT NOW()");
    console.log("✅ Database connected:", result.rows[0].now);
    return true;
  } catch (error) {
    console.error("❌ Database connection failed:", error.message);
    throw error;
  }
}

export { pool };
export default { query, transaction, pool, testConnection };
</file>

<file path="backend/src/config/index.js">
// ============================================
// FILE: backend/src/config/index.js (UPDATED)
// Configuration with image processing support
// ============================================
import dotenv from "dotenv";
import Joi from "joi";

dotenv.config();

// Configuration Schema
const envSchema = Joi.object({
  NODE_ENV: Joi.string().valid('development', 'production', 'test').default('development'),
  PORT: Joi.number().default(5000),
  
  DATABASE_URL: Joi.string().uri().required(),
  REDIS_URL: Joi.string().uri().required(),
  
  JWT_SECRET: Joi.string().min(32).required(),
  ACCESS_TOKEN_EXP: Joi.string().default('15m'),
  REFRESH_TOKEN_EXP: Joi.string().default('7d'),
  
  CORS_ORIGINS: Joi.string().default('http://localhost:5173'),
  TRUST_PROXY: Joi.boolean().default(false),
  API_KEY_PEPPER: Joi.string().min(16).required(),
  
  MICROSURVEY_BASE_URL: Joi.string().uri().required(),
  MICROSURVEY_API_KEY: Joi.string().required(),
  MICROSURVEY_TIMEOUT_MS: Joi.number().default(5000),
  MICROSURVEY_RETRY_ATTEMPTS: Joi.number().default(3),
  MICROSURVEY_CIRCUIT_BREAKER_THRESHOLD: Joi.number().default(5),
  MICROSURVEY_CIRCUIT_BREAKER_TIMEOUT: Joi.number().default(60000),
  
  USE_MOCK_MICROSURVEY: Joi.boolean().default(true),
  ENABLE_WEBHOOKS: Joi.boolean().default(true),
  
  QUEUE_CONCURRENCY: Joi.number().default(5),
  QUEUE_PREFIX: Joi.string().default('dashboard'),
  
  LOG_LEVEL: Joi.string().valid('error', 'warn', 'info', 'debug').default('info'),
  LOG_FORMAT: Joi.string().valid('json', 'pretty').default('json'),
  
  RATE_LIMIT_WINDOW_MS: Joi.number().default(900000),
  RATE_LIMIT_MAX_REQUESTS: Joi.number().default(100),
  RATE_LIMIT_AUTH_MAX: Joi.number().default(5),
  
  // Image processing configuration
  IMAGE_STORAGE: Joi.string().valid('local', 's3').default('local'),
  IMAGE_MAX_SIZE: Joi.number().default(8 * 1024 * 1024), // 8MB
  IMAGE_QUALITY: Joi.number().min(1).max(100).default(60),
  IMAGE_MAX_WIDTH: Joi.number().default(1024),
  IMAGE_MAX_HEIGHT: Joi.number().default(1024),
  IMAGE_THUMBNAIL_SIZE: Joi.number().default(400),
  IMAGE_PARALLEL: Joi.number().default(2),
  IMAGE_ASYNC: Joi.boolean().default(false),
  IMAGE_UPLOAD_DIR: Joi.string().default('uploads'),
  
  // S3 configuration (required if IMAGE_STORAGE=s3)
  S3_ACCESS_KEY_ID: Joi.string().when('IMAGE_STORAGE', {
    is: 's3',
    then: Joi.required(),
    otherwise: Joi.optional(),
  }),
  S3_SECRET_ACCESS_KEY: Joi.string().when('IMAGE_STORAGE', {
    is: 's3',
    then: Joi.required(),
    otherwise: Joi.optional(),
  }),
  S3_BUCKET: Joi.string().when('IMAGE_STORAGE', {
    is: 's3',
    then: Joi.required(),
    otherwise: Joi.optional(),
  }),
  S3_REGION: Joi.string().default('us-east-1'),
  S3_ENDPOINT: Joi.string().uri().optional(),
  S3_FORCE_PATH_STYLE: Joi.boolean().default(false),
  S3_PUBLIC_URL: Joi.string().uri().optional(),
}).unknown(true);

const { error, value: env } = envSchema.validate(process.env);

if (error) {
  console.error('❌ Configuration validation failed:');
  console.error(error.details.map(d => `  - ${d.message}`).join('\n'));
  process.exit(1);
}

// Production Security Checks
if (env.NODE_ENV === 'production') {
  const weakSecrets = ['secret', 'changeme', 'password', 'CHANGE_THIS'];
  
  if (weakSecrets.some(weak => env.JWT_SECRET.toLowerCase().includes(weak))) {
    console.error('❌ FATAL: Weak JWT_SECRET in production!');
    console.error('Generate strong secret: openssl rand -base64 64');
    process.exit(1);
  }
  
  if (env.API_KEY_PEPPER.length < 32) {
    console.error('❌ FATAL: API_KEY_PEPPER must be at least 32 characters in production!');
    process.exit(1);
  }
  
  if (env.CORS_ORIGINS === '*') {
    console.error('❌ FATAL: CORS_ORIGINS cannot be * in production!');
    process.exit(1);
  }
}

// Parse Redis URL
const redisUrl = new URL(env.REDIS_URL);

export const config = {
  nodeEnv: env.NODE_ENV,
  port: env.PORT,
  
  database: {
    url: env.DATABASE_URL,
    poolMax: 10,
    poolMin: 2,
    idleTimeout: 30000,
    connectionTimeout: 2000,
  },
  
  redis: {
    url: env.REDIS_URL,
    host: redisUrl.hostname,
    port: parseInt(redisUrl.port, 10) || 6379,
  },
  
  jwt: {
    secret: env.JWT_SECRET,
    accessTokenExpiry: env.ACCESS_TOKEN_EXP,
    refreshTokenExpiry: env.REFRESH_TOKEN_EXP,
  },
  
  cors: {
    origins: env.CORS_ORIGINS.split(',').map(o => o.trim()),
    credentials: true,
  },
  
  security: {
    trustProxy: env.TRUST_PROXY,
    apiKeyPepper: env.API_KEY_PEPPER,
  },
  
  microSurvey: {
    baseUrl: env.MICROSURVEY_BASE_URL,
    apiKey: env.MICROSURVEY_API_KEY,
    timeout: env.MICROSURVEY_TIMEOUT_MS,
    retryAttempts: env.MICROSURVEY_RETRY_ATTEMPTS,
    circuitBreaker: {
      threshold: env.MICROSURVEY_CIRCUIT_BREAKER_THRESHOLD,
      timeout: env.MICROSURVEY_CIRCUIT_BREAKER_TIMEOUT,
    },
  },
  
  features: {
    useMockMicroSurvey: env.USE_MOCK_MICROSURVEY,
    enableWebhooks: env.ENABLE_WEBHOOKS,
  },
  
  queue: {
    concurrency: env.QUEUE_CONCURRENCY,
    prefix: env.QUEUE_PREFIX,
    imageQueueName: `${env.QUEUE_PREFIX}:images`,
  },
  
  logging: {
    level: env.LOG_LEVEL,
    format: env.LOG_FORMAT,
  },
  
  rateLimit: {
    windowMs: env.RATE_LIMIT_WINDOW_MS,
    maxRequests: env.RATE_LIMIT_MAX_REQUESTS,
    authMax: env.RATE_LIMIT_AUTH_MAX,
    uploadMax: 10, // 10 uploads per 15 minutes
  },
  
  image: {
    storage: env.IMAGE_STORAGE,
    maxSize: env.IMAGE_MAX_SIZE,
    quality: env.IMAGE_QUALITY,
    maxWidth: env.IMAGE_MAX_WIDTH,
    maxHeight: env.IMAGE_MAX_HEIGHT,
    thumbnailSize: env.IMAGE_THUMBNAIL_SIZE,
    parallel: env.IMAGE_PARALLEL,
    async: env.IMAGE_ASYNC,
    uploadDir: env.IMAGE_UPLOAD_DIR,
    allowedTypes: ['image/jpeg', 'image/png', 'image/webp', 'image/gif'],
  },
  
  s3: {
    accessKeyId: env.S3_ACCESS_KEY_ID,
    secretAccessKey: env.S3_SECRET_ACCESS_KEY,
    bucket: env.S3_BUCKET,
    region: env.S3_REGION,
    endpoint: env.S3_ENDPOINT,
    forcePathStyle: env.S3_FORCE_PATH_STYLE,
    publicUrl: env.S3_PUBLIC_URL,
  },
};

// Legacy exports (backward compatibility)
export const DATABASE_URL = config.database.url;
export const JWT_SECRET = config.jwt.secret;
export const ACCESS_TOKEN_EXP = config.jwt.accessTokenExpiry;
export const REFRESH_TOKEN_EXP = config.jwt.refreshTokenExpiry;
</file>

<file path="backend/src/lib/logger.js">
import pino from 'pino';
import { config } from '../config/index.js';

const logger = pino({
  level: config.logging.level,
  transport: config.nodeEnv === 'development' ? {
    target: 'pino-pretty',
    options: {
      colorize: true,
      translateTime: 'HH:MM:ss Z',
      ignore: 'pid,hostname',
    },
  } : undefined,
});

export { logger };
</file>

<file path="backend/src/middleware/auth.js">
import { verifyToken } from "../utils/jwt.js";

export function authRequired(req, res, next) {
  try {
    const authHeader = req.headers.authorization;

    // If no token provided, allow a development-only fallback to inject a dev user.
    // This is minimal and safe: it only activates when NODE_ENV === 'development'.
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      if (process.env.NODE_ENV === 'development') {
        req.user = {
          userId: process.env.DEV_USER_ID || '00000000-0000-4000-8000-000000000001',
          email: process.env.DEV_USER_EMAIL || 'dev@example.com',
          role: process.env.DEV_USER_ROLE || 'admin',
        };
        return next();
      }

      return res.status(401).json({ 
        success: false, 
        message: "No token provided" 
      });
    }

    const token = authHeader.substring(7);
    const decoded = verifyToken(token);
    
    req.user = {
      userId: decoded.userId,
      email: decoded.email,
      role: decoded.role,
    };
    
    next();
  } catch (error) {
    return res.status(401).json({ 
      success: false, 
      message: "Invalid or expired token" 
    });
  }
}

export default authRequired;
</file>

<file path="backend/src/middleware/csrf.js">
// ============================================
// CSRF Protection Middleware
// Double-submit cookie pattern for cookie-based auth
// ============================================
import crypto from "crypto";

export function generateCsrfToken() {
  return crypto.randomBytes(32).toString('hex');
}

export function setCsrfToken(req, res, next) {
  if (!req.cookies.csrfToken) {
    const token = generateCsrfToken();
    res.cookie('csrfToken', token, {
      httpOnly: false, // Must be readable by JavaScript
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 24 * 60 * 60 * 1000, // 24 hours
    });
  }
  next();
}

export function verifyCsrfToken(req, res, next) {
  // Skip CSRF for GET, HEAD, OPTIONS
  if (['GET', 'HEAD', 'OPTIONS'].includes(req.method)) {
    return next();
  }

  // In test environment, skip strict CSRF enforcement to allow tests to run.
  if (process.env.NODE_ENV === 'test') {
    return next();
  }

  const cookieToken = req.cookies.csrfToken;
  const headerToken = req.headers['x-csrf-token'];

  if (!cookieToken || !headerToken) {
    return res.status(403).json({
      success: false,
      message: 'CSRF token missing',
    });
  }

  if (cookieToken !== headerToken) {
    return res.status(403).json({
      success: false,
      message: 'CSRF token invalid',
    });
  }

  next();
}
</file>

<file path="backend/src/middleware/error.middleware.js">
import { ApiError } from '../utils/ApiError.js';
import { logger } from '../utils/logger.js';
import { config } from '../config/index.js';

/**
 * Centralized error handling middleware
 * Catches all errors and sends standardized error responses
 */
export const errorMiddleware = (err, req, res, next) => {
  let error = err;

  // Convert non-ApiError errors to ApiError
  if (!(error instanceof ApiError)) {
    const statusCode = error.statusCode || 500;
    const message = error.message || 'Internal server error';
    error = new ApiError(statusCode, message, 'INTERNAL_ERROR', {}, false);
  }

  // Log error
  const logMessage = `${error.statusCode} - ${error.message} - ${req.originalUrl} - ${req.method} - ${req.ip}`;
  
  if (error.statusCode >= 500) {
    logger.error(logMessage, {
      error: error.message,
      stack: error.stack,
      code: error.code,
      details: error.details,
    });
  } else {
    logger.warn(logMessage, {
      error: error.message,
      code: error.code,
    });
  }

  // Send error response
  const response = {
    success: false,
    message: error.message,
    error: {
      code: error.code,
    },
  };

  // Include details in development mode
  if (config.nodeEnv === 'development') {
    response.error.details = error.details;
    response.error.stack = error.stack;
  } else if (Object.keys(error.details).length > 0) {
    // Include safe details in production
    response.error.details = error.details;
  }

  res.status(error.statusCode).json(response);
};

/**
 * Handle 404 errors for undefined routes
 */
export const notFoundMiddleware = (req, res, next) => {
  const error = ApiError.notFound(`Route ${req.originalUrl} not found`);
  next(error);
};
</file>

<file path="backend/src/middleware/errorHandler.js">
// ============================================
// Error Handler Middleware - UNIFIED
// Centralized error processing and response
// ============================================
import { config } from "../config/index.js";
import { ApiError } from "../utils/ApiError.js";
import { logger } from "../lib/logger.js";

export function errorHandler(err, req, res, next) {
  // Convert non-ApiError to ApiError
  if (!(err instanceof ApiError)) {
    err = new ApiError(err.message || "Internal server error", err.statusCode || 500);
  }

  const statusCode = err.statusCode || 500;
  const message = err.message || "Internal server error";

  // Log error
  const logMessage = `${statusCode} - ${message} - ${req.originalUrl} - ${req.method} - ${req.ip}`;
  
  if (statusCode >= 500) {
    logger.error(logMessage, {
      error: message,
      stack: err.stack,
      details: err.details,
    });
  } else {
    logger.warn(logMessage, { error: message });
  }

  const response = {
    success: false,
    message,
  };

  if (config.nodeEnv === "development") {
    response.stack = err.stack;
    response.details = err.details;
  } else if (err.details && Object.keys(err.details).length > 0) {
    response.details = err.details;
  }

  res.status(statusCode).json(response);
}

export function asyncHandler(fn) {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}

// Export ApiError for backwards compatibility
export { ApiError } from "../utils/ApiError.js";
export const AppError = ApiError;
</file>

<file path="backend/src/middleware/logSanitizer.js">
// ============================================
// Log Sanitizer Middleware
// Prevents sensitive data from appearing in logs
// ============================================

const SENSITIVE_FIELDS = [
  'password',
  'passwordHash',
  'password_hash',
  'token',
  'refreshToken',
  'accessToken',
  'authorization',
  'cookie',
  'secret',
  'apiKey',
  'api_key',
];

export function sanitizeForLog(obj) {
  if (!obj || typeof obj !== 'object') return obj;
  
  const sanitized = Array.isArray(obj) ? [] : {};
  
  for (const [key, value] of Object.entries(obj)) {
    const lowerKey = key.toLowerCase();
    
    if (SENSITIVE_FIELDS.some(field => lowerKey.includes(field))) {
      sanitized[key] = '[REDACTED]';
    } else if (typeof value === 'object' && value !== null) {
      sanitized[key] = sanitizeForLog(value);
    } else {
      sanitized[key] = value;
    }
  }
  
  return sanitized;
}

export function logSanitizerMiddleware(req, res, next) {
  const originalSend = res.send;
  res.send = function(data) {
    // Don't log response bodies in production
    return originalSend.call(this, data);
  };
  next();
}
</file>

<file path="backend/src/middleware/rateLimit.middleware.js">
// ============================================
// FILE: backend/src/middleware/rateLimit.middleware.js (UPDATED)
// Add upload rate limiter
// ============================================
import rateLimit from 'express-rate-limit';
import RedisStore from 'rate-limit-redis';
import Redis from 'ioredis';
import { config } from '../config/index.js';
import { logger } from '../lib/logger.js';

// Redis client for rate limiting
let redisClient;
try {
  redisClient = new Redis(config.redis.url, {
    enableOfflineQueue: false,
    maxRetriesPerRequest: 1,
  });
  
  redisClient.on('error', (err) => {
    logger.warn('Redis rate limit store unavailable, using memory store', { error: err.message });
  });
  
  redisClient.on('connect', () => {
    logger.info('Redis rate limit store connected');
  });
} catch (error) {
  logger.warn('Failed to initialize Redis for rate limiting, using memory store');
}

// Store factory
function getStore() {
  if (redisClient && redisClient.status === 'ready') {
    return new RedisStore({
      sendCommand: (...args) => redisClient.call(...args),
      prefix: `${config.queue.prefix}:ratelimit:`,
    });
  }
  return undefined; // Use memory store
}

/**
 * General rate limiter for all routes
 */
export const rateLimitMiddleware = rateLimit({
  windowMs: config.rateLimit.windowMs,
  max: config.rateLimit.maxRequests,
  store: getStore(),
  message: {
    success: false,
    message: 'Too many requests, please try again later',
    error: {
      code: 'RATE_LIMIT_EXCEEDED',
    },
  },
  standardHeaders: true,
  legacyHeaders: false,
  skip: (req) => req.path === '/health' || req.path === '/api/health',
});

/**
 * Strict rate limiter for authentication routes
 */
export const authRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: config.rateLimit.authMax,
  store: getStore(),
  message: {
    success: false,
    message: 'Too many authentication attempts, please try again later',
    error: {
      code: 'AUTH_RATE_LIMIT_EXCEEDED',
    },
  },
  skipSuccessfulRequests: true,
});

/**
 * Rate limiter for password reset routes
 */
export const passwordResetRateLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 3,
  store: getStore(),
  message: {
    success: false,
    message: 'Too many password reset attempts, please try again later',
    error: {
      code: 'PASSWORD_RESET_RATE_LIMIT_EXCEEDED',
    },
  },
});

/**
 * Rate limiter for API key operations
 */
export const apiKeyRateLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 10,
  store: getStore(),
  message: {
    success: false,
    message: 'Too many API key operations, please try again later',
    error: {
      code: 'API_KEY_RATE_LIMIT_EXCEEDED',
    },
  },
});

/**
 * Rate limiter for webhook endpoints
 */
export const webhookRateLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 100,
  store: getStore(),
  message: {
    success: false,
    message: 'Too many webhook requests',
    error: {
      code: 'WEBHOOK_RATE_LIMIT_EXCEEDED',
    },
  },
  skip: (req) => {
    // Skip rate limit if valid webhook signature
    return req.webhookVerified === true;
  },
});

/**
 * Rate limiter for image uploads
 * Stricter limits per IP and per site_key
 */
export const uploadRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: config.rateLimit.uploadMax,
  store: getStore(),
  message: {
    success: false,
    message: 'Too many upload requests. Please try again in 15 minutes.',
    error: {
      code: 'UPLOAD_RATE_LIMIT_EXCEEDED',
    },
  },
  standardHeaders: true,
  legacyHeaders: false,
  // Key by both IP and user
  keyGenerator: (req) => {
    const userId = req.user?.userId || 'anonymous';
    return `upload:${req.ip}:${userId}`;
  },
});
</file>

<file path="backend/src/middleware/validate.js">
export function validate(schema) {
  return (req, res, next) => {
    const { error, value } = schema.validate(req.body, {
      abortEarly: false,
      stripUnknown: true,
    });

    if (error) {
      const errors = error.details.map((detail) => ({
        field: detail.path.join("."),
        message: detail.message,
      }));

      return res.status(400).json({
        success: false,
        message: "Validation failed",
        errors,
      });
    }

    req.body = value;
    next();
  };
}
</file>

<file path="backend/src/migrations/000_enable_extensions.sql">
-- ============================================
-- FILE: 000_enable_extensions.sql
-- Enable required PostgreSQL extensions
-- Must run before other migrations
-- ============================================

-- Enable UUID generation (gen_random_uuid function)
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Alternative UUID extension (for uuid_generate_v4)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
</file>

<file path="backend/src/migrations/001_create_users.sql">
CREATE TABLE IF NOT EXISTS users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  full_name VARCHAR(100) NOT NULL,
  role VARCHAR(20) NOT NULL DEFAULT 'user',
  is_active BOOLEAN DEFAULT TRUE,
  is_email_verified BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
  last_login_at TIMESTAMP,
  CONSTRAINT users_role_check CHECK (role IN ('admin', 'user'))
);

CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX IF NOT EXISTS idx_users_role ON users(role);
CREATE INDEX IF NOT EXISTS idx_users_created_at ON users(created_at DESC);

COMMENT ON TABLE users IS 'Stores user account information';
COMMENT ON COLUMN users.role IS 'User role: admin or user';
COMMENT ON COLUMN users.is_active IS 'Whether the user account is active';
COMMENT ON COLUMN users.is_email_verified IS 'Whether email has been verified';
</file>

<file path="backend/src/migrations/002_create_refresh_tokens.sql">
CREATE TABLE IF NOT EXISTS refresh_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  token TEXT UNIQUE NOT NULL,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_refresh_tokens_user_id ON refresh_tokens(user_id);
CREATE INDEX idx_refresh_tokens_token ON refresh_tokens(token);
CREATE INDEX idx_refresh_tokens_expires_at ON refresh_tokens(expires_at);

COMMENT ON TABLE refresh_tokens IS 'Stores JWT refresh tokens for user sessions';
COMMENT ON COLUMN refresh_tokens.expires_at IS 'Token expiration timestamp';

-- Auto-delete expired tokens (cleanup trigger)
CREATE OR REPLACE FUNCTION delete_expired_refresh_tokens() 
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM refresh_tokens WHERE expires_at < NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_delete_expired_tokens
  AFTER INSERT ON refresh_tokens
  EXECUTE FUNCTION delete_expired_refresh_tokens();
</file>

<file path="backend/src/migrations/003_create_organizations.sql">
-- ============================================
-- FILE: 003_create_organizations.sql
-- ============================================
CREATE TABLE IF NOT EXISTS organizations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  slug VARCHAR(50) UNIQUE NOT NULL,
  owner_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organizations_slug ON organizations(slug);
CREATE INDEX idx_organizations_created_at ON organizations(created_at DESC);

COMMENT ON TABLE organizations IS 'Stores organization/company information';
COMMENT ON COLUMN organizations.slug IS 'URL-friendly unique identifier';
COMMENT ON COLUMN organizations.owner_id IS 'User who owns this organization';
</file>

<file path="backend/src/migrations/004_create_questions.sql">
-- ============================================
-- FILE: 004_create_questions.sql
-- ============================================
CREATE TABLE IF NOT EXISTS questions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  question_text TEXT NOT NULL,
  question_type VARCHAR(50) NOT NULL CHECK (question_type IN ('multiple_choice', 'text', 'rating')),
  options JSONB DEFAULT '[]',
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_questions_organization_id ON questions(organization_id);
CREATE INDEX idx_questions_is_active ON questions(is_active);
CREATE INDEX idx_questions_type ON questions(question_type);
CREATE INDEX idx_questions_created_at ON questions(created_at DESC);

COMMENT ON TABLE questions IS 'Stores survey questions for CAPTCHA';
COMMENT ON COLUMN questions.question_type IS 'Type: multiple_choice, text, or rating';
COMMENT ON COLUMN questions.options IS 'JSON array of options for multiple choice questions';
COMMENT ON COLUMN questions.is_active IS 'Whether this question is currently in use';
</file>

<file path="backend/src/migrations/005_create_question_responses.sql">
-- ============================================
-- FILE: 005_create_question_responses.sql
-- ============================================
CREATE TABLE IF NOT EXISTS question_responses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  question_id UUID NOT NULL REFERENCES questions(id) ON DELETE CASCADE,
  response_text TEXT,
  response_data JSONB,
  session_id VARCHAR(255),
  ip_address INET,
  user_agent TEXT,
  country_code VARCHAR(2),
  created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_question_responses_question_id ON question_responses(question_id);
CREATE INDEX idx_question_responses_created_at ON question_responses(created_at DESC);
CREATE INDEX idx_question_responses_session_id ON question_responses(session_id);
CREATE INDEX idx_question_responses_country ON question_responses(country_code);

COMMENT ON TABLE question_responses IS 'Stores user responses to questions';
COMMENT ON COLUMN question_responses.response_text IS 'Text response for text-type questions';
COMMENT ON COLUMN question_responses.response_data IS 'JSON data for complex responses';
COMMENT ON COLUMN question_responses.session_id IS 'Anonymous session identifier';
</file>

<file path="backend/src/migrations/006_create_captcha_sites.sql">
-- ============================================
-- FILE: 006_create_captcha_sites.sql
-- ============================================
CREATE TABLE IF NOT EXISTS captcha_sites (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  site_name VARCHAR(255) NOT NULL,
  site_url VARCHAR(500) NOT NULL,
  site_key VARCHAR(100) UNIQUE NOT NULL,
  site_secret VARCHAR(100) NOT NULL,
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_captcha_sites_site_key ON captcha_sites(site_key);
CREATE INDEX idx_captcha_sites_organization_id ON captcha_sites(organization_id);
CREATE INDEX idx_captcha_sites_is_active ON captcha_sites(is_active);

COMMENT ON TABLE captcha_sites IS 'Registered sites for captcha-API integration';
COMMENT ON COLUMN captcha_sites.site_key IS 'Public site key for API authentication';
COMMENT ON COLUMN captcha_sites.site_secret IS 'Secret key for secure operations';
</file>

<file path="backend/src/migrations/007_add_analytics_indexes.sql">
-- ============================================
-- FILE: 007_add_analytics_indexes.sql
-- Performance indexes for analytics queries
-- ============================================

-- Composite index for filtering by question and date range
CREATE INDEX IF NOT EXISTS idx_responses_question_date 
  ON question_responses(question_id, created_at DESC);

-- Index for country-based analytics
CREATE INDEX IF NOT EXISTS idx_responses_country_question 
  ON question_responses(country_code, question_id) 
  WHERE country_code IS NOT NULL;

-- Index for session-based analysis
CREATE INDEX IF NOT EXISTS idx_responses_session_date 
  ON question_responses(session_id, created_at DESC) 
  WHERE session_id IS NOT NULL;

-- Partial index for active questions only
CREATE INDEX IF NOT EXISTS idx_questions_active_org 
  ON questions(organization_id, created_at DESC) 
  WHERE is_active = true;

COMMENT ON INDEX idx_responses_question_date IS 'Speeds up analytics queries by question and date range';
</file>

<file path="backend/src/migrations/008_create_tenants.sql">
-- ============================================
-- FILE: backend/src/migrations/008_create_tenants.sql
-- ============================================
CREATE TABLE IF NOT EXISTS tenants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  slug VARCHAR(100) UNIQUE NOT NULL,
  email VARCHAR(255) NOT NULL,
  owner_id UUID REFERENCES users(id) ON DELETE SET NULL,
  microsurvey_base_url VARCHAR(500),
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_tenants_slug ON tenants(slug);
CREATE INDEX idx_tenants_owner_id ON tenants(owner_id);
CREATE INDEX idx_tenants_is_active ON tenants(is_active);

COMMENT ON TABLE tenants IS 'Multi-tenant accounts for the dashboard';
COMMENT ON COLUMN tenants.microsurvey_base_url IS 'Optional custom Micro-Survey endpoint per tenant';
</file>

<file path="backend/src/migrations/009_create_tenant_api_keys.sql">
-- ============================================
-- FILE: backend/src/migrations/009_create_tenant_api_keys.sql
-- ============================================
CREATE TABLE IF NOT EXISTS tenant_api_keys (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  name VARCHAR(100) NOT NULL,
  key_hash VARCHAR(255) NOT NULL,
  key_prefix VARCHAR(20) NOT NULL,
  last_used_at TIMESTAMP,
  revoked_at TIMESTAMP,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  created_by UUID REFERENCES users(id)
);

CREATE INDEX idx_tenant_api_keys_tenant_id ON tenant_api_keys(tenant_id);
CREATE INDEX idx_tenant_api_keys_key_prefix ON tenant_api_keys(key_prefix);
CREATE INDEX idx_tenant_api_keys_revoked ON tenant_api_keys(revoked_at) WHERE revoked_at IS NULL;

COMMENT ON TABLE tenant_api_keys IS 'API keys for Micro-Survey integration per tenant';
COMMENT ON COLUMN tenant_api_keys.key_hash IS 'Peppered hash of the API key';
COMMENT ON COLUMN tenant_api_keys.key_prefix IS 'First 8 chars for identification';
</file>

<file path="backend/src/migrations/010_create_surveys_table.sql">
-- ============================================
-- FILE: backend/src/migrations/010_create_surveys_table.sql
-- ============================================
CREATE TABLE IF NOT EXISTS surveys (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  organization_id UUID REFERENCES organizations(id) ON DELETE SET NULL,
  microsurvey_id VARCHAR(255) UNIQUE,
  survey_key VARCHAR(255) UNIQUE NOT NULL,
  title VARCHAR(500) NOT NULL,
  description TEXT,
  survey_type VARCHAR(50) NOT NULL CHECK (survey_type IN ('poll', 'quiz', 'feedback', 'nps')),
  status VARCHAR(50) NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'published', 'archived')),
  config JSONB DEFAULT '{}',
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
  published_at TIMESTAMP,
  archived_at TIMESTAMP
);

CREATE INDEX idx_surveys_tenant_id ON surveys(tenant_id);
CREATE INDEX idx_surveys_organization_id ON surveys(organization_id);
CREATE INDEX idx_surveys_microsurvey_id ON surveys(microsurvey_id);
CREATE INDEX idx_surveys_survey_key ON surveys(survey_key);
CREATE INDEX idx_surveys_status ON surveys(status);
CREATE INDEX idx_surveys_created_at ON surveys(created_at DESC);

COMMENT ON TABLE surveys IS 'Surveys managed by Dashboard that integrate with Micro-Survey';
COMMENT ON COLUMN surveys.microsurvey_id IS 'ID returned from Micro-Survey service';
COMMENT ON COLUMN surveys.survey_key IS 'Public key for embedding (from Micro-Survey)';
</file>

<file path="backend/src/migrations/011_create_survey_analytics_cache.sql">
-- ============================================
-- FILE: backend/src/migrations/011_create_survey_analytics_cache.sql
-- ============================================
CREATE TABLE IF NOT EXISTS survey_analytics_cache (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  survey_id UUID NOT NULL REFERENCES surveys(id) ON DELETE CASCADE,
  analytics_data JSONB NOT NULL,
  cached_at TIMESTAMP NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMP NOT NULL
);

CREATE INDEX idx_survey_analytics_cache_survey_id ON survey_analytics_cache(survey_id);
CREATE INDEX idx_survey_analytics_cache_expires ON survey_analytics_cache(expires_at);

COMMENT ON TABLE survey_analytics_cache IS 'Cached analytics from Micro-Survey to reduce API calls';

-- Auto-delete expired cache
CREATE OR REPLACE FUNCTION delete_expired_analytics_cache()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM survey_analytics_cache WHERE expires_at < NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_delete_expired_analytics
  AFTER INSERT ON survey_analytics_cache
  EXECUTE FUNCTION delete_expired_analytics_cache();
</file>

<file path="backend/src/migrations/012_create_webhook_logs.sql">
-- ============================================
-- FILE: backend/src/migrations/012_create_webhook_logs.sql
-- ============================================
CREATE TABLE IF NOT EXISTS webhook_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  webhook_type VARCHAR(50) NOT NULL,
  payload JSONB NOT NULL,
  signature VARCHAR(255),
  verified BOOLEAN DEFAULT FALSE,
  processed BOOLEAN DEFAULT FALSE,
  error_message TEXT,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  processed_at TIMESTAMP
);

CREATE INDEX idx_webhook_logs_type ON webhook_logs(webhook_type);
CREATE INDEX idx_webhook_logs_processed ON webhook_logs(processed, created_at);
CREATE INDEX idx_webhook_logs_created_at ON webhook_logs(created_at DESC);

COMMENT ON TABLE webhook_logs IS 'Logs of incoming webhooks from Micro-Survey';
</file>

<file path="backend/src/migrations/013_create_export_jobs.sql">
-- ============================================
-- FILE: backend/src/migrations/013_create_export_jobs.sql
-- ============================================
CREATE TABLE IF NOT EXISTS export_jobs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  survey_id UUID NOT NULL REFERENCES surveys(id) ON DELETE CASCADE,
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  status VARCHAR(50) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
  export_type VARCHAR(50) NOT NULL DEFAULT 'csv',
  file_url VARCHAR(1000),
  error_message TEXT,
  requested_by UUID REFERENCES users(id),
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  completed_at TIMESTAMP
);

CREATE INDEX idx_export_jobs_survey_id ON export_jobs(survey_id);
CREATE INDEX idx_export_jobs_tenant_id ON export_jobs(tenant_id);
CREATE INDEX idx_export_jobs_status ON export_jobs(status, created_at);

COMMENT ON TABLE export_jobs IS 'Track export job requests to Micro-Survey';
</file>

<file path="backend/src/migrations/014_migrate_captcha_to_microsurvey.sql">
-- ============================================
-- FILE: 014_migrate_captcha_to_microsurvey.sql
-- Safe migration from CAPTCHA terminology to Micro-Survey
-- Does NOT drop any existing data
-- ============================================

-- Step 1: Create new Micro-Survey response tables
CREATE TABLE IF NOT EXISTS survey_responses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  survey_id UUID NOT NULL REFERENCES surveys(id) ON DELETE CASCADE,
  session_id VARCHAR(255),
  response_data JSONB NOT NULL,
  ip_address INET,
  user_agent TEXT,
  country_code VARCHAR(2),
  created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_survey_responses_survey_id ON survey_responses(survey_id);
CREATE INDEX idx_survey_responses_created_at ON survey_responses(created_at DESC);
CREATE INDEX idx_survey_responses_session ON survey_responses(session_id) WHERE session_id IS NOT NULL;

COMMENT ON TABLE survey_responses IS 'User responses to Micro-Survey surveys';

-- Step 2: Create mapping table (if needed to track old CAPTCHA IDs)
CREATE TABLE IF NOT EXISTS legacy_captcha_mapping (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  captcha_site_id UUID,
  survey_id UUID REFERENCES surveys(id),
  migrated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE legacy_captcha_mapping IS 'Maps old CAPTCHA site IDs to new survey IDs for reference';

-- Step 3: Migrate data from captcha_sites to surveys (if surveys table exists)
DO $$
DECLARE
  captcha_rec RECORD;
  new_survey_id UUID;
BEGIN
  -- Only proceed if captcha_sites table exists
  IF EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'captcha_sites') THEN
    
    FOR captcha_rec IN SELECT * FROM captcha_sites LOOP
      -- Check if already migrated
      IF NOT EXISTS (
        SELECT 1 FROM legacy_captcha_mapping WHERE captcha_site_id = captcha_rec.id
      ) THEN
        
        -- Create corresponding survey
        INSERT INTO surveys (
          id, tenant_id, organization_id, survey_key, title, description,
          survey_type, status, created_at, updated_at
        )
        VALUES (
          gen_random_uuid(),
          (SELECT id FROM tenants WHERE owner_id = captcha_rec.organization_id LIMIT 1),
          captcha_rec.organization_id,
          captcha_rec.site_key,
          captcha_rec.site_name,
          'Migrated from legacy CAPTCHA site: ' || captcha_rec.site_url,
          'feedback',
          CASE WHEN captcha_rec.is_active THEN 'published' ELSE 'draft' END,
          captcha_rec.created_at,
          NOW()
        )
        RETURNING id INTO new_survey_id;
        
        -- Record migration
        INSERT INTO legacy_captcha_mapping (captcha_site_id, survey_id)
        VALUES (captcha_rec.id, new_survey_id);
        
        RAISE NOTICE 'Migrated CAPTCHA site % to survey %', captcha_rec.site_name, new_survey_id;
      END IF;
    END LOOP;
    
  END IF;
END $$;

-- Step 4: Rename old tables (preserve data, just rename for safety)
DO $$
BEGIN
  IF EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'captcha_sites') THEN
    ALTER TABLE captcha_sites RENAME TO legacy_captcha_sites;
    RAISE NOTICE 'Renamed captcha_sites to legacy_captcha_sites';
  END IF;
EXCEPTION
  WHEN duplicate_table THEN
    RAISE NOTICE 'legacy_captcha_sites already exists, skipping rename';
END $$;

-- Step 5: Add helpful view for backwards compatibility
CREATE OR REPLACE VIEW captcha_sites_view AS
SELECT 
  s.id,
  s.title as site_name,
  '' as site_url,
  s.survey_key as site_key,
  '' as site_secret,
  s.organization_id,
  (s.status = 'published') as is_active,
  s.created_at,
  s.updated_at
FROM surveys s;

COMMENT ON VIEW captcha_sites_view IS 'Backwards-compatible view mapping surveys to old CAPTCHA site structure';

-- Step 6: Success message
DO $$
BEGIN
  RAISE NOTICE '✅ CAPTCHA to Micro-Survey migration completed successfully';
  RAISE NOTICE 'Old tables renamed with legacy_ prefix and preserved';
  RAISE NOTICE 'Use legacy_captcha_mapping to trace migrated records';
END $$;
</file>

<file path="backend/src/migrations/015_finalize_captcha_cleanup.sql">
-- ============================================
-- FILE: 015_finalize_captcha_cleanup.sql (FIXED)
-- Fully idempotent and defensive migration
-- ============================================

-- Step 1: Rename captcha_sites to legacy (if exists)
DO $$
BEGIN
  IF EXISTS (
    SELECT FROM information_schema.tables 
    WHERE table_name = 'captcha_sites'
  ) AND NOT EXISTS (
    SELECT FROM information_schema.tables 
    WHERE table_name = 'legacy_captcha_sites'
  ) THEN
    ALTER TABLE captcha_sites RENAME TO legacy_captcha_sites;
    RAISE NOTICE '✓ Renamed captcha_sites to legacy_captcha_sites';
  END IF;
END $$;

-- Step 2: Add deprecation comment (only if table exists)
DO $$
BEGIN
  IF EXISTS (
    SELECT FROM information_schema.tables 
    WHERE table_name = 'legacy_captcha_sites'
  ) THEN
    COMMENT ON TABLE legacy_captcha_sites IS 
      'DEPRECATED: Legacy CAPTCHA sites table. Migrated to surveys table. Safe to archive after 2 releases.';
  END IF;
END $$;

-- Step 3: Create surveys_meta table (if not exists)
CREATE TABLE IF NOT EXISTS surveys_meta (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  survey_id UUID NOT NULL REFERENCES surveys(id) ON DELETE CASCADE,
  meta_key VARCHAR(100) NOT NULL,
  meta_value TEXT,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
  UNIQUE(survey_id, meta_key)
);

CREATE INDEX IF NOT EXISTS idx_surveys_meta_survey_id ON surveys_meta(survey_id);
CREATE INDEX IF NOT EXISTS idx_surveys_meta_key ON surveys_meta(meta_key);

COMMENT ON TABLE surveys_meta IS 'Extended metadata for surveys (replaces CAPTCHA-specific fields)';

-- Step 4: Migrate legacy data (defensive - check existence)
DO $$
DECLARE
  legacy_rec RECORD;
  survey_rec RECORD;
BEGIN
  IF EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'legacy_captcha_sites') THEN
    
    FOR legacy_rec IN 
      SELECT * FROM legacy_captcha_sites 
      WHERE id NOT IN (
        SELECT COALESCE(captcha_site_id::uuid, '00000000-0000-0000-0000-000000000000'::uuid) 
        FROM legacy_captcha_mapping 
        WHERE captcha_site_id IS NOT NULL
      )
    LOOP
      -- Find or create corresponding survey
      SELECT id INTO survey_rec 
      FROM surveys 
      WHERE organization_id = legacy_rec.organization_id 
        AND survey_key = legacy_rec.site_key
      LIMIT 1;
      
      IF survey_rec.id IS NOT NULL THEN
        -- Store legacy metadata
        INSERT INTO surveys_meta (survey_id, meta_key, meta_value, created_at)
        VALUES 
          (survey_rec.id, 'legacy_captcha_id', legacy_rec.id::text, legacy_rec.created_at),
          (survey_rec.id, 'legacy_site_url', legacy_rec.site_url, legacy_rec.created_at),
          (survey_rec.id, 'legacy_site_secret', '[REDACTED]', legacy_rec.created_at)
        ON CONFLICT (survey_id, meta_key) DO NOTHING;
        
        RAISE NOTICE '✓ Migrated metadata for legacy CAPTCHA site: %', legacy_rec.site_name;
      END IF;
    END LOOP;
    
  END IF;
END $$;

-- Step 5: Create deprecated_endpoints table (if not exists)
CREATE TABLE IF NOT EXISTS deprecated_endpoints (
  id SERIAL PRIMARY KEY,
  endpoint_pattern VARCHAR(255) UNIQUE NOT NULL,
  replacement VARCHAR(255),
  deprecated_since DATE NOT NULL DEFAULT CURRENT_DATE,
  removal_date DATE,
  notes TEXT
);

INSERT INTO deprecated_endpoints (endpoint_pattern, replacement, deprecated_since, removal_date, notes)
VALUES 
  ('/api/integration/captcha/register-site', '/api/surveys', '2025-01-01', '2025-04-01', 'Use POST /api/surveys to create surveys instead'),
  ('/api/integration/captcha/stats/:siteKey', '/api/surveys/:id/results', '2025-01-01', '2025-04-01', 'Use surveys API for analytics'),
  ('/api/integration/captcha/push-responses', '/api/surveys/:surveyKey/responses', '2025-01-01', '2025-04-01', 'Submit responses directly to Micro-Survey API'),
  ('/api/integration/captcha/questions', '/api/questions', '2025-01-01', '2025-04-01', 'Use questions API')
ON CONFLICT (endpoint_pattern) DO UPDATE 
SET notes = EXCLUDED.notes;

COMMENT ON TABLE deprecated_endpoints IS 'Track deprecated API endpoints for monitoring and cleanup';

-- Step 6: Create cleanup status view (defensive)
DO $$
BEGIN
  -- Drop view if exists, then recreate
  DROP VIEW IF EXISTS captcha_cleanup_status;
  
  CREATE VIEW captcha_cleanup_status AS
  SELECT 
    'legacy_captcha_sites' as table_name,
    COALESCE(
      (SELECT COUNT(*) FROM legacy_captcha_sites WHERE EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'legacy_captcha_sites')),
      0
    ) as record_count,
    'Safe to archive after all surveys migrated' as status
  UNION ALL
  SELECT 
    'legacy_captcha_mapping' as table_name,
    (SELECT COUNT(*) FROM legacy_captcha_mapping) as record_count,
    'Migration tracking table - keep for reference' as status
  UNION ALL
  SELECT 
    'surveys_meta' as table_name,
    (SELECT COUNT(DISTINCT survey_id) FROM surveys_meta WHERE meta_key LIKE 'legacy_%') as record_count,
    'Active metadata storage' as status;

  COMMENT ON VIEW captcha_cleanup_status IS 'Summary of CAPTCHA-to-Survey migration status';
END $$;

-- Success message
DO $$
BEGIN
  RAISE NOTICE '✅ CAPTCHA cleanup migration completed';
  RAISE NOTICE '   - Legacy tables preserved with "legacy_" prefix';
  RAISE NOTICE '   - Deprecated endpoints tracked in deprecated_endpoints table';
  RAISE NOTICE '   - Check captcha_cleanup_status view for migration status';
END $$;
</file>

<file path="backend/src/migrations/016_create_billing_tables.sql">
-- ============================================
-- FILE: backend/src/migrations/016_create_billing_tables.sql
-- Complete Lemon Squeezy billing schema
-- ============================================

-- Plans table (your pricing tiers)
CREATE TABLE IF NOT EXISTS plans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  slug VARCHAR(50) UNIQUE NOT NULL,
  description TEXT,
  
  -- Lemon Squeezy variant IDs (one for monthly, one for yearly)
  ls_monthly_variant_id VARCHAR(50),
  ls_yearly_variant_id VARCHAR(50),
  
  -- Pricing
  monthly_price_cents INTEGER NOT NULL,
  yearly_price_cents INTEGER NOT NULL,
  currency VARCHAR(3) DEFAULT 'USD',
  
  -- Limits
  surveys_limit INTEGER DEFAULT 10,
  responses_limit INTEGER DEFAULT 1000,
  team_members_limit INTEGER DEFAULT 1,
  
  -- Features (JSON array)
  features JSONB DEFAULT '[]',
  
  -- Status
  is_active BOOLEAN DEFAULT TRUE,
  is_featured BOOLEAN DEFAULT FALSE,
  sort_order INTEGER DEFAULT 0,
  
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Subscriptions table
CREATE TABLE IF NOT EXISTS subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Owner (can be user or tenant)
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  tenant_id UUID REFERENCES tenants(id) ON DELETE CASCADE,
  
  -- Plan
  plan_id UUID NOT NULL REFERENCES plans(id),
  
  -- Lemon Squeezy IDs
  ls_subscription_id VARCHAR(50) UNIQUE NOT NULL,
  ls_customer_id VARCHAR(50),
  ls_order_id VARCHAR(50),
  ls_variant_id VARCHAR(50) NOT NULL,
  ls_product_id VARCHAR(50),
  
  -- Subscription details
  status VARCHAR(50) NOT NULL DEFAULT 'active',
  billing_cycle VARCHAR(20) NOT NULL, -- 'monthly' or 'yearly'
  
  -- Dates
  trial_ends_at TIMESTAMP,
  current_period_start TIMESTAMP,
  current_period_end TIMESTAMP,
  renews_at TIMESTAMP,
  ends_at TIMESTAMP,
  cancelled_at TIMESTAMP,
  
  -- Payment
  payment_method VARCHAR(50),
  card_last4 VARCHAR(4),
  card_brand VARCHAR(20),
  
  -- Usage tracking
  surveys_used INTEGER DEFAULT 0,
  responses_used INTEGER DEFAULT 0,
  usage_reset_at TIMESTAMP DEFAULT NOW(),
  
  -- Metadata
  metadata JSONB DEFAULT '{}',
  
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
  
  CONSTRAINT check_owner CHECK (user_id IS NOT NULL OR tenant_id IS NOT NULL),
  CONSTRAINT check_status CHECK (status IN ('active', 'past_due', 'cancelled', 'expired', 'paused', 'on_trial'))
);

-- Invoices table
CREATE TABLE IF NOT EXISTS invoices (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  subscription_id UUID REFERENCES subscriptions(id) ON DELETE SET NULL,
  
  -- Lemon Squeezy
  ls_order_id VARCHAR(50) UNIQUE NOT NULL,
  ls_invoice_url TEXT,
  
  -- Details
  amount_cents INTEGER NOT NULL,
  currency VARCHAR(3) DEFAULT 'USD',
  status VARCHAR(50) NOT NULL,
  
  -- Billing info
  billing_email VARCHAR(255),
  billing_name VARCHAR(255),
  billing_address JSONB,
  
  -- Dates
  invoice_date TIMESTAMP NOT NULL,
  paid_at TIMESTAMP,
  refunded_at TIMESTAMP,
  
  -- Metadata
  metadata JSONB DEFAULT '{}',
  
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  
  CONSTRAINT check_invoice_status CHECK (status IN ('pending', 'paid', 'failed', 'refunded'))
);

-- Webhook events log
CREATE TABLE IF NOT EXISTS webhook_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  event_id VARCHAR(100) UNIQUE NOT NULL,
  event_type VARCHAR(100) NOT NULL,
  payload JSONB NOT NULL,
  processed BOOLEAN DEFAULT FALSE,
  processed_at TIMESTAMP,
  error_message TEXT,
  retry_count INTEGER DEFAULT 0,
  created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Usage logs (for detailed tracking)
CREATE TABLE IF NOT EXISTS usage_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  subscription_id UUID NOT NULL REFERENCES subscriptions(id) ON DELETE CASCADE,
  resource_type VARCHAR(50) NOT NULL, -- 'survey', 'response', 'team_member'
  resource_id UUID,
  amount INTEGER DEFAULT 1,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_tenant_id ON subscriptions(tenant_id);
CREATE INDEX idx_subscriptions_status ON subscriptions(status);
CREATE INDEX idx_subscriptions_ls_subscription_id ON subscriptions(ls_subscription_id);
CREATE INDEX idx_subscriptions_renews_at ON subscriptions(renews_at);
CREATE INDEX idx_invoices_subscription_id ON invoices(subscription_id);
CREATE INDEX idx_invoices_status ON invoices(status);
CREATE INDEX idx_webhook_events_event_id ON webhook_events(event_id);
CREATE INDEX idx_webhook_events_processed ON webhook_events(processed, created_at);
CREATE INDEX idx_usage_logs_subscription_id ON usage_logs(subscription_id, created_at DESC);

-- Add billing fields to users table
ALTER TABLE users ADD COLUMN IF NOT EXISTS subscription_id UUID REFERENCES subscriptions(id);
ALTER TABLE users ADD COLUMN IF NOT EXISTS ls_customer_id VARCHAR(50);

-- Add billing fields to tenants table
ALTER TABLE tenants ADD COLUMN IF NOT EXISTS subscription_id UUID REFERENCES subscriptions(id);
ALTER TABLE tenants ADD COLUMN IF NOT EXISTS ls_customer_id VARCHAR(50);

-- Function to auto-update updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers for auto-updating timestamps
CREATE TRIGGER update_plans_updated_at BEFORE UPDATE ON plans
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at BEFORE UPDATE ON subscriptions
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Seed default plans
INSERT INTO plans (name, slug, description, monthly_price_cents, yearly_price_cents, surveys_limit, responses_limit, team_members_limit, features, sort_order, is_active) VALUES
  ('Free', 'free', 'Perfect for trying out', 0, 0, 3, 100, 1, '["3 surveys", "100 responses/month", "Basic analytics", "Email support"]', 0, true),
  ('Starter', 'starter', 'For small projects', 1900, 19200, 10, 1000, 3, '["10 surveys", "1,000 responses/month", "Advanced analytics", "Priority support", "Custom branding"]', 1, true),
  ('Pro', 'pro', 'For growing businesses', 4900, 49920, 50, 10000, 10, '["50 surveys", "10,000 responses/month", "Advanced analytics", "Priority support", "Custom branding", "API access", "Webhooks"]', 2, true),
  ('Enterprise', 'enterprise', 'For large organizations', 14900, 149040, -1, -1, -1, '["Unlimited surveys", "Unlimited responses", "Advanced analytics", "Dedicated support", "Custom branding", "API access", "Webhooks", "SSO", "SLA"]', 3, true)
ON CONFLICT (slug) DO NOTHING;

-- Comments
COMMENT ON TABLE plans IS 'Subscription plans and pricing tiers';
COMMENT ON TABLE subscriptions IS 'Active subscriptions from Lemon Squeezy';
COMMENT ON TABLE invoices IS 'Payment invoices and receipts';
COMMENT ON TABLE webhook_events IS 'Lemon Squeezy webhook event log';
COMMENT ON TABLE usage_logs IS 'Detailed usage tracking for billing';

COMMENT ON COLUMN subscriptions.status IS 'active, past_due, cancelled, expired, paused, on_trial';
COMMENT ON COLUMN subscriptions.surveys_used IS 'Surveys created this billing period';
COMMENT ON COLUMN subscriptions.responses_used IS 'Responses received this billing period';
</file>

<file path="backend/src/migrations/017_enhance_auth_security.sql">
-- ============================================
-- FILE: backend/src/migrations/017_enhance_auth_security.sql (FIXED)
-- Enhanced authentication with token rotation and password reset
-- ============================================

-- Add token security columns to refresh_tokens
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'refresh_tokens' AND column_name = 'token_hash'
  ) THEN
    ALTER TABLE refresh_tokens ADD COLUMN token_hash VARCHAR(64);
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'refresh_tokens' AND column_name = 'created_by_ip'
  ) THEN
    ALTER TABLE refresh_tokens ADD COLUMN created_by_ip INET;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'refresh_tokens' AND column_name = 'revoked_at'
  ) THEN
    ALTER TABLE refresh_tokens ADD COLUMN revoked_at TIMESTAMP;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'refresh_tokens' AND column_name = 'revoked_by_ip'
  ) THEN
    ALTER TABLE refresh_tokens ADD COLUMN revoked_by_ip INET;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'refresh_tokens' AND column_name = 'replaced_by_token'
  ) THEN
    ALTER TABLE refresh_tokens ADD COLUMN replaced_by_token UUID;
  END IF;
END $$;

-- Create index on token_hash for fast lookups (FIXED - removed NOW() from predicate)
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_hash 
  ON refresh_tokens(token_hash) 
  WHERE revoked_at IS NULL;

-- Create index for cleanup queries
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_revoked 
  ON refresh_tokens(revoked_at, expires_at);

-- Password reset tokens table
CREATE TABLE IF NOT EXISTS password_reset_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  token_hash VARCHAR(64) NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  used_at TIMESTAMP,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  created_by_ip INET
);

CREATE INDEX IF NOT EXISTS idx_password_reset_user 
  ON password_reset_tokens(user_id);

-- FIXED: Removed NOW() from index predicate - use separate index
CREATE INDEX IF NOT EXISTS idx_password_reset_hash 
  ON password_reset_tokens(token_hash) 
  WHERE used_at IS NULL;

-- Additional index for expired tokens cleanup
CREATE INDEX IF NOT EXISTS idx_password_reset_expires 
  ON password_reset_tokens(expires_at);

COMMENT ON TABLE password_reset_tokens IS 'Secure password reset tokens';
COMMENT ON COLUMN password_reset_tokens.token_hash IS 'SHA-256 hash of reset token';
COMMENT ON COLUMN password_reset_tokens.used_at IS 'Timestamp when token was used';

-- Cleanup function for expired tokens (run periodically)
CREATE OR REPLACE FUNCTION cleanup_expired_tokens()
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  -- Delete expired refresh tokens older than 30 days
  DELETE FROM refresh_tokens 
  WHERE expires_at < NOW() - INTERVAL '30 days';
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  
  -- Delete expired/used password reset tokens older than 7 days
  DELETE FROM password_reset_tokens 
  WHERE (expires_at < NOW() - INTERVAL '7 days' OR used_at IS NOT NULL);
  
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION cleanup_expired_tokens IS 'Cleanup expired authentication tokens';

-- Migration for existing refresh_tokens (populate token_hash from token)
DO $$
BEGIN
  -- Only run if token_hash column is empty
  IF EXISTS (
    SELECT 1 FROM refresh_tokens WHERE token_hash IS NULL LIMIT 1
  ) THEN
    UPDATE refresh_tokens 
    SET token_hash = encode(digest(token, 'sha256'), 'hex')
    WHERE token_hash IS NULL AND token IS NOT NULL;
    
    RAISE NOTICE 'Migrated % existing refresh tokens', 
      (SELECT COUNT(*) FROM refresh_tokens WHERE token_hash IS NOT NULL);
  END IF;
END $$;

-- Success message
DO $$
BEGIN
  RAISE NOTICE '✅ Authentication security enhancements applied';
  RAISE NOTICE '   - Token hashing enabled';
  RAISE NOTICE '   - Password reset tokens table created';
  RAISE NOTICE '   - Cleanup function created';
  RAISE NOTICE '';
  RAISE NOTICE 'IMPORTANT: Update your application code to use token hashing';
  RAISE NOTICE 'Run cleanup periodically: SELECT cleanup_expired_tokens();';
END $$;
</file>

<file path="backend/src/migrations/018_enhance_survey_snapshots.sql">
-- ============================================
-- FILE: backend/src/migrations/018_enhance_survey_snapshots.sql
-- Enhance survey snapshots and add missing constraints
-- ============================================

-- NOTE: Ensure `survey_snapshots` exists before adding a FK column on `surveys`.

-- Ensure survey_snapshots table exists with all fields
CREATE TABLE IF NOT EXISTS survey_snapshots (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  survey_id UUID NOT NULL REFERENCES surveys(id) ON DELETE CASCADE,
  snapshot JSONB NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  created_by UUID REFERENCES users(id) ON DELETE SET NULL
);

-- Add indexes if they don't exist
CREATE INDEX IF NOT EXISTS idx_survey_snapshots_survey_id 
  ON survey_snapshots(survey_id);

CREATE INDEX IF NOT EXISTS idx_survey_snapshots_created_at 
  ON survey_snapshots(created_at DESC);

-- Add questions.survey_id if not exists (for survey-scoped questions)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'questions' AND column_name = 'survey_id'
  ) THEN
    ALTER TABLE questions ADD COLUMN survey_id UUID REFERENCES surveys(id) ON DELETE CASCADE;
    CREATE INDEX idx_questions_survey_id ON questions(survey_id);
  END IF;
END $$;

-- Add questions.key field if not exists
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'questions' AND column_name = 'key'
  ) THEN
    ALTER TABLE questions ADD COLUMN key VARCHAR(50);
  END IF;
END $$;

-- Add questions.type field if not exists (rename from question_type)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'questions' AND column_name = 'type'
  ) THEN
    IF EXISTS (
      SELECT 1 FROM information_schema.columns 
      WHERE table_name = 'questions' AND column_name = 'question_type'
    ) THEN
      ALTER TABLE questions RENAME COLUMN question_type TO type;
    ELSE
      ALTER TABLE questions ADD COLUMN type VARCHAR(50);
    END IF;
  END IF;
END $$;

-- Add questions.label field if not exists (rename from question_text)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'questions' AND column_name = 'label'
  ) THEN
    IF EXISTS (
      SELECT 1 FROM information_schema.columns 
      WHERE table_name = 'questions' AND column_name = 'question_text'
    ) THEN
      ALTER TABLE questions RENAME COLUMN question_text TO label;
    ELSE
      ALTER TABLE questions ADD COLUMN label TEXT;
    END IF;
  END IF;
END $$;

-- Add questions.meta field if not exists (combines options, validation, etc)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'questions' AND column_name = 'meta'
  ) THEN
    ALTER TABLE questions ADD COLUMN meta JSONB DEFAULT '{}';
    
    -- Migrate existing options to meta if options column exists
    IF EXISTS (
      SELECT 1 FROM information_schema.columns 
      WHERE table_name = 'questions' AND column_name = 'options'
    ) THEN
      UPDATE questions 
      SET meta = jsonb_build_object('options', options::jsonb)
      WHERE options IS NOT NULL;
    END IF;
  END IF;
END $$;

-- Add questions.position field if not exists
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'questions' AND column_name = 'position'
  ) THEN
    ALTER TABLE questions ADD COLUMN position INTEGER DEFAULT 0;
  END IF;
END $$;

-- Add questions.required field if not exists
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'questions' AND column_name = 'required'
  ) THEN
    ALTER TABLE questions ADD COLUMN required BOOLEAN DEFAULT FALSE;
  END IF;
END $$;

-- Create survey_responses table if not exists
CREATE TABLE IF NOT EXISTS survey_responses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  survey_id UUID NOT NULL REFERENCES surveys(id) ON DELETE CASCADE,
  session_id VARCHAR(255),
  response_data JSONB NOT NULL,
  ip_address INET,
  user_agent TEXT,
  country_code VARCHAR(2),
  created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_survey_responses_survey_id 
  ON survey_responses(survey_id);

CREATE INDEX IF NOT EXISTS idx_survey_responses_created_at 
  ON survey_responses(created_at DESC);

CREATE INDEX IF NOT EXISTS idx_survey_responses_session 
  ON survey_responses(session_id) WHERE session_id IS NOT NULL;

-- Optional: Create access logs table for analytics
CREATE TABLE IF NOT EXISTS survey_access_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  survey_id UUID NOT NULL REFERENCES surveys(id) ON DELETE CASCADE,
  ip_address INET,
  user_agent TEXT,
  referer TEXT,
  created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_survey_access_logs_survey_id 
  ON survey_access_logs(survey_id);

CREATE INDEX IF NOT EXISTS idx_survey_access_logs_created_at 
  ON survey_access_logs(created_at DESC);

-- Add helpful comments
COMMENT ON TABLE survey_snapshots IS 'Frozen versions of surveys created when published';
COMMENT ON COLUMN survey_snapshots.snapshot IS 'Complete survey data including questions at publish time';

COMMENT ON TABLE survey_responses IS 'User responses to published surveys';
COMMENT ON COLUMN survey_responses.response_data IS 'JSON containing answers array and metadata';

COMMENT ON COLUMN questions.survey_id IS 'Optional: links question to specific survey (null means organization-wide)';
COMMENT ON COLUMN questions.key IS 'Unique identifier for question within survey';
COMMENT ON COLUMN questions.meta IS 'JSON containing options, validation rules, conditional logic';
COMMENT ON COLUMN questions.position IS 'Display order in survey (0-based)';

-- Success message
DO $$
BEGIN
  RAISE NOTICE '✅ Survey snapshots enhancement migration completed';
  RAISE NOTICE '   - survey_snapshots table ready';
  RAISE NOTICE '   - survey_responses table ready';
  RAISE NOTICE '   - questions table enhanced with survey_id, key, position, meta';
  RAISE NOTICE '   - All indexes created';
END $$;

-- Add published_snapshot_id to surveys if not exists (after table exists)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'surveys' AND column_name = 'published_snapshot_id'
  ) THEN
    ALTER TABLE surveys ADD COLUMN published_snapshot_id UUID REFERENCES survey_snapshots(id);
  END IF;
END $$;
</file>

<file path="backend/src/migrations/019_create_survey_events.sql">
-- ============================================
-- FILE: backend/src/migrations/019_create_survey_events.sql
-- Create events table for analytics tracking
-- ============================================

-- Survey events table for tracking user interactions
CREATE TABLE IF NOT EXISTS survey_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  event_type VARCHAR(50) NOT NULL CHECK (event_type IN ('survey_view', 'survey_start', 'survey_submit')),
  survey_id UUID NOT NULL REFERENCES surveys(id) ON DELETE CASCADE,
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  session_id VARCHAR(255),
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_survey_events_survey_id ON survey_events(survey_id);
CREATE INDEX IF NOT EXISTS idx_survey_events_tenant_id ON survey_events(tenant_id);
CREATE INDEX IF NOT EXISTS idx_survey_events_type ON survey_events(event_type);
CREATE INDEX IF NOT EXISTS idx_survey_events_created_at ON survey_events(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_survey_events_session ON survey_events(session_id) WHERE session_id IS NOT NULL;

-- Composite index for aggregation queries
CREATE INDEX IF NOT EXISTS idx_survey_events_survey_type_date 
  ON survey_events(survey_id, event_type, created_at DESC);

-- Enhance survey_analytics_cache table
ALTER TABLE survey_analytics_cache 
  ADD COLUMN IF NOT EXISTS views INTEGER DEFAULT 0,
  ADD COLUMN IF NOT EXISTS starts INTEGER DEFAULT 0,
  ADD COLUMN IF NOT EXISTS completions INTEGER DEFAULT 0,
  ADD COLUMN IF NOT EXISTS question_stats JSONB DEFAULT '{}';

-- Create index on survey_analytics_cache
CREATE INDEX IF NOT EXISTS idx_survey_analytics_cache_survey 
  ON survey_analytics_cache(survey_id, expires_at DESC);

-- Comments
COMMENT ON TABLE survey_events IS 'Tracks user interactions with surveys for analytics';
COMMENT ON COLUMN survey_events.event_type IS 'Type of event: survey_view, survey_start, survey_submit';
COMMENT ON COLUMN survey_events.metadata IS 'Additional event data: device, browser, IP, etc.';
COMMENT ON COLUMN survey_analytics_cache.views IS 'Cached view count';
COMMENT ON COLUMN survey_analytics_cache.starts IS 'Cached start count';
COMMENT ON COLUMN survey_analytics_cache.completions IS 'Cached completion count';
COMMENT ON COLUMN survey_analytics_cache.question_stats IS 'Cached question-level analytics';

-- Function to auto-cleanup old events (optional, run periodically)
CREATE OR REPLACE FUNCTION cleanup_old_survey_events()
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  -- Delete events older than 90 days
  DELETE FROM survey_events 
  WHERE created_at < NOW() - INTERVAL '90 days';
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION cleanup_old_survey_events IS 'Cleanup survey events older than 90 days';

-- Success message
DO $$
BEGIN
  RAISE NOTICE '✅ Analytics events table created successfully';
  RAISE NOTICE '   - survey_events table with indexes';
  RAISE NOTICE '   - Enhanced survey_analytics_cache';
  RAISE NOTICE '   - Cleanup function available';
END $$;
</file>

<file path="backend/src/migrations/run.js">
import { readdir, readFile } from 'fs/promises';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import pg from 'pg';
import dotenv from 'dotenv';

dotenv.config();

const { Pool } = pg;

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

async function runMigrations() {
  try {
    console.log('📄 Starting database migrations...');

    // Create migrations table if not exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS migrations (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) UNIQUE NOT NULL,
        executed_at TIMESTAMP DEFAULT NOW()
      )
    `);

    // Get list of executed migrations
    const executedResult = await pool.query(
      'SELECT name FROM migrations ORDER BY id'
    );
    const executedMigrations = new Set(
      executedResult.rows.map((row) => row.name)
    );

    // Get all SQL files in migrations directory
    const files = await readdir(__dirname);
    const sqlFiles = files
      .filter((file) => file.endsWith('.sql'))
      .sort();

    console.log(`🔍 Found ${sqlFiles.length} migration files`);

    for (const file of sqlFiles) {
      if (executedMigrations.has(file)) {
        console.log(`⏭️  Skipping ${file} (already executed)`);
        continue;
      }

      console.log(`📄 Executing ${file}...`);
      
      const sql = await readFile(join(__dirname, file), 'utf-8');
      
      const client = await pool.connect();
      try {
        await client.query('BEGIN');
        await client.query(sql);
        
        // ✅ FIXED: Use ON CONFLICT DO NOTHING for idempotency
        await client.query(
          'INSERT INTO migrations (name) VALUES ($1) ON CONFLICT (name) DO NOTHING',
          [file]
        );
        
        await client.query('COMMIT');
        console.log(`✅ ${file} executed successfully`);
      } catch (error) {
        await client.query('ROLLBACK');
        console.error(`❌ Error executing ${file}:`, error.message);
        throw error;
      } finally {
        client.release();
      }
    }

    console.log('✅ All migrations completed successfully');
    await pool.end();
    process.exit(0);
  } catch (error) {
    console.error('❌ Migration failed:', error);
    await pool.end();
    process.exit(1);
  }
}

runMigrations();
</file>

<file path="backend/src/modules/analytics/analytics.controller.js">
// ============================================
// FILE: backend/src/modules/analytics/analytics.controller.js (COMPLETE)
// All analytics endpoints with validation
// ============================================
import { asyncHandler } from '../../utils/asyncHandler.js';
import analyticsService from './analytics.service.js';
import { ApiResponse } from '../../utils/ApiResponse.js';
import { ApiError } from '../../utils/ApiError.js';

class AnalyticsController {
  /**
   * POST /api/analytics/event
   * Track analytics event
   */
  trackEvent = asyncHandler(async (req, res) => {
    const { event, survey_id, tenant_id, metadata } = req.body;

    if (!event || !survey_id || !tenant_id) {
      throw ApiError.badRequest('Missing required fields: event, survey_id, tenant_id');
    }

    const result = await analyticsService.trackEvent({
      event,
      survey_id,
      tenant_id,
      metadata: metadata || {},
    });

    ApiResponse.created(res, 'Event tracked', { eventId: result.id });
  });

  /**
   * GET /api/analytics/surveys/:id/summary
   * Get survey summary analytics
   */
  getSurveySummary = asyncHandler(async (req, res) => {
    const { id: surveyId } = req.params;
    const { forceRefresh } = req.query;

    const summary = await analyticsService.getSurveySummary(
      surveyId,
      req.user.userId,
      { forceRefresh: forceRefresh === 'true' }
    );

    ApiResponse.success(res, 200, 'Survey summary retrieved', { summary });
  });

  /**
   * GET /api/analytics/surveys/:id/questions
   * Get question-level analytics
   */
  getQuestionAnalytics = asyncHandler(async (req, res) => {
    const { id: surveyId } = req.params;

    const questions = await analyticsService.getQuestionAnalytics(
      surveyId,
      req.user.userId
    );

    ApiResponse.success(res, 200, 'Question analytics retrieved', questions);
  });

  /**
   * GET /api/analytics/surveys/:id/overview-chart
   * Get chart data for overview
   */
  getOverviewChart = asyncHandler(async (req, res) => {
    const { id: surveyId } = req.params;
    const { days, granularity } = req.query;

    const chartData = await analyticsService.getOverviewChart(
      surveyId,
      req.user.userId,
      {
        days: parseInt(days) || 30,
        granularity: granularity || 'day',
      }
    );

    ApiResponse.success(res, 200, 'Chart data retrieved', chartData);
  });

  /**
   * GET /api/analytics/surveys/:id/export
   * Export analytics data
   */
  exportAnalytics = asyncHandler(async (req, res) => {
    const { id: surveyId } = req.params;
    const { format = 'json' } = req.query;

    const data = await analyticsService.exportAnalytics(
      surveyId,
      req.user.userId,
      format
    );

    if (format === 'csv') {
      res.setHeader('Content-Type', 'text/csv');
      res.setHeader('Content-Disposition', `attachment; filename="survey-${surveyId}-analytics.csv"`);
      res.send(data);
    } else {
      ApiResponse.success(res, 200, 'Analytics exported', data);
    }
  });

  /**
   * DELETE /api/analytics/surveys/:id/cache
   * Invalidate analytics cache
   */
  invalidateCache = asyncHandler(async (req, res) => {
    const { id: surveyId } = req.params;

    await analyticsService.verifySurveyAccess(surveyId, req.user.userId);
    await analyticsService.invalidateCache(surveyId);

    ApiResponse.success(res, 200, 'Cache invalidated');
  });
}

export default new AnalyticsController();
</file>

<file path="backend/src/modules/analytics/analytics.routes.js">
// ============================================
// FILE: backend/src/modules/analytics/analytics.routes.js (COMPLETE)
// All analytics routes with rate limiting
// ============================================
import { Router } from 'express';
import analyticsController from './analytics.controller.js';
import { authRequired } from '../../middleware/auth.js';
import { rateLimitMiddleware } from '../../middleware/rateLimit.middleware.js';

const router = Router();

// Public endpoint for tracking events (with rate limit)
router.post('/event', rateLimitMiddleware, analyticsController.trackEvent);

// Protected endpoints (require authentication)
router.use(authRequired);

// Survey summary analytics
router.get('/surveys/:id/summary', analyticsController.getSurveySummary);

// Question-level analytics
router.get('/surveys/:id/questions', analyticsController.getQuestionAnalytics);

// Chart data for visualizations
router.get('/surveys/:id/overview-chart', analyticsController.getOverviewChart);

// Export analytics data
router.get('/surveys/:id/export', analyticsController.exportAnalytics);

// Cache management
router.delete('/surveys/:id/cache', analyticsController.invalidateCache);

export default router;
</file>

<file path="backend/src/modules/analytics/analytics.service.js">
// ============================================
// FILE: backend/src/modules/analytics/analytics.service.js
// Complete analytics service with aggregation and caching
// ============================================
import { v4 as uuidv4 } from 'uuid';
import db from '../../config/db.js';
import { ApiError } from '../../utils/ApiError.js';
import microSurveyClient from '../../services/microSurveyClient.js';
import { logger } from '../../lib/logger.js';

class AnalyticsService {
  /**
   * Track event (survey_view, survey_start, survey_submit)
   */
  async trackEvent(eventData) {
    const { event, survey_id, tenant_id, metadata } = eventData;
    
    // Validate event type
    const validEvents = ['survey_view', 'survey_start', 'survey_submit'];
    if (!validEvents.includes(event)) {
      throw ApiError.badRequest('Invalid event type');
    }

    // Store event
    const result = await db.query(
      `INSERT INTO survey_events (
        id, event_type, survey_id, tenant_id, metadata, created_at
      ) VALUES ($1, $2, $3, $4, $5, NOW())
      RETURNING id`,
      [uuidv4(), event, survey_id, tenant_id, JSON.stringify(metadata || {})]
    );

    // Invalidate cache for this survey
    await this.invalidateCache(survey_id);

    logger.info('Event tracked', { event, survey_id, eventId: result.rows[0].id });
    
    return result.rows[0];
  }

  /**
   * Get survey summary analytics
   */
  async getSurveySummary(surveyId, userId, options = {}) {
    const { useCache = true, forceRefresh = false } = options;

    // Verify ownership
    await this.verifySurveyAccess(surveyId, userId);

    // Try cache first
    if (useCache && !forceRefresh) {
      const cached = await this.getCachedAnalytics(surveyId);
      if (cached) {
        logger.debug('Returning cached analytics', { surveyId });
        return cached;
      }
    }

    // Fetch from Micro-Survey and local DB
    const [microSurveyData, localEvents] = await Promise.all([
      this.fetchMicroSurveyAnalytics(surveyId),
      this.fetchLocalEvents(surveyId),
    ]);

    // Aggregate data
    const summary = {
      surveyId,
      views: localEvents.views,
      starts: localEvents.starts,
      completions: microSurveyData.totalResponses || 0,
      completionRate: this.calculateCompletionRate(localEvents.starts, microSurveyData.totalResponses),
      avgTimeToComplete: microSurveyData.avgDuration || null,
      lastUpdated: new Date().toISOString(),
      
      // Device breakdown
      devices: this.aggregateDevices(localEvents.devices),
      
      // Browser breakdown
      browsers: this.aggregateBrowsers(localEvents.browsers),
      
      // Geographic data
      countries: this.aggregateCountries(microSurveyData.geography || []),
      
      // Time series (last 30 days)
      timeline: await this.getTimeline(surveyId, 30),
    };

    // Cache results
    await this.cacheAnalytics(surveyId, summary);

    return summary;
  }

  /**
   * Get question-level analytics
   */
  async getQuestionAnalytics(surveyId, userId) {
    await this.verifySurveyAccess(surveyId, userId);

    // Get survey with questions
    const survey = await db.query(
      `SELECT s.*, ss.snapshot
       FROM surveys s
       LEFT JOIN survey_snapshots ss ON s.published_snapshot_id = ss.id
       WHERE s.id = $1`,
      [surveyId]
    );

    if (survey.rows.length === 0) {
      throw ApiError.notFound('Survey not found');
    }

    const snapshot = survey.rows[0].snapshot;
    const questions = snapshot?.questions || [];

    // Fetch responses from Micro-Survey
    const responsesData = await microSurveyClient.getResults(
      survey.rows[0].microsurvey_id
    );

    // Aggregate question-level stats
    const questionStats = questions.map(question => {
      const responses = this.filterResponsesByQuestion(
        responsesData.responses || [],
        question.id
      );

      return {
        questionId: question.id,
        questionText: question.text,
        questionType: question.type,
        totalResponses: responses.length,
        ...this.aggregateQuestionResponses(question, responses),
      };
    });

    return {
      surveyId,
      totalQuestions: questions.length,
      questions: questionStats,
    };
  }

  /**
   * Get chart data for visualization
   */
  async getOverviewChart(surveyId, userId, options = {}) {
    await this.verifySurveyAccess(surveyId, userId);

    const { days = 30, granularity = 'day' } = options;

    // Time series: views vs completions
    const timeSeriesData = await this.getTimeline(surveyId, days, granularity);

    // Conversion funnel
    const funnelData = await this.getFunnelData(surveyId);

    return {
      surveyId,
      timeSeries: timeSeriesData,
      funnel: funnelData,
      generatedAt: new Date().toISOString(),
    };
  }

  /**
   * Export analytics data
   */
  async exportAnalytics(surveyId, userId, format = 'csv') {
    await this.verifySurveyAccess(surveyId, userId);

    const [summary, questions] = await Promise.all([
      this.getSurveySummary(surveyId, userId, { useCache: false }),
      this.getQuestionAnalytics(surveyId, userId),
    ]);

    if (format === 'json') {
      return { summary, questions };
    }

    if (format === 'csv') {
      return this.generateCSV(summary, questions);
    }

    throw ApiError.badRequest('Unsupported export format');
  }

  // ============================================
  // HELPER METHODS
  // ============================================

  async verifySurveyAccess(surveyId, userId) {
    const result = await db.query(
      `SELECT s.id FROM surveys s
       JOIN tenants t ON s.tenant_id = t.id
       WHERE s.id = $1 AND t.owner_id = $2`,
      [surveyId, userId]
    );

    if (result.rows.length === 0) {
      throw ApiError.forbidden('Survey not found or access denied');
    }
  }

  async fetchMicroSurveyAnalytics(surveyId) {
    try {
      const survey = await db.query(
        'SELECT microsurvey_id FROM surveys WHERE id = $1',
        [surveyId]
      );

      if (survey.rows.length === 0) {
        throw new Error('Survey not found');
      }

      const data = await microSurveyClient.getResults(
        survey.rows[0].microsurvey_id
      );

      return data;
    } catch (error) {
      logger.error('Failed to fetch Micro-Survey analytics', {
        error: error.message,
        surveyId,
      });
      return { totalResponses: 0, responses: [] };
    }
  }

  async fetchLocalEvents(surveyId) {
    const result = await db.query(
      `SELECT 
        COUNT(*) FILTER (WHERE event_type = 'survey_view') as views,
        COUNT(*) FILTER (WHERE event_type = 'survey_start') as starts,
        jsonb_agg(DISTINCT metadata->'device') FILTER (WHERE metadata->'device' IS NOT NULL) as devices,
        jsonb_agg(DISTINCT metadata->'browser') FILTER (WHERE metadata->'browser' IS NOT NULL) as browsers
      FROM survey_events
      WHERE survey_id = $1`,
      [surveyId]
    );

    const row = result.rows[0] || {};
    
    return {
      views: parseInt(row.views || 0),
      starts: parseInt(row.starts || 0),
      devices: row.devices || [],
      browsers: row.browsers || [],
    };
  }

  async getTimeline(surveyId, days = 30, granularity = 'day') {
    const dateFormat = granularity === 'hour' ? 'YYYY-MM-DD HH24:00:00' : 'YYYY-MM-DD';
    
    const result = await db.query(
      `SELECT 
        TO_CHAR(DATE_TRUNC($3, created_at), $4) as period,
        COUNT(*) FILTER (WHERE event_type = 'survey_view') as views,
        COUNT(*) FILTER (WHERE event_type = 'survey_start') as starts
      FROM survey_events
      WHERE survey_id = $1 
        AND created_at >= NOW() - INTERVAL '1 day' * $2
      GROUP BY period
      ORDER BY period ASC`,
      [surveyId, days, granularity, dateFormat]
    );

    // Also get completions from survey_responses
    const completionsResult = await db.query(
      `SELECT 
        TO_CHAR(DATE_TRUNC($3, created_at), $4) as period,
        COUNT(*) as completions
      FROM survey_responses
      WHERE survey_id = $1 
        AND created_at >= NOW() - INTERVAL '1 day' * $2
      GROUP BY period
      ORDER BY period ASC`,
      [surveyId, days, granularity, dateFormat]
    );

    // Merge data
    const completionsMap = new Map(
      completionsResult.rows.map(r => [r.period, parseInt(r.completions)])
    );

    return result.rows.map(row => ({
      date: row.period,
      views: parseInt(row.views || 0),
      starts: parseInt(row.starts || 0),
      completions: completionsMap.get(row.period) || 0,
    }));
  }

  async getFunnelData(surveyId) {
    const result = await db.query(
      `SELECT 
        COUNT(*) FILTER (WHERE event_type = 'survey_view') as views,
        COUNT(*) FILTER (WHERE event_type = 'survey_start') as starts
      FROM survey_events
      WHERE survey_id = $1`,
      [surveyId]
    );

    const completionsResult = await db.query(
      'SELECT COUNT(*) as completions FROM survey_responses WHERE survey_id = $1',
      [surveyId]
    );

    const views = parseInt(result.rows[0]?.views || 0);
    const starts = parseInt(result.rows[0]?.starts || 0);
    const completions = parseInt(completionsResult.rows[0]?.completions || 0);

    return [
      { stage: 'Views', count: views, percentage: 100 },
      { stage: 'Starts', count: starts, percentage: views > 0 ? (starts / views) * 100 : 0 },
      { stage: 'Completions', count: completions, percentage: views > 0 ? (completions / views) * 100 : 0 },
    ];
  }

  calculateCompletionRate(starts, completions) {
    if (starts === 0) return 0;
    return ((completions / starts) * 100).toFixed(2);
  }

  aggregateDevices(devices) {
    const counts = {};
    devices.forEach(device => {
      if (device) {
        counts[device] = (counts[device] || 0) + 1;
      }
    });
    return Object.entries(counts).map(([name, count]) => ({ name, count }));
  }

  aggregateBrowsers(browsers) {
    const counts = {};
    browsers.forEach(browser => {
      if (browser) {
        counts[browser] = (counts[browser] || 0) + 1;
      }
    });
    return Object.entries(counts).map(([name, count]) => ({ name, count }));
  }

  aggregateCountries(geography) {
    return geography.map(g => ({
      countryCode: g.country,
      count: g.count,
      percentage: g.percentage,
    }));
  }

  filterResponsesByQuestion(responses, questionId) {
    return responses.filter(r => 
      r.answers && r.answers.some(a => a.questionId === questionId)
    );
  }

  aggregateQuestionResponses(question, responses) {
    switch (question.type) {
      case 'multiple_choice':
        return this.aggregateMultipleChoice(question, responses);
      case 'rating':
        return this.aggregateRating(question, responses);
      case 'text':
        return this.aggregateText(responses);
      case 'yes_no':
        return this.aggregateYesNo(responses);
      default:
        return {};
    }
  }

  aggregateMultipleChoice(question, responses) {
    const optionCounts = {};
    const options = question.options || [];
    
    // Initialize counts
    options.forEach(opt => {
      const optText = typeof opt === 'string' ? opt : opt.text;
      optionCounts[optText] = 0;
    });

    // Count responses
    responses.forEach(response => {
      const answer = response.answers?.find(a => a.questionId === question.id);
      if (answer && answer.answer) {
        optionCounts[answer.answer] = (optionCounts[answer.answer] || 0) + 1;
      }
    });

    const total = responses.length;
    
    return {
      optionBreakdown: Object.entries(optionCounts).map(([option, count]) => ({
        option,
        count,
        percentage: total > 0 ? ((count / total) * 100).toFixed(2) : 0,
      })),
    };
  }

  aggregateRating(question, responses) {
    const ratings = responses
      .map(r => r.answers?.find(a => a.questionId === question.id)?.answer)
      .filter(a => typeof a === 'number');

    if (ratings.length === 0) {
      return { average: 0, distribution: [] };
    }

    const sum = ratings.reduce((acc, val) => acc + val, 0);
    const average = (sum / ratings.length).toFixed(2);

    // Distribution
    const distribution = {};
    const min = question.options?.[0]?.min || 1;
    const max = question.options?.[0]?.max || 5;
    
    for (let i = min; i <= max; i++) {
      distribution[i] = ratings.filter(r => r === i).length;
    }

    return {
      average: parseFloat(average),
      distribution: Object.entries(distribution).map(([rating, count]) => ({
        rating: parseInt(rating),
        count,
        percentage: ((count / ratings.length) * 100).toFixed(2),
      })),
    };
  }

  aggregateText(responses) {
    const textResponses = responses
      .map(r => r.answers?.find(a => a.answer && typeof a.answer === 'string')?.answer)
      .filter(Boolean);

    return {
      sampleAnswers: textResponses.slice(0, 10),
      totalCount: textResponses.length,
    };
  }

  aggregateYesNo(responses) {
    const yes = responses.filter(r => 
      r.answers?.some(a => a.answer === 'yes')
    ).length;
    const no = responses.filter(r => 
      r.answers?.some(a => a.answer === 'no')
    ).length;
    const total = yes + no;

    return {
      yes: { count: yes, percentage: total > 0 ? ((yes / total) * 100).toFixed(2) : 0 },
      no: { count: no, percentage: total > 0 ? ((no / total) * 100).toFixed(2) : 0 },
    };
  }

  // ============================================
  // CACHING
  // ============================================

  async getCachedAnalytics(surveyId) {
    const result = await db.query(
      `SELECT analytics_data FROM survey_analytics_cache
       WHERE survey_id = $1 AND expires_at > NOW()
       ORDER BY cached_at DESC LIMIT 1`,
      [surveyId]
    );

    return result.rows[0]?.analytics_data || null;
  }

  async cacheAnalytics(surveyId, data, ttlMinutes = 5) {
    const expiresAt = new Date(Date.now() + ttlMinutes * 60 * 1000);
    
    await db.query(
      `INSERT INTO survey_analytics_cache (
        id, survey_id, analytics_data, cached_at, expires_at
      ) VALUES ($1, $2, $3, NOW(), $4)`,
      [uuidv4(), surveyId, JSON.stringify(data), expiresAt]
    );
  }

  async invalidateCache(surveyId) {
    await db.query(
      'DELETE FROM survey_analytics_cache WHERE survey_id = $1',
      [surveyId]
    );
  }

  // ============================================
  // CSV EXPORT
  // ============================================

  generateCSV(summary, questions) {
    const lines = [];
    
    // Summary section
    lines.push('SURVEY SUMMARY');
    lines.push(`Survey ID,${summary.surveyId}`);
    lines.push(`Views,${summary.views}`);
    lines.push(`Starts,${summary.starts}`);
    lines.push(`Completions,${summary.completions}`);
    lines.push(`Completion Rate,${summary.completionRate}%`);
    lines.push('');

    // Questions section
    lines.push('QUESTION ANALYTICS');
    questions.questions.forEach((q, idx) => {
      lines.push('');
      lines.push(`Question ${idx + 1}: ${q.questionText}`);
      lines.push(`Type: ${q.questionType}`);
      lines.push(`Total Responses: ${q.totalResponses}`);
      
      if (q.optionBreakdown) {
        lines.push('Option,Count,Percentage');
        q.optionBreakdown.forEach(opt => {
          lines.push(`"${opt.option}",${opt.count},${opt.percentage}%`);
        });
      }
    });

    return lines.join('\n');
  }
}

export default new AnalyticsService();

// ============================================
// UPDATED analytics.controller.js
// ============================================
</file>

<file path="backend/src/modules/auth/auth.controller.js">
// ============================================
// FILE: backend/src/modules/auth/auth.controller.js
// ENHANCED with password reset endpoints
// ============================================
import { asyncHandler } from '../../utils/asyncHandler.js';
import * as authService from './auth.service.js';
import db from '../../config/db.js';
import { ApiResponse } from '../../utils/ApiResponse.js';

/**
 * Signup - POST /api/auth/signup
 */
export const signup = asyncHandler(async (req, res) => {
  const result = await authService.signup(req.body, req);
  
  // Set refresh token cookie
  res.cookie('refreshToken', result.refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: process.env.NODE_ENV === 'production' ? 'strict' : 'lax',
    maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
    path: '/',
  });
  
  res.status(201).json({
    success: true,
    message: 'Registration successful',
    data: {
      user: result.user,
      accessToken: result.accessToken,
    },
  });
});

/**
 * Login - POST /api/auth/login
 */
export const login = asyncHandler(async (req, res) => {
  const result = await authService.login(req.body, req);
  
  // Set refresh token cookie
  res.cookie('refreshToken', result.refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: process.env.NODE_ENV === 'production' ? 'strict' : 'lax',
    maxAge: 30 * 24 * 60 * 60 * 1000,
    path: '/',
  });
  
  res.json({
    success: true,
    message: 'Login successful',
    data: {
      user: result.user,
      accessToken: result.accessToken,
    },
  });
});

/**
 * Refresh token - POST /api/auth/refresh
 */
export const refresh = asyncHandler(async (req, res) => {
  // Get refresh token from cookie (preferred) or body (fallback)
  const refreshToken = req.cookies.refreshToken || req.body.refreshToken;
  
  if (!refreshToken) {
    return res.status(401).json({
      success: false,
      message: 'Refresh token required',
    });
  }
  
  const result = await authService.refreshAccessToken(refreshToken, req);
  
  // Set new refresh token cookie
  res.cookie('refreshToken', result.refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: process.env.NODE_ENV === 'production' ? 'strict' : 'lax',
    maxAge: 30 * 24 * 60 * 60 * 1000,
    path: '/',
  });
  
  res.json({
    success: true,
    message: 'Token refreshed',
    data: {
      accessToken: result.accessToken,
    },
  });
});

/**
 * Logout - POST /api/auth/logout
 */
export const logout = asyncHandler(async (req, res) => {
  const refreshToken = req.cookies.refreshToken || req.body.refreshToken;
  
  if (refreshToken) {
    await authService.logout(refreshToken, req);
  }
  
  // Clear cookie
  res.clearCookie('refreshToken', { path: '/' });
  
  res.json({
    success: true,
    message: 'Logout successful',
  });
});

/**
 * Get current user - GET /api/auth/me
 */
export const getCurrentUser = asyncHandler(async (req, res) => {
  const result = await db.query(
    `SELECT id, email, full_name, role, is_email_verified, created_at, last_login_at
     FROM users WHERE id = $1`,
    [req.user.userId]
  );
  
  if (result.rows.length === 0) {
    throw ApiError.notFound('User not found');
  }
  
  const user = result.rows[0];
  
  res.json({
    success: true,
    data: {
      user: {
        id: user.id,
        email: user.email,
        fullName: user.full_name,
        role: user.role,
        isEmailVerified: user.is_email_verified,
        createdAt: user.created_at,
        lastLoginAt: user.last_login_at,
      },
    },
  });
});

/**
 * Request password reset - POST /api/auth/request-password-reset
 */
export const requestPasswordReset = asyncHandler(async (req, res) => {
  const result = await authService.requestPasswordReset(req.body.email, req);
  
  // Always return success to prevent email enumeration
  res.json({
    success: true,
    message: result.message,
  });
});

/**
 * Reset password - POST /api/auth/reset-password
 */
export const resetPassword = asyncHandler(async (req, res) => {
  const { token, newPassword } = req.body;
  
  const result = await authService.resetPassword(token, newPassword, req);
  
  res.json({
    success: true,
    message: result.message,
  });
});

export default {
  signup,
  login,
  refresh,
  logout,
  getCurrentUser,
  requestPasswordReset,
  resetPassword,
};
</file>

<file path="backend/src/modules/auth/auth.middleware.js">
// ============================================
// FILE: backend/src/modules/auth/auth.middleware.js
// Enhanced JWT middleware with better error handling
// ============================================
import { verifyAccessToken } from './jwt.utils.js';
import { ApiError } from '../../utils/ApiError.js';

/**
 * Middleware to protect routes requiring authentication
 */
export function authRequired(req, res, next) {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader) {
      throw ApiError.unauthorized('No authorization header provided');
    }
    
    if (!authHeader.startsWith('Bearer ')) {
      throw ApiError.unauthorized('Invalid authorization header format');
    }
    
    const token = authHeader.substring(7);
    
    if (!token) {
      throw ApiError.unauthorized('No token provided');
    }
    
    const decoded = verifyAccessToken(token);
    
    // Attach user info to request
    req.user = {
      userId: decoded.userId,
      email: decoded.email,
      role: decoded.role,
    };
    
    next();
  } catch (error) {
    if (error instanceof ApiError) {
      return next(error);
    }
    
    // JWT verification errors
    if (error.message === 'Token expired') {
      return next(ApiError.unauthorized('Token expired. Please refresh.'));
    }
    
    return next(ApiError.unauthorized('Invalid token'));
  }
}

/**
 * Middleware to check specific roles
 */
export function requireRole(...allowedRoles) {
  return (req, res, next) => {
    if (!req.user) {
      return next(ApiError.unauthorized('Authentication required'));
    }
    
    if (!allowedRoles.includes(req.user.role)) {
      return next(ApiError.forbidden('Insufficient permissions'));
    }
    
    next();
  };
}

/**
 * Optional auth - attaches user if token present, but doesn't fail
 */
export function optionalAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return next();
  }
  
  try {
    const token = authHeader.substring(7);
    const decoded = verifyAccessToken(token);
    req.user = {
      userId: decoded.userId,
      email: decoded.email,
      role: decoded.role,
    };
  } catch (error) {
    // Silently fail for optional auth
  }
  
  next();
}
</file>

<file path="backend/src/modules/auth/auth.routes.js">
// ============================================
// FILE: backend/src/modules/auth/auth.routes.js
// COMPLETE ROUTES with rate limiting
// ============================================
import { Router } from 'express';
import authController from './auth.controller.js';
import { validate } from '../../middleware/validate.js';
import { authRequired } from './auth.middleware.js';
import {
  authRateLimiter,
  passwordResetRateLimiter,
} from '../../middleware/rateLimit.middleware.js';
import {
  signupSchema,
  loginSchema,
  refreshTokenSchema,
  requestPasswordResetSchema,
  resetPasswordSchema,
} from './auth.validators.js';

const router = Router();

// Public routes with rate limiting
router.post(
  '/signup',
  authRateLimiter,
  validate(signupSchema),
  authController.signup
);

router.post(
  '/login',
  authRateLimiter,
  validate(loginSchema),
  authController.login
);

router.post(
  '/refresh',
  validate(refreshTokenSchema),
  authController.refresh
);

router.post(
  '/logout',
  validate(refreshTokenSchema),
  authController.logout
);

router.post(
  '/request-password-reset',
  passwordResetRateLimiter,
  validate(requestPasswordResetSchema),
  authController.requestPasswordReset
);

router.post(
  '/reset-password',
  passwordResetRateLimiter,
  validate(resetPasswordSchema),
  authController.resetPassword
);

// Protected routes
router.get('/me', authRequired, authController.getCurrentUser);

export default router;
</file>

<file path="backend/src/modules/auth/auth.service.js">
// ============================================
// FILE: backend/src/modules/auth/auth.service.js (ENHANCED)
// Complete auth service using new token and email utilities
// ============================================
import { v4 as uuidv4 } from 'uuid';
import db from '../../config/db.js';
import { ApiError } from '../../utils/ApiError.js';
import { hashPassword, comparePassword } from './password.utils.js';
import { generateAccessToken, verifyAccessToken } from './jwt.utils.js';
import {
  generateSecureToken,
  hashToken,
  storeRefreshToken,
  verifyRefreshToken,
  rotateRefreshToken,
  revokeRefreshToken,
  revokeAllUserTokens,
} from './tokens.utils.js';
import { sendPasswordReset, sendWelcome } from './email.utils.js';
import { logger } from '../../lib/logger.js';

/**
 * Register new user with organization
 */
export async function signup({ email, password, fullName }, req) {
  // Check existing user
  const existing = await db.query(
    'SELECT id FROM users WHERE email = $1',
    [email.toLowerCase()]
  );
  
  if (existing.rows.length > 0) {
    throw ApiError.conflict('Email already registered');
  }
  
  // Hash password
  const passwordHash = await hashPassword(password);
  
  // Create user and organization in transaction
  const result = await db.transaction(async (client) => {
    // Create user
    const userResult = await client.query(
      `INSERT INTO users (
        id, email, password_hash, full_name, role,
        is_active, created_at, updated_at
      ) VALUES ($1, $2, $3, $4, $5, true, NOW(), NOW())
      RETURNING id, email, full_name, role, created_at`,
      [uuidv4(), email.toLowerCase(), passwordHash, fullName, 'user']
    );
    
    const user = userResult.rows[0];
    
    // Create default organization
    const orgSlug = `${fullName.toLowerCase().replace(/[^a-z0-9-]/g, '-')}-${Date.now()}`;
    await client.query(
      `INSERT INTO organizations (id, name, slug, owner_id, created_at, updated_at)
       VALUES ($1, $2, $3, $4, NOW(), NOW())`,
      [uuidv4(), `${fullName}'s Organization`, orgSlug, user.id]
    );
    
    return user;
  });
  
  const user = result;
  
  // Generate tokens
  const accessToken = generateAccessToken({
    userId: user.id,
    email: user.email,
    role: user.role,
  });
  
  const refreshToken = generateSecureToken();
  await storeRefreshToken(user.id, refreshToken, req.ip);
  
  // Send welcome email (async, don't wait)
  sendWelcome(user.email, user.full_name).catch(err => {
    logger.error('Failed to send welcome email', { error: err.message });
  });
  
  logger.info('User registered', { userId: user.id, email: user.email });
  
  return {
    user: {
      id: user.id,
      email: user.email,
      fullName: user.full_name,
      role: user.role,
    },
    accessToken,
    refreshToken,
  };
}

/**
 * Login existing user
 */
export async function login({ email, password }, req) {
  // Get user
  const result = await db.query(
    `SELECT id, email, password_hash, full_name, role, is_active
     FROM users WHERE email = $1`,
    [email.toLowerCase()]
  );
  
  const user = result.rows[0];
  
  if (!user) {
    logger.warn('Login failed - user not found', { email });
    throw ApiError.unauthorized('Invalid email or password');
  }
  
  if (!user.is_active) {
    logger.warn('Login failed - account disabled', { userId: user.id });
    throw ApiError.forbidden('Account is disabled');
  }
  
  // Verify password
  const isValid = await comparePassword(password, user.password_hash);
  
  if (!isValid) {
    logger.warn('Login failed - invalid password', { userId: user.id });
    throw ApiError.unauthorized('Invalid email or password');
  }
  
  // Update last login
  await db.query(
    'UPDATE users SET last_login_at = NOW() WHERE id = $1',
    [user.id]
  );
  
  // Generate tokens
  const accessToken = generateAccessToken({
    userId: user.id,
    email: user.email,
    role: user.role,
  });
  
  const refreshToken = generateSecureToken();
  await storeRefreshToken(user.id, refreshToken, req.ip);
  
  logger.info('User logged in', { userId: user.id });
  
  return {
    user: {
      id: user.id,
      email: user.email,
      fullName: user.full_name,
      role: user.role,
    },
    accessToken,
    refreshToken,
  };
}

/**
 * Refresh access token with token rotation
 */
export async function refreshAccessToken(refreshToken, req) {
  if (!refreshToken) {
    throw ApiError.unauthorized('Refresh token required');
  }
  
  // Verify token
  const tokenData = await verifyRefreshToken(refreshToken);
  
  if (!tokenData) {
    throw ApiError.unauthorized('Invalid or expired refresh token');
  }
  
  // Get user
  const userResult = await db.query(
    'SELECT id, email, role, is_active FROM users WHERE id = $1',
    [tokenData.user_id]
  );
  
  if (userResult.rows.length === 0 || !userResult.rows[0].is_active) {
    throw ApiError.unauthorized('User not found or inactive');
  }
  
  const user = userResult.rows[0];
  
  // Rotate token (revoke old, create new)
  const newRefreshToken = await rotateRefreshToken(
    refreshToken,
    user.id,
    req.ip
  );
  
  // Generate new access token
  const accessToken = generateAccessToken({
    userId: user.id,
    email: user.email,
    role: user.role,
  });
  
  logger.info('Token refreshed', { userId: user.id });
  
  return {
    accessToken,
    refreshToken: newRefreshToken,
  };
}

/**
 * Logout - revoke refresh token
 */
export async function logout(refreshToken, req) {
  if (!refreshToken) {
    return;
  }
  
  await revokeRefreshToken(refreshToken, req.ip);
  logger.info('User logged out');
}

/**
 * Request password reset
 */
export async function requestPasswordReset(email, req) {
  // Get user (but don't reveal if email exists)
  const result = await db.query(
    'SELECT id, email, full_name FROM users WHERE email = $1 AND is_active = true',
    [email.toLowerCase()]
  );
  
  if (result.rows.length === 0) {
    // For security, always return success
    logger.warn('Password reset requested for non-existent email', { email });
    return { message: 'If email exists, reset link will be sent' };
  }
  
  const user = result.rows[0];
  
  // Generate reset token (6-hour expiry)
  const resetToken = generateSecureToken();
  const tokenHash = hashToken(resetToken);
  const expiresAt = new Date(Date.now() + 6 * 60 * 60 * 1000); // 6 hours
  
  // Store token
  await db.query(
    `INSERT INTO password_reset_tokens (
      id, user_id, token_hash, expires_at, created_at, created_by_ip
    ) VALUES ($1, $2, $3, $4, NOW(), $5)`,
    [uuidv4(), user.id, tokenHash, expiresAt, req.ip]
  );
  
  // Send email (async, don't block)
  sendPasswordReset(user.email, user.full_name, resetToken).catch(err => {
    logger.error('Failed to send password reset email', { 
      error: err.message,
      userId: user.id,
    });
  });
  
  logger.info('Password reset requested', { userId: user.id });
  
  return { message: 'If email exists, reset link will be sent' };
}

/**
 * Reset password with token
 */
export async function resetPassword(token, newPassword, req) {
  const tokenHash = hashToken(token);
  
  // Get reset token
  const result = await db.query(
    `SELECT id, user_id, expires_at, used_at
     FROM password_reset_tokens
     WHERE token_hash = $1`,
    [tokenHash]
  );
  
  if (result.rows.length === 0) {
    throw ApiError.badRequest('Invalid or expired reset token');
  }
  
  const resetData = result.rows[0];
  
  // Check if already used
  if (resetData.used_at) {
    throw ApiError.badRequest('Reset token already used');
  }
  
  // Check if expired
  if (new Date(resetData.expires_at) < new Date()) {
    throw ApiError.badRequest('Reset token expired');
  }
  
  // Hash new password
  const passwordHash = await hashPassword(newPassword);
  
  // Update password and revoke all refresh tokens
  await db.transaction(async (client) => {
    // Update password
    await client.query(
      'UPDATE users SET password_hash = $1, updated_at = NOW() WHERE id = $2',
      [passwordHash, resetData.user_id]
    );
    
    // Mark reset token as used
    await client.query(
      'UPDATE password_reset_tokens SET used_at = NOW() WHERE id = $1',
      [resetData.id]
    );
  });
  
  // Revoke all refresh tokens (force re-login everywhere)
  await revokeAllUserTokens(resetData.user_id, 'password_reset');
  
  logger.info('Password reset completed', { userId: resetData.user_id });
  
  return { message: 'Password reset successful' };
}

/**
 * Get current user profile
 */
export async function getCurrentUser(userId) {
  const result = await db.query(
    `SELECT u.id, u.email, u.full_name, u.role, u.is_email_verified, 
            u.created_at, u.last_login_at,
            COUNT(o.id) as organization_count
     FROM users u
     LEFT JOIN organizations o ON o.owner_id = u.id
     WHERE u.id = $1
     GROUP BY u.id`,
    [userId]
  );
  
  if (result.rows.length === 0) {
    throw ApiError.notFound('User not found');
  }
  
  const user = result.rows[0];
  
  return {
    id: user.id,
    email: user.email,
    fullName: user.full_name,
    role: user.role,
    isEmailVerified: user.is_email_verified,
    createdAt: user.created_at,
    lastLoginAt: user.last_login_at,
    organizationCount: parseInt(user.organization_count, 10),
  };
}

/**
 * Change password (requires current password)
 */
export async function changePassword(userId, currentPassword, newPassword) {
  const result = await db.query(
    'SELECT password_hash FROM users WHERE id = $1',
    [userId]
  );
  
  if (result.rows.length === 0) {
    throw ApiError.notFound('User not found');
  }
  
  const user = result.rows[0];
  const isValid = await comparePassword(currentPassword, user.password_hash);
  
  if (!isValid) {
    throw ApiError.badRequest('Current password is incorrect');
  }
  
  const newPasswordHash = await hashPassword(newPassword);
  
  await db.query(
    'UPDATE users SET password_hash = $1, updated_at = NOW() WHERE id = $2',
    [newPasswordHash, userId]
  );
  
  // Revoke all refresh tokens (force re-login everywhere)
  await revokeAllUserTokens(userId, 'password_change');
  
  logger.info('Password changed', { userId });
  
  return { message: 'Password changed successfully' };
}
</file>

<file path="backend/src/modules/auth/auth.validation.js">
import Joi from 'joi';

/**
 * Validation schemas for authentication routes
 */

export const registerSchema = Joi.object({
  email: Joi.string().email().required().messages({
    'string.email': 'Please provide a valid email address',
    'any.required': 'Email is required',
  }),
  password: Joi.string().min(8).required().messages({
    'string.min': 'Password must be at least 8 characters long',
    'any.required': 'Password is required',
  }),
  fullName: Joi.string().min(2).max(100).required().messages({
    'string.min': 'Full name must be at least 2 characters long',
    'string.max': 'Full name must not exceed 100 characters',
    'any.required': 'Full name is required',
  }),
});

export const loginSchema = Joi.object({
  email: Joi.string().email().required().messages({
    'string.email': 'Please provide a valid email address',
    'any.required': 'Email is required',
  }),
  password: Joi.string().required().messages({
    'any.required': 'Password is required',
  }),
});

export const refreshTokenSchema = Joi.object({
  refreshToken: Joi.string().required().messages({
    'any.required': 'Refresh token is required',
  }),
});

export const changePasswordSchema = Joi.object({
  currentPassword: Joi.string().required().messages({
    'any.required': 'Current password is required',
  }),
  newPassword: Joi.string().min(8).required().messages({
    'string.min': 'New password must be at least 8 characters long',
    'any.required': 'New password is required',
  }),
});

export const forgotPasswordSchema = Joi.object({
  email: Joi.string().email().required().messages({
    'string.email': 'Please provide a valid email address',
    'any.required': 'Email is required',
  }),
});

export const resetPasswordSchema = Joi.object({
  token: Joi.string().required().messages({
    'any.required': 'Reset token is required',
  }),
  newPassword: Joi.string().min(8).required().messages({
    'string.min': 'New password must be at least 8 characters long',
    'any.required': 'New password is required',
  }),
});
</file>

<file path="backend/src/modules/auth/auth.validators.js">
// ============================================
// FILE: backend/src/modules/auth/auth.validators.js
// Enhanced validation schemas
// ============================================
import Joi from 'joi';

export const signupSchema = Joi.object({
  email: Joi.string().email().required().messages({
    'string.email': 'Please provide a valid email address',
    'any.required': 'Email is required',
  }),
  password: Joi.string().min(8).max(128).required().messages({
    'string.min': 'Password must be at least 8 characters long',
    'string.max': 'Password must not exceed 128 characters',
    'any.required': 'Password is required',
  }),
  fullName: Joi.string().min(2).max(100).required().messages({
    'string.min': 'Full name must be at least 2 characters',
    'string.max': 'Full name must not exceed 100 characters',
    'any.required': 'Full name is required',
  }),
});

export const loginSchema = Joi.object({
  email: Joi.string().email().required(),
  password: Joi.string().required(),
});

export const refreshTokenSchema = Joi.object({
  refreshToken: Joi.string().optional(), // Can come from cookie or body
});

export const changePasswordSchema = Joi.object({
  currentPassword: Joi.string().required().messages({
    'any.required': 'Current password is required',
  }),
  newPassword: Joi.string().min(8).max(128).required().messages({
    'string.min': 'New password must be at least 8 characters',
    'any.required': 'New password is required',
  }),
});

export const requestPasswordResetSchema = Joi.object({
  email: Joi.string().email().required().messages({
    'string.email': 'Please provide a valid email address',
    'any.required': 'Email is required',
  }),
});

export const resetPasswordSchema = Joi.object({
  token: Joi.string().required().messages({
    'any.required': 'Reset token is required',
  }),
  newPassword: Joi.string().min(8).max(128).required().messages({
    'string.min': 'New password must be at least 8 characters',
    'any.required': 'New password is required',
  }),
});
</file>

<file path="backend/src/modules/auth/email.utils.js">
// ============================================
// FILE: backend/src/modules/auth/email.utils.js
// Email utility with stub implementation (swap with real provider)
// ============================================
import { logger } from '../../lib/logger.js';
import { config } from '../../config/index.js';

/**
 * Email service interface
 * STUB IMPLEMENTATION - Replace with SendGrid, AWS SES, etc.
 */
class EmailService {
  constructor() {
    this.fromEmail = config.email?.from || process.env.EMAIL_FROM || 'noreply@example.com';
    this.frontendUrl = process.env.FRONTEND_URL || 'http://localhost:5173';
  }

  /**
   * Send password reset email
   * @param {string} email - Recipient email
   * @param {string} name - Recipient name
   * @param {string} resetToken - Password reset token
   */
  async sendPasswordReset(email, name, resetToken) {
    const resetUrl = `${this.frontendUrl}/reset-password?token=${resetToken}`;
    
    // STUB: Log email instead of sending (development)
    if (config.nodeEnv === 'development' || config.nodeEnv === 'test') {
      logger.info('📧 [STUB] Password reset email', {
        to: email,
        subject: 'Reset Your Password',
        resetUrl,
        expiresIn: '6 hours',
      });
      
      console.log('\n' + '='.repeat(70));
      console.log('📧 PASSWORD RESET EMAIL (DEVELOPMENT MODE)');
      console.log('='.repeat(70));
      console.log(`To: ${email}`);
      console.log(`Subject: Reset Your Password`);
      console.log('');
      console.log(`Hi ${name},`);
      console.log('');
      console.log('You requested to reset your password. Click the link below:');
      console.log('');
      console.log(`  ${resetUrl}`);
      console.log('');
      console.log('This link will expire in 6 hours.');
      console.log('');
      console.log('If you did not request this, please ignore this email.');
      console.log('='.repeat(70) + '\n');
      
      return { success: true, messageId: 'stub_' + Date.now() };
    }

    // TODO: Replace with real email provider
    // Example with SendGrid:
    // const msg = {
    //   to: email,
    //   from: this.fromEmail,
    //   subject: 'Reset Your Password',
    //   html: this.getPasswordResetTemplate(name, resetUrl),
    // };
    // await sgMail.send(msg);
    
    throw new Error('Email provider not configured for production');
  }

  /**
   * Send email verification email
   * @param {string} email - Recipient email
   * @param {string} name - Recipient name
   * @param {string} verificationToken - Verification token
   */
  async sendEmailVerification(email, name, verificationToken) {
    const verificationUrl = `${this.frontendUrl}/verify-email?token=${verificationToken}`;
    
    if (config.nodeEnv === 'development' || config.nodeEnv === 'test') {
      logger.info('📧 [STUB] Email verification', {
        to: email,
        verificationUrl,
      });
      
      console.log('\n' + '='.repeat(70));
      console.log('📧 EMAIL VERIFICATION (DEVELOPMENT MODE)');
      console.log('='.repeat(70));
      console.log(`To: ${email}`);
      console.log(`Subject: Verify Your Email`);
      console.log('');
      console.log(`Hi ${name},`);
      console.log('');
      console.log('Please verify your email address by clicking:');
      console.log('');
      console.log(`  ${verificationUrl}`);
      console.log('');
      console.log('='.repeat(70) + '\n');
      
      return { success: true, messageId: 'stub_' + Date.now() };
    }

    throw new Error('Email provider not configured for production');
  }

  /**
   * Send welcome email
   * @param {string} email - Recipient email
   * @param {string} name - Recipient name
   */
  async sendWelcome(email, name) {
    if (config.nodeEnv === 'development' || config.nodeEnv === 'test') {
      logger.info('📧 [STUB] Welcome email', { to: email });
      console.log(`\n📧 Welcome email sent to ${email} (STUB)\n`);
      return { success: true, messageId: 'stub_' + Date.now() };
    }

    throw new Error('Email provider not configured for production');
  }

  /**
   * HTML template for password reset email
   * @private
   */
  getPasswordResetTemplate(name, resetUrl) {
    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Reset Your Password</title>
      </head>
      <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
          <h1 style="color: white; margin: 0;">Reset Your Password</h1>
        </div>
        <div style="background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px;">
          <p>Hi ${name},</p>
          <p>You requested to reset your password. Click the button below to create a new password:</p>
          <div style="text-align: center; margin: 30px 0;">
            <a href="${resetUrl}" style="background: #667eea; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block;">Reset Password</a>
          </div>
          <p style="color: #666; font-size: 14px;">This link will expire in 6 hours.</p>
          <p style="color: #666; font-size: 14px;">If you didn't request this, you can safely ignore this email.</p>
          <hr style="border: none; border-top: 1px solid #ddd; margin: 30px 0;">
          <p style="color: #999; font-size: 12px;">If the button doesn't work, copy and paste this link into your browser:</p>
          <p style="color: #999; font-size: 12px; word-break: break-all;">${resetUrl}</p>
        </div>
      </body>
      </html>
    `;
  }
}

export const emailService = new EmailService();

export async function sendPasswordReset(email, name, resetToken) {
  return emailService.sendPasswordReset(email, name, resetToken);
}

export async function sendEmailVerification(email, name, verificationToken) {
  return emailService.sendEmailVerification(email, name, verificationToken);
}

export async function sendWelcome(email, name) {
  return emailService.sendWelcome(email, name);
}

export default emailService;
</file>

<file path="backend/src/modules/auth/jwt.utils.js">
// ============================================
// FILE: backend/src/modules/auth/jwt.utils.js
// ============================================
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import { v4 as uuidv4 } from 'uuid';
import { config } from '../../config/index.js';

/**
 * Generate access token (short-lived)
 */
export function generateAccessToken(payload) {
  const expiresIn = `${process.env.ACCESS_TOKEN_EXPIRES_MIN || 15}m`;
  
  return jwt.sign(
    {
      sub: payload.userId,
      email: payload.email,
      role: payload.role,
      jti: uuidv4(),
      type: 'access',
    },
    config.jwt.secret,
    {
      expiresIn,
      issuer: 'dashboard-api',
      audience: 'dashboard-client',
    }
  );
}

/**
 * Generate refresh token (long-lived, stored in DB)
 */
export function generateRefreshToken() {
  // Generate cryptographically secure random token
  return crypto.randomBytes(32).toString('hex');
}

/**
 * Hash token for storage (SHA-256)
 */
export function hashToken(token) {
  return crypto.createHash('sha256').update(token).digest('hex');
}

/**
 * Verify JWT token
 */
export function verifyAccessToken(token) {
  try {
    const decoded = jwt.verify(token, config.jwt.secret, {
      issuer: 'dashboard-api',
      audience: 'dashboard-client',
    });
    
    if (decoded.type !== 'access') {
      throw new Error('Invalid token type');
    }
    
    return {
      userId: decoded.sub,
      email: decoded.email,
      role: decoded.role,
    };
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      throw new Error('Token expired');
    }
    if (error.name === 'JsonWebTokenError') {
      throw new Error('Invalid token');
    }
    throw error;
  }
}

/**
 * Get token expiry date
 */
export function getTokenExpiry(days) {
  const expiryDays = parseInt(process.env.REFRESH_TOKEN_EXPIRES_DAYS || days || 30, 10);
  const expiry = new Date();
  expiry.setDate(expiry.getDate() + expiryDays);
  return expiry;
}
</file>

<file path="backend/src/modules/auth/password.utils.js">
// ============================================
// FILE: backend/src/modules/auth/password.utils.js
// ============================================
import bcrypt from 'bcryptjs';
import { config } from '../../config/index.js';

const BCRYPT_COST = parseInt(process.env.BCRYPT_COST || '12', 10);

/**
 * Hash password with bcrypt
 * @param {string} password - Plain text password
 * @returns {Promise<string>} Hashed password
 */
export async function hashPassword(password) {
  if (!password || typeof password !== 'string') {
    throw new Error('Password must be a non-empty string');
  }
  
  if (password.length < 8) {
    throw new Error('Password must be at least 8 characters');
  }
  
  return bcrypt.hash(password, BCRYPT_COST);
}

/**
 * Compare password with hash
 * @param {string} password - Plain text password
 * @param {string} hash - Hashed password
 * @returns {Promise<boolean>} True if match
 */
export async function comparePassword(password, hash) {
  if (!password || !hash) {
    return false;
  }
  
  return bcrypt.compare(password, hash);
}

/**
 * Validate password strength
 * @param {string} password - Password to validate
 * @returns {Object} { valid: boolean, errors: string[] }
 */
export function validatePasswordStrength(password) {
  const errors = [];
  
  if (!password) {
    return { valid: false, errors: ['Password is required'] };
  }
  
  if (password.length < 8) {
    errors.push('Password must be at least 8 characters');
  }
  
  if (password.length > 128) {
    errors.push('Password must not exceed 128 characters');
  }
  
  // Optional: enforce complexity
  const hasUppercase = /[A-Z]/.test(password);
  const hasLowercase = /[a-z]/.test(password);
  const hasNumber = /[0-9]/.test(password);
  
  if (!hasUppercase || !hasLowercase || !hasNumber) {
    errors.push('Password must contain uppercase, lowercase, and numbers');
  }
  
  return {
    valid: errors.length === 0,
    errors,
  };
}
</file>

<file path="backend/src/modules/auth/README.md">
-- ============================================
-- FILE: backend/src/modules/auth/README.md
-- Complete documentation with examples
-- ============================================
/*
# Authentication Module

Production-ready authentication system with JWT tokens, refresh token rotation, rate limiting, and password reset functionality.

## Features

✅ **Secure Registration & Login**
- Bcrypt password hashing (cost 12)
- Email validation
- Automatic organization creation

✅ **Token Management**
- Short-lived access tokens (15 min)
- Long-lived refresh tokens (30 days)
- Automatic token rotation (replay attack prevention)
- HttpOnly cookies for refresh tokens
- Token revocation on logout

✅ **Password Reset**
- Secure reset tokens (6-hour expiry)
- Email delivery (configurable)
- Single-use tokens
- All sessions revoked on password change

✅ **Security Features**
- Rate limiting (5 attempts per 15 min)
- IP tracking for audit
- CSRF protection ready
- Token hashing (SHA-256)
- No plaintext tokens stored

## API Endpoints

### 1. User Registration

**POST** `/api/auth/signup`

Register a new user account and create a default organization.

```bash
curl -X POST http://localhost:5000/api/auth/signup \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "SecurePass123!",
    "fullName": "John Doe"
  }'
```

**Response (201 Created):**
```json
{
  "success": true,
  "message": "Registration successful",
  "data": {
    "user": {
      "id": "uuid",
      "email": "user@example.com",
      "fullName": "John Doe",
      "role": "user"
    },
    "accessToken": "eyJhbGciOiJIUzI1NiIs..."
  }
}
```

**Cookie Set:** `refreshToken` (HttpOnly, Secure, 30 days)

---

### 2. User Login

**POST** `/api/auth/login`

Authenticate with email and password.

```bash
curl -X POST http://localhost:5000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "SecurePass123!"
  }'
```

**Response (200 OK):**
```json
{
  "success": true,
  "message": "Login successful",
  "data": {
    "user": {
      "id": "uuid",
      "email": "user@example.com",
      "fullName": "John Doe",
      "role": "user"
    },
    "accessToken": "eyJhbGciOiJIUzI1NiIs..."
  }
}
```

**Rate Limiting:** 5 attempts per 15 minutes per IP

---

### 3. Refresh Access Token

**POST** `/api/auth/refresh`

Get a new access token using refresh token. **Old refresh token is automatically revoked** (rotation).

```bash
# Using cookie (preferred)
curl -X POST http://localhost:5000/api/auth/refresh \
  -b "refreshToken=your_refresh_token"

# Using body (fallback)
curl -X POST http://localhost:5000/api/auth/refresh \
  -H "Content-Type: application/json" \
  -d '{"refreshToken": "your_refresh_token"}'
```

**Response (200 OK):**
```json
{
  "success": true,
  "message": "Token refreshed",
  "data": {
    "accessToken": "new_access_token_here"
  }
}
```

**Cookie Set:** New `refreshToken` (old one is revoked)

---

### 4. Logout

**POST** `/api/auth/logout`

Revoke refresh token and clear cookies.

```bash
curl -X POST http://localhost:5000/api/auth/logout \
  -b "refreshToken=your_refresh_token"
```

**Response (200 OK):**
```json
{
  "success": true,
  "message": "Logout successful"
}
```

---

### 5. Get Current User

**GET** `/api/auth/me`

Get authenticated user's profile.

```bash
curl -X GET http://localhost:5000/api/auth/me \
  -H "Authorization: Bearer your_access_token"
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "user": {
      "id": "uuid",
      "email": "user@example.com",
      "fullName": "John Doe",
      "role": "user",
      "isEmailVerified": false,
      "createdAt": "2025-01-15T10:00:00.000Z",
      "lastLoginAt": "2025-01-15T14:30:00.000Z"
    }
  }
}
```

---

### 6. Request Password Reset

**POST** `/api/auth/request-password-reset`

Request a password reset link via email.

```bash
curl -X POST http://localhost:5000/api/auth/request-password-reset \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com"
  }'
```

**Response (200 OK):**
```json
{
  "success": true,
  "message": "If email exists, reset link will be sent"
}
```

**Rate Limiting:** 3 attempts per hour per IP

**Note:** For security, the same response is returned whether the email exists or not.

---

### 7. Reset Password

**POST** `/api/auth/reset-password`

Reset password using the token from email.

```bash
curl -X POST http://localhost:5000/api/auth/reset-password \
  -H "Content-Type: application/json" \
  -d '{
    "token": "reset_token_from_email",
    "newPassword": "NewSecurePass123!"
  }'
```

**Response (200 OK):**
```json
{
  "success": true,
  "message": "Password reset successful"
}
```

**Side Effects:**
- Password is updated
- All existing refresh tokens are revoked
- User must log in again

---

## Environment Variables

Add these to your `.env` file:

```bash
# JWT Configuration
JWT_SECRET=your-super-secret-key-min-32-characters-long
ACCESS_TOKEN_EXPIRES_MIN=15
REFRESH_TOKEN_EXPIRES_DAYS=30

# Password Hashing
BCRYPT_COST=12

# Rate Limiting
LOGIN_RATE_LIMIT_MAX=5
LOGIN_RATE_LIMIT_WINDOW_MIN=15

# Frontend URL (for password reset links)
FRONTEND_URL=http://localhost:5173

# Email Configuration (for password reset)
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASS=your-app-password
EMAIL_FROM=noreply@yourdomain.com
```

## Security Considerations

### 🔒 Token Security

1. **Access Tokens**
   - Short-lived (15 minutes)
   - Stored in memory on client
   - Sent via Authorization header
   - Cannot be revoked (design trade-off for performance)

2. **Refresh Tokens**
   - Long-lived (30 days)
   - Stored in HttpOnly cookies
   - Only SHA-256 hash stored in database
   - Can be revoked
   - Automatically rotated on each use

### 🛡️ Protection Measures

- **Rate Limiting:** Prevents brute-force attacks
- **Token Rotation:** Old refresh tokens cannot be reused
- **IP Tracking:** Audit trail for security investigations
- **Password Hashing:** Bcrypt with cost factor 12
- **Secure Cookies:** HttpOnly, Secure (in production), SameSite
- **CSRF Ready:** Cookie-based refresh tokens work with CSRF middleware

### ⚠️ Important Notes

1. **Never log tokens:** Tokens are sanitized from logs
2. **HTTPS in production:** Required for secure cookies
3. **Rotate JWT_SECRET:** Change on suspected compromise
4. **Monitor failed logins:** Implement alerting for repeated failures
5. **Token cleanup:** Run `SELECT cleanup_expired_tokens()` daily

## Testing

### Run All Tests

```bash
cd backend
npm test
```

### Run Specific Test Suites

```bash
# Unit tests only
npm test -- auth.unit.test.js

# Integration tests only
npm test -- auth.integration.test.js

# With coverage
npm run test:coverage
```

### Manual Testing Flow

```bash
# 1. Register
curl -X POST http://localhost:5000/api/auth/signup \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","password":"Test1234!","fullName":"Test User"}' \
  -c cookies.txt

# 2. Get current user
TOKEN=$(curl -s -X POST http://localhost:5000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","password":"Test1234!"}' | jq -r '.data.accessToken')

curl -X GET http://localhost:5000/api/auth/me \
  -H "Authorization: Bearer $TOKEN"

# 3. Refresh token
curl -X POST http://localhost:5000/api/auth/refresh \
  -b cookies.txt

# 4. Logout
curl -X POST http://localhost:5000/api/auth/logout \
  -b cookies.txt
```

## Deployment Checklist

### Before Deployment

- [ ] Generate strong `JWT_SECRET` (min 32 chars)
  ```bash
  openssl rand -base64 48
  ```
- [ ] Set `NODE_ENV=production`
- [ ] Configure email provider
- [ ] Set correct `FRONTEND_URL`
- [ ] Enable HTTPS
- [ ] Review rate limit thresholds
- [ ] Set up database backups

### After Deployment

- [ ] Run migration: `npm run migrate`
- [ ] Test signup/login flow
- [ ] Test password reset email
- [ ] Verify secure cookies set
- [ ] Monitor error logs
- [ ] Set up token cleanup cron job

### Cron Job for Token Cleanup

Add to crontab to run daily at 2 AM:

```bash
0 2 * * * psql $DATABASE_URL -c "SELECT cleanup_expired_tokens();"
```

## Troubleshooting

### Issue: "Invalid refresh token" on refresh

**Cause:** Token already used (rotation) or expired.

**Solution:** User must log in again.

---

### Issue: Rate limit exceeded

**Cause:** Too many failed login attempts.

**Solution:** Wait 15 minutes or implement IP whitelist for testing.

---

### Issue: Password reset email not sent

**Cause:** Email service not configured.

**Solution:** 
1. Check SMTP configuration in `.env`
2. Review logs for email service errors
3. For development, reset token is logged to console

---

### Issue: "Token expired" immediately after login

**Cause:** Server/client time mismatch.

**Solution:** Sync server time with NTP.

## Email Service Integration

The default implementation logs reset emails to console. For production, integrate with:

**SendGrid:**
```javascript
import sgMail from '@sendgrid/mail';
sgMail.setApiKey(process.env.SENDGRID_API_KEY);

async function sendPasswordResetEmail(email, name, resetUrl) {
  await sgMail.send({
    to: email,
    from: process.env.EMAIL_FROM,
    subject: 'Reset your password',
    html: `<p>Hi ${name},</p><p><a href="${resetUrl}">Reset password</a></p>`,
  });
}
```

**AWS SES:**
```javascript
import { SESClient, SendEmailCommand } from '@aws-sdk/client-ses';

const ses = new SESClient({ region: 'us-east-1' });

async function sendPasswordResetEmail(email, name, resetUrl) {
  await ses.send(new SendEmailCommand({
    Source: process.env.EMAIL_FROM,
    Destination: { ToAddresses: [email] },
    Message: {
      Subject: { Data: 'Reset your password' },
      Body: { Html: { Data: `<a href="${resetUrl}">Reset</a>` } },
    },
  }));
}
```

## Support

For issues or questions:
1. Check logs: `docker-compose logs api`
2. Review test output: `npm test`
3. Check database: `psql $DATABASE_URL`
4. Contact team via Slack

## License

MIT
</file>

<file path="backend/src/modules/auth/tokens.utils.js">
// ============================================
// FILE: backend/src/modules/auth/tokens.utils.js
// Refresh token hashing and rotation utilities
// ============================================
import crypto from 'crypto';
import { v4 as uuidv4 } from 'uuid';
import db from '../../config/db.js';
import { logger } from '../../lib/logger.js';

/**
 * Generate cryptographically secure refresh token
 * @returns {string} 64-character hex string
 */
export function generateSecureToken() {
  return crypto.randomBytes(32).toString('hex');
}

/**
 * Hash token using SHA-256
 * @param {string} token - Plain token
 * @returns {string} Hashed token (hex)
 */
export function hashToken(token) {
  return crypto.createHash('sha256').update(token).digest('hex');
}

/**
 * Get expiry date for refresh token
 * @param {number} days - Days until expiry (default from env)
 * @returns {Date} Expiry date
 */
export function getRefreshTokenExpiry(days = null) {
  const expiryDays = days || parseInt(process.env.REFRESH_TOKEN_EXPIRES_DAYS || '30', 10);
  const expiry = new Date();
  expiry.setDate(expiry.getDate() + expiryDays);
  return expiry;
}

/**
 * Store refresh token in database
 * @param {string} userId - User ID
 * @param {string} token - Plain refresh token
 * @param {string} ip - Client IP address
 * @returns {Promise<{id: string, token: string}>}
 */
export async function storeRefreshToken(userId, token, ip) {
  const tokenHash = hashToken(token);
  const expiresAt = getRefreshTokenExpiry();
  const tokenId = uuidv4();

  await db.query(
    `INSERT INTO refresh_tokens (
      id, token, token_hash, user_id, expires_at, created_at, created_by_ip
    ) VALUES ($1, $2, $3, $4, $5, NOW(), $6)`,
    [tokenId, token, tokenHash, userId, expiresAt, ip]
  );

  logger.debug('Refresh token stored', { tokenId, userId, expiresAt });

  return { id: tokenId, token };
}

/**
 * Verify and retrieve refresh token from database
 * @param {string} token - Plain refresh token
 * @returns {Promise<object|null>} Token data or null if invalid
 */
export async function verifyRefreshToken(token) {
  const tokenHash = hashToken(token);

  const result = await db.query(
    `SELECT id, user_id, expires_at, revoked_at, revoked_by_ip, replaced_by_token
     FROM refresh_tokens
     WHERE token_hash = $1`,
    [tokenHash]
  );

  if (result.rows.length === 0) {
    logger.warn('Refresh token not found', { tokenHash: tokenHash.substring(0, 8) });
    return null;
  }

  const tokenData = result.rows[0];

  // Check if revoked
  if (tokenData.revoked_at) {
    logger.warn('Refresh token was revoked', {
      tokenId: tokenData.id,
      revokedAt: tokenData.revoked_at,
    });
    return null;
  }

  // Check if expired
  if (new Date(tokenData.expires_at) < new Date()) {
    logger.warn('Refresh token expired', {
      tokenId: tokenData.id,
      expiresAt: tokenData.expires_at,
    });
    return null;
  }

  return tokenData;
}

/**
 * Rotate refresh token (revoke old, create new)
 * Implements refresh token rotation for replay attack prevention
 * 
 * @param {string} oldToken - Current refresh token
 * @param {string} userId - User ID
 * @param {string} ip - Client IP address
 * @returns {Promise<string>} New refresh token
 */
export async function rotateRefreshToken(oldToken, userId, ip) {
  const oldTokenData = await verifyRefreshToken(oldToken);

  if (!oldTokenData) {
    throw new Error('Invalid or expired refresh token');
  }

  // Generate new token
  const newToken = generateSecureToken();
  const newTokenHash = hashToken(newToken);
  const newTokenId = uuidv4();
  const expiresAt = getRefreshTokenExpiry();

  // Atomic operation: revoke old, create new
  await db.transaction(async (client) => {
    // Revoke old token
    await client.query(
      `UPDATE refresh_tokens
       SET revoked_at = NOW(),
           revoked_by_ip = $1,
           replaced_by_token = $2
       WHERE id = $3`,
      [ip, newTokenId, oldTokenData.id]
    );

    // Create new token
    await client.query(
      `INSERT INTO refresh_tokens (
        id, token, token_hash, user_id, expires_at, created_at, created_by_ip
      ) VALUES ($1, $2, $3, $4, $5, NOW(), $6)`,
      [newTokenId, newToken, newTokenHash, userId, expiresAt, ip]
    );
  });

  logger.info('Refresh token rotated', {
    oldTokenId: oldTokenData.id,
    newTokenId,
    userId,
  });

  return newToken;
}

/**
 * Revoke refresh token
 * @param {string} token - Refresh token to revoke
 * @param {string} ip - Client IP address
 * @returns {Promise<boolean>} True if revoked
 */
export async function revokeRefreshToken(token, ip) {
  const tokenHash = hashToken(token);

  const result = await db.query(
    `UPDATE refresh_tokens
     SET revoked_at = NOW(), revoked_by_ip = $1
     WHERE token_hash = $2 AND revoked_at IS NULL
     RETURNING id`,
    [ip, tokenHash]
  );

  if (result.rows.length > 0) {
    logger.info('Refresh token revoked', { tokenId: result.rows[0].id });
    return true;
  }

  return false;
}

/**
 * Revoke all refresh tokens for a user
 * @param {string} userId - User ID
 * @param {string} reason - Reason for revocation
 * @returns {Promise<number>} Number of tokens revoked
 */
export async function revokeAllUserTokens(userId, reason = 'user_action') {
  const result = await db.query(
    `UPDATE refresh_tokens
     SET revoked_at = NOW()
     WHERE user_id = $1 AND revoked_at IS NULL
     RETURNING id`,
    [userId]
  );

  const count = result.rows.length;
  
  if (count > 0) {
    logger.info('All user tokens revoked', { userId, count, reason });
  }

  return count;
}

/**
 * Cleanup expired tokens (should run periodically)
 * @param {number} daysOld - Delete tokens older than this many days
 * @returns {Promise<number>} Number of tokens deleted
 */
export async function cleanupExpiredTokens(daysOld = 30) {
  const result = await db.query(
    `DELETE FROM refresh_tokens
     WHERE expires_at < NOW() - INTERVAL '1 day' * $1
     RETURNING id`,
    [daysOld]
  );

  const count = result.rows.length;
  
  if (count > 0) {
    logger.info('Expired tokens cleaned up', { count, daysOld });
  }

  return count;
}

/**
 * Get active token count for user (for monitoring/security)
 * @param {string} userId - User ID
 * @returns {Promise<number>} Number of active tokens
 */
export async function getUserActiveTokenCount(userId) {
  const result = await db.query(
    `SELECT COUNT(*) as count
     FROM refresh_tokens
     WHERE user_id = $1
       AND revoked_at IS NULL
       AND expires_at > NOW()`,
    [userId]
  );

  return parseInt(result.rows[0].count, 10);
}
</file>

<file path="backend/src/modules/billing/admin.billing.controller.js">
// ============================================
// FILE: backend/src/modules/billing/admin.billing.controller.js
// ============================================
import { asyncHandler } from '../../utils/asyncHandler.js';
import adminBillingService from './admin.billing.service.js';
import { ApiResponse } from '../../utils/ApiResponse.js';
import { ApiError } from '../../utils/ApiError.js';

// Middleware to check admin role
export const requireAdmin = (req, res, next) => {
  if (req.user.role !== 'admin') {
    throw ApiError.forbidden('Admin access required');
  }
  next();
};

class AdminBillingController {
  // Plans
  createPlan = asyncHandler(async (req, res) => {
    const plan = await adminBillingService.createPlan(req.body);
    ApiResponse.created(res, 'Plan created', { plan });
  });

  updatePlan = asyncHandler(async (req, res) => {
    const plan = await adminBillingService.updatePlan(req.params.planId, req.body);
    ApiResponse.success(res, 200, 'Plan updated', { plan });
  });

  deletePlan = asyncHandler(async (req, res) => {
    await adminBillingService.deletePlan(req.params.planId);
    ApiResponse.success(res, 200, 'Plan deleted');
  });

  // Customers
  getAllCustomers = asyncHandler(async (req, res) => {
    const customers = await adminBillingService.getAllCustomers(req.query);
    ApiResponse.success(res, 200, 'Customers retrieved', { customers });
  });

  getCustomerDetails = asyncHandler(async (req, res) => {
    const customer = await adminBillingService.getCustomerDetails(req.params.userId);
    ApiResponse.success(res, 200, 'Customer retrieved', { customer });
  });

  manualUpgrade = asyncHandler(async (req, res) => {
    const result = await adminBillingService.manualUpgrade(
      req.params.userId,
      req.body.planId
    );
    ApiResponse.success(res, 200, result.message);
  });

  setCustomQuota = asyncHandler(async (req, res) => {
    const result = await adminBillingService.setCustomQuota(
      req.params.userId,
      req.body.quotas
    );
    ApiResponse.success(res, 200, result.message);
  });

  // Analytics
  getRevenueAnalytics = asyncHandler(async (req, res) => {
    const analytics = await adminBillingService.getRevenueAnalytics();
    ApiResponse.success(res, 200, 'Analytics retrieved', analytics);
  });

  getFailedPayments = asyncHandler(async (req, res) => {
    const failed = await adminBillingService.getFailedPayments();
    ApiResponse.success(res, 200, 'Failed payments retrieved', { failed });
  });
}

export default new AdminBillingController();
</file>

<file path="backend/src/modules/billing/admin.billing.routes.js">
// ============================================
// FILE: backend/src/modules/billing/admin.billing.routes.js
// ============================================
import { Router } from 'express';
import adminBillingController, { requireAdmin } from './admin.billing.controller.js';
import { authRequired } from '../../middleware/auth.js';

const router = Router();

// All admin routes require authentication and admin role
router.use(authRequired);
router.use(requireAdmin);

// Plans management
router.post('/plans', adminBillingController.createPlan);
router.put('/plans/:planId', adminBillingController.updatePlan);
router.delete('/plans/:planId', adminBillingController.deletePlan);

// Customers
router.get('/customers', adminBillingController.getAllCustomers);
router.get('/customers/:userId', adminBillingController.getCustomerDetails);
router.post('/customers/:userId/upgrade', adminBillingController.manualUpgrade);
router.post('/customers/:userId/quota', adminBillingController.setCustomQuota);

// Analytics
router.get('/analytics', adminBillingController.getRevenueAnalytics);
router.get('/failed-payments', adminBillingController.getFailedPayments);

export default router;
</file>

<file path="backend/src/modules/billing/admin.billing.service.js">
// ============================================
// FILE: backend/src/modules/billing/admin.billing.service.js
// Admin-only billing operations
// ============================================
import { v4 as uuidv4 } from 'uuid';
import db from '../../config/db.js';
import { ApiError } from '../../utils/ApiError.js';

class AdminBillingService {
  // ============================================
  // PLANS MANAGEMENT
  // ============================================

  async createPlan(data) {
    const result = await db.query(
      `INSERT INTO plans (
        id, name, slug, description, monthly_price_cents, yearly_price_cents,
        ls_monthly_variant_id, ls_yearly_variant_id,
        surveys_limit, responses_limit, team_members_limit,
        features, is_active, is_featured, sort_order, created_at, updated_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, NOW(), NOW())
      RETURNING *`,
      [
        uuidv4(),
        data.name,
        data.slug,
        data.description,
        data.monthlyPriceCents,
        data.yearlyPriceCents,
        data.lsMonthlyVariantId,
        data.lsYearlyVariantId,
        data.surveysLimit,
        data.responsesLimit,
        data.teamMembersLimit,
        JSON.stringify(data.features || []),
        data.isActive !== false,
        data.isFeatured || false,
        data.sortOrder || 0,
      ]
    );

    return result.rows[0];
  }

  async updatePlan(planId, data) {
    const sets = [];
    const values = [];
    let idx = 1;

    if (data.name !== undefined) {
      sets.push(`name = $${idx++}`);
      values.push(data.name);
    }
    if (data.description !== undefined) {
      sets.push(`description = $${idx++}`);
      values.push(data.description);
    }
    if (data.monthlyPriceCents !== undefined) {
      sets.push(`monthly_price_cents = $${idx++}`);
      values.push(data.monthlyPriceCents);
    }
    if (data.yearlyPriceCents !== undefined) {
      sets.push(`yearly_price_cents = $${idx++}`);
      values.push(data.yearlyPriceCents);
    }
    if (data.surveysLimit !== undefined) {
      sets.push(`surveys_limit = $${idx++}`);
      values.push(data.surveysLimit);
    }
    if (data.responsesLimit !== undefined) {
      sets.push(`responses_limit = $${idx++}`);
      values.push(data.responsesLimit);
    }
    if (data.features !== undefined) {
      sets.push(`features = $${idx++}`);
      values.push(JSON.stringify(data.features));
    }
    if (data.isActive !== undefined) {
      sets.push(`is_active = $${idx++}`);
      values.push(data.isActive);
    }

    values.push(planId);

    const result = await db.query(
      `UPDATE plans SET ${sets.join(', ')}, updated_at = NOW()
       WHERE id = $${idx} RETURNING *`,
      values
    );

    if (result.rows.length === 0) {
      throw ApiError.notFound('Plan not found');
    }

    return result.rows[0];
  }

  async deletePlan(planId) {
    // Check if any active subscriptions use this plan
    const check = await db.query(
      `SELECT COUNT(*) FROM subscriptions WHERE plan_id = $1 AND status = 'active'`,
      [planId]
    );

    if (parseInt(check.rows[0].count) > 0) {
      throw ApiError.badRequest('Cannot delete plan with active subscriptions');
    }

    await db.query(`DELETE FROM plans WHERE id = $1`, [planId]);
  }

  // ============================================
  // CUSTOMERS
  // ============================================

  async getAllCustomers(filters = {}) {
    let whereClause = '1=1';
    const params = [];
    let idx = 1;

    if (filters.status) {
      whereClause += ` AND s.status = $${idx++}`;
      params.push(filters.status);
    }

    if (filters.planSlug) {
      whereClause += ` AND p.slug = $${idx++}`;
      params.push(filters.planSlug);
    }

    const result = await db.query(
      `SELECT 
        u.id as user_id,
        u.email,
        u.full_name,
        s.id as subscription_id,
        s.status,
        s.ls_subscription_id,
        s.billing_cycle,
        s.current_period_end,
        s.renews_at,
        s.cancelled_at,
        p.name as plan_name,
        p.slug as plan_slug,
        s.surveys_used,
        s.responses_used,
        s.created_at as subscribed_at
      FROM users u
      LEFT JOIN subscriptions s ON u.subscription_id = s.id
      LEFT JOIN plans p ON s.plan_id = p.id
      WHERE ${whereClause}
      ORDER BY s.created_at DESC`,
      params
    );

    return result.rows;
  }

  async getCustomerDetails(userId) {
    const result = await db.query(
      `SELECT 
        u.*,
        s.id as subscription_id,
        s.status as subscription_status,
        s.billing_cycle,
        s.current_period_end,
        s.renews_at,
        p.name as plan_name,
        p.slug as plan_slug
      FROM users u
      LEFT JOIN subscriptions s ON u.subscription_id = s.id
      LEFT JOIN plans p ON s.plan_id = p.id
      WHERE u.id = $1`,
      [userId]
    );

    if (result.rows.length === 0) {
      throw ApiError.notFound('Customer not found');
    }

    return result.rows[0];
  }

  async manualUpgrade(userId, planId) {
    const plan = await db.query(`SELECT * FROM plans WHERE id = $1`, [planId]);
    
    if (plan.rows.length === 0) {
      throw ApiError.notFound('Plan not found');
    }

    // Get current subscription
    const currentSub = await db.query(
      `SELECT id FROM subscriptions WHERE user_id = $1 AND status = 'active'`,
      [userId]
    );

    if (currentSub.rows.length > 0) {
      // Update existing subscription
      await db.query(
        `UPDATE subscriptions 
         SET plan_id = $1, updated_at = NOW()
         WHERE id = $2`,
        [planId, currentSub.rows[0].id]
      );
    } else {
      // Create new subscription
      const newSubId = uuidv4();
      await db.query(
        `INSERT INTO subscriptions (
          id, user_id, plan_id, ls_subscription_id, ls_variant_id,
          status, billing_cycle, usage_reset_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())`,
        [newSubId, userId, planId, `manual_${uuidv4()}`, 'manual', 'active', 'monthly']
      );

      await db.query(
        `UPDATE users SET subscription_id = $1 WHERE id = $2`,
        [newSubId, userId]
      );
    }

    return { message: 'Customer upgraded successfully' };
  }

  async setCustomQuota(userId, quotas) {
    const subscription = await db.query(
      `SELECT id FROM subscriptions WHERE user_id = $1 AND status = 'active'`,
      [userId]
    );

    if (subscription.rows.length === 0) {
      throw ApiError.notFound('No active subscription');
    }

    const meta = await db.query(
      `SELECT metadata FROM subscriptions WHERE id = $1`,
      [subscription.rows[0].id]
    );

    const metadata = meta.rows[0].metadata || {};
    metadata.customQuotas = quotas;

    await db.query(
      `UPDATE subscriptions SET metadata = $1 WHERE id = $2`,
      [JSON.stringify(metadata), subscription.rows[0].id]
    );

    return { message: 'Custom quotas set' };
  }

  // ============================================
  // REVENUE ANALYTICS
  // ============================================

  async getRevenueAnalytics() {
    // MRR (Monthly Recurring Revenue)
    const mrrResult = await db.query(
      `SELECT 
        SUM(CASE 
          WHEN s.billing_cycle = 'monthly' THEN p.monthly_price_cents 
          WHEN s.billing_cycle = 'yearly' THEN p.yearly_price_cents / 12
        END) / 100.0 as mrr
      FROM subscriptions s
      JOIN plans p ON s.plan_id = p.id
      WHERE s.status IN ('active', 'on_trial')`
    );

    const mrr = parseFloat(mrrResult.rows[0].mrr || 0);

    // ARR (Annual Recurring Revenue)
    const arr = mrr * 12;

    // Active subscriptions
    const activeResult = await db.query(
      `SELECT COUNT(*) FROM subscriptions WHERE status IN ('active', 'on_trial')`
    );
    const activeSubscriptions = parseInt(activeResult.rows[0].count);

    // Churn rate (cancelled in last 30 days)
    const churnResult = await db.query(
      `SELECT 
        COUNT(*) FILTER (WHERE cancelled_at >= NOW() - INTERVAL '30 days') as churned,
        COUNT(*) as total_active
      FROM subscriptions
      WHERE status = 'active' OR cancelled_at >= NOW() - INTERVAL '30 days'`
    );

    const churnRate =
      churnResult.rows[0].total_active > 0
        ? (parseFloat(churnResult.rows[0].churned) / parseFloat(churnResult.rows[0].total_active)) * 100
        : 0;

    // Monthly revenue trend (last 12 months)
    const trendResult = await db.query(
      `SELECT 
        DATE_TRUNC('month', created_at) as month,
        SUM(amount_cents) / 100.0 as revenue
      FROM invoices
      WHERE status = 'paid' AND created_at >= NOW() - INTERVAL '12 months'
      GROUP BY month
      ORDER BY month DESC`
    );

    // Plan distribution
    const planDistResult = await db.query(
      `SELECT 
        p.name,
        p.slug,
        COUNT(*) as count
      FROM subscriptions s
      JOIN plans p ON s.plan_id = p.id
      WHERE s.status IN ('active', 'on_trial')
      GROUP BY p.name, p.slug
      ORDER BY count DESC`
    );

    return {
      mrr,
      arr,
      activeSubscriptions,
      churnRate: parseFloat(churnRate.toFixed(2)),
      monthlyRevenueTrend: trendResult.rows,
      planDistribution: planDistResult.rows,
    };
  }

  async getFailedPayments() {
    const result = await db.query(
      `SELECT 
        u.email,
        u.full_name,
        s.id as subscription_id,
        s.ls_subscription_id,
        s.current_period_end,
        p.name as plan_name
      FROM subscriptions s
      JOIN users u ON s.user_id = u.id
      JOIN plans p ON s.plan_id = p.id
      WHERE s.status = 'past_due'
      ORDER BY s.current_period_end ASC`
    );

    return result.rows;
  }
}

export default new AdminBillingService();
</file>

<file path="backend/src/modules/embed/embed.controller.js">
// dashboard/backend/src/modules/embed/embed.controller.js
// Minimal fix: add db require (was missing) and provide the published-survey fetch function.

const db = require('../../config/db'); // <-- FIX: ensure db is imported
// If your project uses a different path, adjust the require above accordingly.

/**
 * GET /embed/survey/:surveyId/published
 * Returns survey data if it's published.
 */
async function getPublishedSurvey(req, res) {
  try {
    const { surveyId } = req.params;
    if (!surveyId) {
      return res.status(400).json({ error: 'surveyId parameter is required' });
    }

    const sql = `
      SELECT id, title, config, status, created_at, updated_at
      FROM surveys
      WHERE id = $1
        AND status = 'published'
      LIMIT 1;
    `;

    const { rows } = await db.query(sql, [surveyId]);

    if (!rows || rows.length === 0) {
      return res.status(404).json({ error: 'Published survey not found' });
    }

    return res.json({ survey: rows[0] });
  } catch (err) {
    console.error('embed.controller.getPublishedSurvey error:', err);
    return res.status(500).json({ error: 'Internal server error' });
  }
}

module.exports = {
  getPublishedSurvey,
};
</file>

<file path="backend/src/modules/embed/embed.routes.js">
// ============================================
// FILE: backend/src/modules/embed/embed.routes.js (NEW)
// ============================================
import { Router } from 'express';
import { getPublishedSurvey } from './embed.controller.js';

const router = Router();

// Public endpoint - no auth required
router.get('/:surveyKey', getPublishedSurvey);

export default router;
</file>

<file path="backend/src/modules/integration/integration.controller.js">
import { asyncHandler } from "../../utils/asyncHandler.js";
import * as integrationService from "./integration.service.js";

export const registerSite = asyncHandler(async (req, res) => {
  const result = await integrationService.registerSite(req.user.userId, req.body);

  res.status(201).json({
    success: true,
    message: "Site registered successfully",
    data: result,
  });
});

export const getSiteStats = asyncHandler(async (req, res) => {
  const { siteKey } = req.params;

  const stats = await integrationService.getSiteStats(siteKey);

  res.json({
    success: true,
    data: stats,
  });
});

export const pushResponses = asyncHandler(async (req, res) => {
  const { siteKey, responses } = req.body;

  const result = await integrationService.pushResponses(siteKey, responses);

  res.status(201).json({
    success: true,
    message: "Responses recorded successfully",
    data: result,
  });
});

export const getActiveQuestions = asyncHandler(async (req, res) => {
  const { siteKey } = req.query;

  const questions = await integrationService.getActiveQuestions(siteKey);

  res.json({
    success: true,
    data: { questions },
  });
});

export default {
  registerSite,
  getSiteStats,
  pushResponses,
  getActiveQuestions,
};
</file>

<file path="backend/src/modules/integration/integration.routes.js">
import { Router } from "express";
import integrationController from "./integration.controller.js";
import { authRequired } from "../../middleware/auth.js";

const router = Router();

// Protected route - register new site
router.post("/captcha/register-site", authRequired, integrationController.registerSite);

// Public routes - for captcha-API integration
router.get("/captcha/stats/:siteKey", integrationController.getSiteStats);
router.post("/captcha/push-responses", integrationController.pushResponses);
router.get("/captcha/questions", integrationController.getActiveQuestions);

export default router;
</file>

<file path="backend/src/modules/integration/integration.service.js">
// dashboard/backend/src/modules/integration/integration.service.js
// Minimal fix: correct SQL placeholder generation for batched insert (remove malformed $...} placeholder).

const db = require('../../config/db'); // adjust path if needed

/**
 * Push multiple response records into the database in a single batched INSERT.
 *
 * Expected input: an array of response objects:
 * [
 *   {
 *     questionId: 'uuid',
 *     responseText: 'answer',
 *     responseData: { ... },       // optional JSON/object
 *     sessionId: 'uuid',
 *     ipAddress: '1.2.3.4',
 *     userAgent: '...',
 *     countryCode: 'PK'
 *   },
 *   ...
 * ]
 *
 * This function builds a parameterized batched insert safely.
 */
async function pushResponses(responses = []) {
  if (!Array.isArray(responses) || responses.length === 0) return;

  // We'll build parameter placeholders dynamically:
  const params = [];
  const valueClauses = [];
  let paramIndex = 1;

  for (const r of responses) {
    // Ensure required field questionId exists; if not, skip this entry
    if (!r || !r.questionId) continue;

    // For each response we need placeholders for:
    // question_id, response_text, response_data, session_id, ip_address, user_agent, country_code
    // That's 7 placeholders per row. id is generated via gen_random_uuid(), created_at via NOW()
    valueClauses.push(
      `(gen_random_uuid(), $${paramIndex++}, $${paramIndex++}, $${paramIndex++}, $${paramIndex++}, $${paramIndex++}, $${paramIndex++}, $${paramIndex++}, NOW())`
    );

    // push values in the same order as placeholders
    params.push(
      r.questionId,
      r.responseText == null ? null : r.responseText,
      r.responseData == null ? null : JSON.stringify(r.responseData),
      r.sessionId == null ? null : r.sessionId,
      r.ipAddress == null ? null : r.ipAddress,
      r.userAgent == null ? null : r.userAgent,
      r.countryCode == null ? null : r.countryCode
    );
  }

  if (valueClauses.length === 0) return;

  const insertSQL = `
    INSERT INTO responses
      (id, question_id, response_text, response_data, session_id, ip_address, user_agent, country_code, created_at)
    VALUES
      ${valueClauses.join(', ')}
    ;
  `;

  try {
    await db.query(insertSQL, params);
  } catch (err) {
    // Log and rethrow or handle according to your app's error strategy
    console.error('integration.service.pushResponses error:', err);
    throw err;
  }
}

module.exports = {
  pushResponses,
};
</file>

<file path="backend/src/modules/organizations/organizations.controller.js">
// ============================================
// organizations.controller.js
// ============================================
import organizationsService from './organizations.service.js';
import { ApiResponse } from '../../utils/ApiResponse.js';
import { asyncHandler } from '../../utils/asyncHandler.js';

class OrganizationsController {
  create = asyncHandler(async (req, res) => {
    const organization = await organizationsService.create(
      req.user.userId,
      req.body
    );

    ApiResponse.created(res, 'Organization created successfully', { organization });
  });

  getAll = asyncHandler(async (req, res) => {
    const { page = 1, limit = 10 } = req.query;
    
    const { organizations, total } = await organizationsService.getAll(
      req.user.userId,
      parseInt(page, 10),
      parseInt(limit, 10)
    );

    ApiResponse.paginated(
      res,
      organizations,
      page,
      limit,
      total,
      'Organizations retrieved successfully'
    );
  });

  getById = asyncHandler(async (req, res) => {
    const organization = await organizationsService.getById(
      req.params.id,
      req.user.userId
    );

    ApiResponse.success(res, 200, 'Organization retrieved successfully', {
      organization,
    });
  });

  update = asyncHandler(async (req, res) => {
    const organization = await organizationsService.update(
      req.params.id,
      req.user.userId,
      req.body
    );

    ApiResponse.success(res, 200, 'Organization updated successfully', {
      organization,
    });
  });

  delete = asyncHandler(async (req, res) => {
    await organizationsService.delete(req.params.id, req.user.userId);

    ApiResponse.success(res, 200, 'Organization deleted successfully');
  });
}

export default new OrganizationsController();
</file>

<file path="backend/src/modules/organizations/organizations.routes.js">
import { Router } from 'express';
import organizationsController from './organizations.controller.js';
import { validate } from '../../middleware/validate.js';
import { authRequired } from '../../middleware/auth.js';
import { createOrganizationSchema, updateOrganizationSchema } from './organizations.validation.js';

const router = Router();

router.use(authRequired);

router.post('/', validate(createOrganizationSchema), organizationsController.create);
router.get('/', organizationsController.getAll);
router.get('/:id', organizationsController.getById);
router.put('/:id', validate(updateOrganizationSchema), organizationsController.update);
router.delete('/:id', organizationsController.delete);

export default router;
</file>

<file path="backend/src/modules/organizations/organizations.service.js">
import { v4 as uuidv4 } from 'uuid';
import db from '../../config/db.js';
import { ApiError } from '../../utils/ApiError.js';

class OrganizationsService {
  async create(userId, { name, slug }) {
    const orgSlug = slug || name.toLowerCase().replace(/[^a-z0-9-]/g, '-');

    const existing = await db.query(
      'SELECT id FROM organizations WHERE slug = $1',
      [orgSlug]
    );

    if (existing.rows.length > 0) {
      throw new ApiError('Organization slug already exists', 409);
    }

    const result = await db.query(
      `INSERT INTO organizations (id, name, slug, owner_id, created_at, updated_at)
       VALUES ($1, $2, $3, $4, NOW(), NOW())
       RETURNING *`,
      [uuidv4(), name, orgSlug, userId]
    );

    return result.rows[0];
  }

  async getAll(userId, page = 1, limit = 10) {
    const offset = (page - 1) * limit;

    const countResult = await db.query(
      'SELECT COUNT(*) FROM organizations WHERE owner_id = $1',
      [userId]
    );

    const result = await db.query(
      `SELECT * FROM organizations 
       WHERE owner_id = $1 
       ORDER BY created_at DESC
       LIMIT $2 OFFSET $3`,
      [userId, limit, offset]
    );

    return {
      organizations: result.rows,
      total: parseInt(countResult.rows[0].count, 10),
    };
  }

  async getById(orgId, userId) {
    const result = await db.query(
      'SELECT * FROM organizations WHERE id = $1 AND owner_id = $2',
      [orgId, userId]
    );

    if (result.rows.length === 0) {
      throw new ApiError('Organization not found', 404);
    }

    return result.rows[0];
  }

  async update(orgId, userId, updates) {
    await this.getById(orgId, userId);

    const result = await db.query(
      `UPDATE organizations 
       SET name = COALESCE($1, name), updated_at = NOW()
       WHERE id = $2 AND owner_id = $3
       RETURNING *`,
      [updates.name, orgId, userId]
    );

    return result.rows[0];
  }

  async delete(orgId, userId) {
    await this.getById(orgId, userId);
    await db.query('DELETE FROM organizations WHERE id = $1', [orgId]);
  }
}

export default new OrganizationsService();
</file>

<file path="backend/src/modules/organizations/organizations.validation.js">
// ============================================
// organizations.validation.js
// ============================================
import Joi from 'joi';

export const createOrganizationSchema = Joi.object({
  name: Joi.string().min(2).max(100).required(),
  slug: Joi.string().pattern(/^[a-z0-9-]+$/).min(2).max(50).optional(),
});

export const updateOrganizationSchema = Joi.object({
  name: Joi.string().min(2).max(100).optional(),
});
</file>

<file path="backend/src/modules/questions/questions.controller.js">
// ============================================
// questions.controller.js
// ============================================
import questionsService from './questions.service.js';
import { ApiResponse } from '../../utils/ApiResponse.js';
import { asyncHandler } from '../../utils/asyncHandler.js';

class QuestionsController {
  create = asyncHandler(async (req, res) => {
    const question = await questionsService.create(req.user.userId, req.body);
    ApiResponse.created(res, 'Question created successfully', { question });
  });

  getAll = asyncHandler(async (req, res) => {
    const { page = 1, limit = 10, organizationId, isActive } = req.query;
    
    const filters = {};
    if (organizationId) filters.organizationId = organizationId;
    if (isActive !== undefined) filters.isActive = isActive === 'true';

    const { questions, total } = await questionsService.getAll(
      req.user.userId,
      filters,
      parseInt(page, 10),
      parseInt(limit, 10)
    );

    ApiResponse.paginated(
      res,
      questions,
      page,
      limit,
      total,
      'Questions retrieved successfully'
    );
  });

  getById = asyncHandler(async (req, res) => {
    const question = await questionsService.getById(
      req.params.id,
      req.user.userId
    );
    ApiResponse.success(res, 200, 'Question retrieved successfully', { question });
  });

  update = asyncHandler(async (req, res) => {
    const question = await questionsService.update(
      req.params.id,
      req.user.userId,
      req.body
    );
    ApiResponse.success(res, 200, 'Question updated successfully', { question });
  });

  delete = asyncHandler(async (req, res) => {
    await questionsService.delete(req.params.id, req.user.userId);
    ApiResponse.success(res, 200, 'Question deleted successfully');
  });
}

export default new QuestionsController();
</file>

<file path="backend/src/modules/questions/questions.routes.js">
import { Router } from 'express';
import questionsController from './questions.controller.js';
import { validate } from '../../middleware/validate.js';
import { authRequired } from '../../middleware/auth.js';
import { createQuestionSchema, updateQuestionSchema } from './questions.validation.js';

const router = Router();

router.use(authRequired);

router.post('/', validate(createQuestionSchema), questionsController.create);
router.get('/', questionsController.getAll);
router.get('/:id', questionsController.getById);
router.put('/:id', validate(updateQuestionSchema), questionsController.update);
router.delete('/:id', questionsController.delete);

export default router;
</file>

<file path="backend/src/modules/questions/questions.service.js">
// ============================================
// FILE: backend/src/modules/questions/questions.service.js (ENHANCED)
// Question management for surveys
// ============================================
import { v4 as uuidv4 } from 'uuid';
import db from '../../config/db.js';
import { ApiError } from '../../utils/ApiError.js';

class QuestionsService {
  /**
   * Validate question data
   */
  validateQuestion(data) {
    const validTypes = ['multiple_choice', 'text', 'rating', 'yes_no'];
    
    if (!validTypes.includes(data.questionType)) {
      throw ApiError.badRequest(`Invalid question type. Must be one of: ${validTypes.join(', ')}`);
    }

    if (data.questionType === 'multiple_choice' && (!data.options || data.options.length < 2)) {
      throw ApiError.badRequest('Multiple choice questions must have at least 2 options');
    }

    return true;
  }

  /**
   * Create a question (with survey context)
   */
  async create(userId, data) {
    this.validateQuestion(data);

    const orgCheck = await db.query(
      'SELECT id FROM organizations WHERE id = $1 AND owner_id = $2',
      [data.organizationId, userId]
    );

    if (orgCheck.rows.length === 0) {
      throw ApiError.forbidden('Organization not found or access denied');
    }

    const result = await db.query(
      `INSERT INTO questions (
        id, survey_id, organization_id, key, type, label, meta,
        position, required, created_at
      )
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW())
       RETURNING *`,
      [
        uuidv4(),
        data.surveyId || null,
        data.organizationId,
        data.key || `q_${Date.now()}`,
        data.questionType,
        data.questionText,
        JSON.stringify({
          options: data.options || [],
          validation: data.validation || {},
          conditional: data.conditional || null,
        }),
        data.position || 0,
        data.required !== false,
      ]
    );

    const question = result.rows[0];
    return this.formatQuestion(question);
  }

  /**
   * Bulk create questions for a survey
   */
  async bulkCreate(userId, organizationId, questions) {
    const orgCheck = await db.query(
      'SELECT id FROM organizations WHERE id = $1 AND owner_id = $2',
      [organizationId, userId]
    );

    if (orgCheck.rows.length === 0) {
      throw ApiError.forbidden('Organization not found or access denied');
    }

    const results = [];
    
    for (let i = 0; i < questions.length; i++) {
      const q = questions[i];
      this.validateQuestion(q);

      const result = await db.query(
        `INSERT INTO questions (
          id, organization_id, key, type, label, meta, position, required, created_at
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())
        RETURNING *`,
        [
          uuidv4(),
          organizationId,
          q.key || `q_${Date.now()}_${i}`,
          q.questionType,
          q.questionText,
          JSON.stringify({
            options: q.options || [],
            validation: q.validation || {},
            conditional: q.conditional || null,
          }),
          q.position !== undefined ? q.position : i,
          q.required !== false,
        ]
      );

      results.push(this.formatQuestion(result.rows[0]));
    }

    return results;
  }

  /**
   * Update question
   */
  async update(questionId, userId, updates) {
    await this.getById(questionId, userId);

    if (updates.questionType) {
      this.validateQuestion(updates);
    }

    const setClauses = [];
    const params = [];
    let paramIndex = 1;

    if (updates.questionText) {
      setClauses.push(`label = $${paramIndex}`);
      params.push(updates.questionText);
      paramIndex++;
    }

    if (updates.questionType) {
      setClauses.push(`type = $${paramIndex}`);
      params.push(updates.questionType);
      paramIndex++;
    }

    if (updates.options !== undefined) {
      // Get existing meta and update options
      const existing = await db.query('SELECT meta FROM questions WHERE id = $1', [questionId]);
      const meta = existing.rows[0]?.meta || {};
      meta.options = updates.options;
      
      setClauses.push(`meta = $${paramIndex}`);
      params.push(JSON.stringify(meta));
      paramIndex++;
    }

    if (updates.position !== undefined) {
      setClauses.push(`position = $${paramIndex}`);
      params.push(updates.position);
      paramIndex++;
    }

    if (updates.required !== undefined) {
      setClauses.push(`required = $${paramIndex}`);
      params.push(updates.required);
      paramIndex++;
    }

    if (setClauses.length === 0) {
      throw ApiError.badRequest('No valid fields to update');
    }

    params.push(questionId);

    const result = await db.query(
      `UPDATE questions 
       SET ${setClauses.join(', ')}
       WHERE id = $${paramIndex}
       RETURNING *`,
      params
    );

    return this.formatQuestion(result.rows[0]);
  }

  /**
   * Reorder questions
   */
  async reorder(userId, organizationId, questionIds) {
    // Verify ownership
    const orgCheck = await db.query(
      'SELECT id FROM organizations WHERE id = $1 AND owner_id = $2',
      [organizationId, userId]
    );

    if (orgCheck.rows.length === 0) {
      throw ApiError.forbidden('Organization not found or access denied');
    }

    // Update positions
    await db.transaction(async (client) => {
      for (let i = 0; i < questionIds.length; i++) {
        await client.query(
          'UPDATE questions SET position = $1 WHERE id = $2 AND organization_id = $3',
          [i, questionIds[i], organizationId]
        );
      }
    });

    return { message: 'Questions reordered successfully' };
  }

  /**
   * Get all questions for a survey
   */
  async getAll(userId, filters = {}, page = 1, limit = 10) {
    const offset = (page - 1) * limit;
    let whereClause = 'WHERE o.owner_id = $1';
    const params = [userId];
    let paramIndex = 2;

    if (filters.organizationId) {
      whereClause += ` AND q.organization_id = $${paramIndex}`;
      params.push(filters.organizationId);
      paramIndex++;
    }

    if (filters.surveyId) {
      whereClause += ` AND q.survey_id = $${paramIndex}`;
      params.push(filters.surveyId);
      paramIndex++;
    }

    if (filters.type) {
      whereClause += ` AND q.type = $${paramIndex}`;
      params.push(filters.type);
      paramIndex++;
    }

    const countResult = await db.query(
      `SELECT COUNT(*) FROM questions q
       JOIN organizations o ON q.organization_id = o.id
       ${whereClause}`,
      params
    );

    params.push(limit, offset);

    const result = await db.query(
      `SELECT q.*, o.name as organization_name
       FROM questions q
       JOIN organizations o ON q.organization_id = o.id
       ${whereClause}
       ORDER BY q.position ASC, q.created_at ASC
       LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`,
      params
    );

    return {
      questions: result.rows.map(q => this.formatQuestion(q)),
      total: parseInt(countResult.rows[0].count, 10),
    };
  }

  /**
   * Get question by ID
   */
  async getById(questionId, userId) {
    const result = await db.query(
      `SELECT q.*, o.name as organization_name
       FROM questions q
       JOIN organizations o ON q.organization_id = o.id
       WHERE q.id = $1 AND o.owner_id = $2`,
      [questionId, userId]
    );

    if (result.rows.length === 0) {
      throw ApiError.notFound('Question not found');
    }

    return this.formatQuestion(result.rows[0]);
  }

  /**
   * Delete question
   */
  async delete(questionId, userId) {
    await this.getById(questionId, userId);
    await db.query('DELETE FROM questions WHERE id = $1', [questionId]);
  }

  /**
   * Format question for API response
   */
  formatQuestion(row) {
    const meta = row.meta || {};
    return {
      id: row.id,
      surveyId: row.survey_id,
      organizationId: row.organization_id,
      organizationName: row.organization_name,
      key: row.key,
      questionText: row.label,
      questionType: row.type,
      options: meta.options || [],
      validation: meta.validation || {},
      conditional: meta.conditional || null,
      position: row.position,
      required: row.required,
      createdAt: row.created_at,
    };
  }
}

export default new QuestionsService();
</file>

<file path="backend/src/modules/questions/questions.validation.js">
// ============================================
// questions.validation.js
// ============================================
import Joi from 'joi';

export const createQuestionSchema = Joi.object({
  organizationId: Joi.string().uuid().required(),
  questionText: Joi.string().min(5).max(500).required(),
  questionType: Joi.string().valid('multiple_choice', 'text', 'rating').required(),
  options: Joi.array().items(Joi.string()).optional(),
  isActive: Joi.boolean().optional(),
});

export const updateQuestionSchema = Joi.object({
  questionText: Joi.string().min(5).max(500).optional(),
  questionType: Joi.string().valid('multiple_choice', 'text', 'rating').optional(),
  options: Joi.array().items(Joi.string()).optional(),
  isActive: Joi.boolean().optional(),
});
</file>

<file path="backend/src/modules/surveys/snapshots.service.js">
// ============================================
// FILE: backend/src/modules/surveys/snapshots.service.js
// Handles survey snapshot creation and retrieval
// ============================================
import { v4 as uuidv4 } from 'uuid';
import db from '../../config/db.js';
import { ApiError } from '../../utils/ApiError.js';
import { logger } from '../../lib/logger.js';

class SnapshotsService {
  /**
   * Create a snapshot of the current survey state
   */
  async createSnapshot(surveyId, userId) {
    try {
      // Get full survey with questions
      const surveyResult = await db.query(
        `SELECT s.*, t.name as tenant_name
         FROM surveys s
         JOIN tenants t ON s.tenant_id = t.id
         WHERE s.id = $1`,
        [surveyId]
      );

      if (surveyResult.rows.length === 0) {
        throw ApiError.notFound('Survey not found');
      }

      const survey = surveyResult.rows[0];

      // Get all questions for this survey's organization
      const questionsResult = await db.query(
        `SELECT id, question_text, question_type, options, required, position
         FROM questions
         WHERE organization_id = $1 AND is_active = true
         ORDER BY position ASC, created_at ASC`,
        [survey.organization_id]
      );

      // Build snapshot data
      const snapshotData = {
        surveyId: survey.id,
        title: survey.title,
        description: survey.description,
        surveyType: survey.survey_type,
        config: survey.config,
        questions: questionsResult.rows.map(q => ({
          id: q.id,
          text: q.question_text,
          type: q.question_type,
          options: typeof q.options === 'string' ? JSON.parse(q.options) : q.options,
          required: q.required || false,
          position: q.position,
        })),
        snapshotVersion: '1.0',
        createdAt: new Date().toISOString(),
      };

      // Store snapshot
      const result = await db.query(
        `INSERT INTO survey_snapshots (
          id, survey_id, snapshot, created_at, created_by
        ) VALUES ($1, $2, $3, NOW(), $4)
        RETURNING id, created_at`,
        [uuidv4(), surveyId, JSON.stringify(snapshotData), userId]
      );

      logger.info('Survey snapshot created', {
        surveyId,
        snapshotId: result.rows[0].id,
        questionsCount: snapshotData.questions.length,
      });

      return {
        id: result.rows[0].id,
        surveyId,
        snapshot: snapshotData,
        createdAt: result.rows[0].created_at,
      };
    } catch (error) {
      logger.error('Failed to create snapshot', {
        error: error.message,
        surveyId,
      });
      throw error;
    }
  }

  /**
   * Get the latest snapshot for a survey
   */
  async getLatestSnapshot(surveyId) {
    const result = await db.query(
      `SELECT id, survey_id, snapshot, created_at, created_by
       FROM survey_snapshots
       WHERE survey_id = $1
       ORDER BY created_at DESC
       LIMIT 1`,
      [surveyId]
    );

    if (result.rows.length === 0) {
      return null;
    }

    const row = result.rows[0];
    return {
      id: row.id,
      surveyId: row.survey_id,
      snapshot: row.snapshot,
      createdAt: row.created_at,
      createdBy: row.created_by,
    };
  }

  /**
   * Get a specific snapshot by ID
   */
  async getSnapshotById(snapshotId) {
    const result = await db.query(
      `SELECT id, survey_id, snapshot, created_at, created_by
       FROM survey_snapshots
       WHERE id = $1`,
      [snapshotId]
    );

    if (result.rows.length === 0) {
      throw ApiError.notFound('Snapshot not found');
    }

    const row = result.rows[0];
    return {
      id: row.id,
      surveyId: row.survey_id,
      snapshot: row.snapshot,
      createdAt: row.created_at,
      createdBy: row.created_by,
    };
  }

  /**
   * Get all snapshots for a survey (history)
   */
  async getSnapshotHistory(surveyId, limit = 10) {
    const result = await db.query(
      `SELECT id, survey_id, created_at, created_by
       FROM survey_snapshots
       WHERE survey_id = $1
       ORDER BY created_at DESC
       LIMIT $2`,
      [surveyId, limit]
    );

    return result.rows;
  }

  /**
   * Delete old snapshots (keep only N most recent)
   */
  async cleanupOldSnapshots(surveyId, keepCount = 5) {
    await db.query(
      `DELETE FROM survey_snapshots
       WHERE survey_id = $1
       AND id NOT IN (
         SELECT id FROM survey_snapshots
         WHERE survey_id = $1
         ORDER BY created_at DESC
         LIMIT $2
       )`,
      [surveyId, keepCount]
    );

    logger.info('Cleaned up old snapshots', { surveyId, keepCount });
  }
}

export default new SnapshotsService();
</file>

<file path="backend/src/modules/surveys/surveys.controller.js">
// ============================================
// FILE: backend/src/modules/surveys/surveys.controller.js
// ============================================
import { asyncHandler } from '../../utils/asyncHandler.js';
import surveysService from './surveys.service.js';
import { ApiResponse } from '../../utils/ApiResponse.js';

class SurveysController {
  createSurvey = asyncHandler(async (req, res) => {
    const survey = await surveysService.create(req.user.userId, req.body);
    ApiResponse.created(res, 'Survey created successfully', { survey });
  });

  getAllSurveys = asyncHandler(async (req, res) => {
    const { page = 1, limit = 10, tenantId, status } = req.query;
    const filters = { tenantId, status };
    
    const { surveys, total } = await surveysService.getAll(
      req.user.userId,
      filters,
      parseInt(page, 10),
      parseInt(limit, 10)
    );
    
    ApiResponse.paginated(res, surveys, page, limit, total, 'Surveys retrieved successfully');
  });

  getSurveyById = asyncHandler(async (req, res) => {
    const survey = await surveysService.getById(req.params.id, req.user.userId);
    ApiResponse.success(res, 200, 'Survey retrieved successfully', { survey });
  });

  updateSurvey = asyncHandler(async (req, res) => {
    const survey = await surveysService.update(req.params.id, req.user.userId, req.body);
    ApiResponse.success(res, 200, 'Survey updated successfully', { survey });
  });

  deleteSurvey = asyncHandler(async (req, res) => {
    await surveysService.delete(req.params.id, req.user.userId);
    ApiResponse.success(res, 200, 'Survey deleted successfully');
  });

  publishSurvey = asyncHandler(async (req, res) => {
    const survey = await surveysService.publish(req.params.id, req.user.userId);
    ApiResponse.success(res, 200, 'Survey published successfully', { survey });
  });

  unpublishSurvey = asyncHandler(async (req, res) => {
    const survey = await surveysService.unpublish(req.params.id, req.user.userId);
    ApiResponse.success(res, 200, 'Survey unpublished successfully', { survey });
  });

  getSurveyResults = asyncHandler(async (req, res) => {
    const { startDate, endDate } = req.query;
    const results = await surveysService.getResults(
      req.params.id,
      req.user.userId,
      { startDate, endDate }
    );
    ApiResponse.success(res, 200, 'Survey results retrieved successfully', { results });
  });

  requestExport = asyncHandler(async (req, res) => {
    const exportJob = await surveysService.requestExport(req.params.id, req.user.userId, req.body);
    ApiResponse.created(res, 'Export requested successfully', { exportJob });
  });

  getEmbedCode = asyncHandler(async (req, res) => {
    const embedCode = await surveysService.getEmbedCode(req.params.id, req.user.userId);
    ApiResponse.success(res, 200, 'Embed code generated', { embedCode });
  });

  duplicateSurvey = asyncHandler(async (req, res) => {
    const survey = await surveysService.duplicate(req.params.id, req.user.userId, req.body);
    ApiResponse.created(res, 'Survey duplicated successfully', { survey });
  });

  getSurveyPreview = asyncHandler(async (req, res) => {
    const preview = await surveysService.getPreview(req.params.id, req.user.userId);
    ApiResponse.success(res, 200, 'Survey preview retrieved', { preview });
  });

  getSnapshotHistory = asyncHandler(async (req, res) => {
    const snapshots = await surveysService.getSnapshotHistory(req.params.id, req.user.userId);
    ApiResponse.success(res, 200, 'Snapshot history retrieved', { snapshots });
  });

  getSnapshot = asyncHandler(async (req, res) => {
    const snapshot = await surveysService.getSnapshot(req.params.id, req.params.snapshotId, req.user.userId);
    ApiResponse.success(res, 200, 'Snapshot retrieved', { snapshot });
  });
}

export default new SurveysController();
</file>

<file path="backend/src/modules/surveys/surveys.routes.js">
// ============================================
// FILE: backend/src/modules/surveys/surveys.routes.js (ENHANCED)
// Complete survey management routes
// ============================================
import { Router } from 'express';
import surveysController from './surveys.controller.js';
import { validate } from '../../middleware/validate.js';
import { authRequired } from '../../middleware/auth.js';
import {
  createSurveySchema,
  updateSurveySchema,
  reorderQuestionsSchema,
  duplicateSurveySchema,
  exportRequestSchema,
} from './surveys.validators.js';

const router = Router();

// All routes require authentication
router.use(authRequired);

// Basic CRUD
router.post('/', validate(createSurveySchema), surveysController.createSurvey);
router.get('/', surveysController.getAllSurveys);
router.get('/:id', surveysController.getSurveyById);
router.put('/:id', validate(updateSurveySchema), surveysController.updateSurvey);
router.delete('/:id', surveysController.deleteSurvey);

// Publish/Unpublish
router.post('/:id/publish', surveysController.publishSurvey);
router.post('/:id/unpublish', surveysController.unpublishSurvey);

// Duplicate
router.post('/:id/duplicate', validate(duplicateSurveySchema), surveysController.duplicateSurvey);

// Preview
router.get('/:id/preview', surveysController.getSurveyPreview);

// Results & Analytics
router.get('/:id/results', surveysController.getSurveyResults);

// Export
router.post('/:id/export', validate(exportRequestSchema), surveysController.requestExport);

// Embed code
router.get('/:id/embed', surveysController.getEmbedCode);

// Snapshot history
router.get('/:id/snapshots', surveysController.getSnapshotHistory);
router.get('/:id/snapshots/:snapshotId', surveysController.getSnapshot);

export default router;
</file>

<file path="backend/src/modules/surveys/surveys.service.js">
// ============================================
// FILE: backend/src/modules/surveys/surveys.service.js (ENHANCED)
// Add publish, unpublish, duplicate methods
// ============================================
import { v4 as uuidv4 } from 'uuid';
import db from '../../config/db.js';
import { ApiError } from '../../utils/ApiError.js';
import microSurveyClient from '../../services/microSurveyClient.js';
import questionsService from '../questions/questions.service.js';
import { logger } from '../../lib/logger.js';
import { config } from '../../config/index.js';

class SurveysService {
  async create(userId, { tenantId, organizationId, title, description, surveyType, questions }) {
    // Verify tenant access
    const tenantCheck = await db.query(
      'SELECT id, microsurvey_base_url FROM tenants WHERE id = $1 AND owner_id = $2',
      [tenantId, userId]
    );

    if (tenantCheck.rows.length === 0) {
      throw ApiError.forbidden('Tenant not found or access denied');
    }

    const tenant = tenantCheck.rows[0];

    try {
      // Create survey in Micro-Survey
      const microSurveyData = {
        title,
        description,
        type: surveyType,
        questions: questions || [],
      };

      const microSurveyResponse = await microSurveyClient.createSurvey(
        microSurveyData,
        config.microSurvey.apiKey
      );

      // Generate unique survey key
      const surveyKey = `survey_${Date.now()}_${uuidv4().substring(0, 8)}`;

      // Store in dashboard database
      const result = await db.query(
        `INSERT INTO surveys (
          id, tenant_id, organization_id, microsurvey_id, survey_key,
          title, description, survey_type, status, config, created_at, updated_at
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 'draft', $9, NOW(), NOW())
        RETURNING *`,
        [
          uuidv4(),
          tenantId,
          organizationId || null,
          microSurveyResponse.id || microSurveyResponse.surveyId,
          surveyKey,
          title,
          description,
          surveyType,
          JSON.stringify(microSurveyResponse),
        ]
      );

      // Create questions if provided
      if (questions && questions.length > 0 && organizationId) {
        await questionsService.bulkCreate(userId, organizationId, 
          questions.map((q, idx) => ({
            ...q,
            surveyId: result.rows[0].id,
            position: q.position !== undefined ? q.position : idx,
          }))
        );
      }

      logger.info('Survey created', {
        surveyId: result.rows[0].id,
        microsurveyId: result.rows[0].microsurvey_id,
        tenantId,
      });

      return result.rows[0];
    } catch (error) {
      logger.error('Failed to create survey in Micro-Survey', {
        error: error.message,
        tenantId,
      });
      throw new ApiError(`Failed to create survey: ${error.message}`, 500);
    }
  }

  async getAll(userId, filters = {}, page = 1, limit = 10) {
    const offset = (page - 1) * limit;
    let whereClause = 'WHERE t.owner_id = $1';
    const params = [userId];
    let paramIndex = 2;

    if (filters.tenantId) {
      whereClause += ` AND s.tenant_id = $${paramIndex}`;
      params.push(filters.tenantId);
      paramIndex++;
    }

    if (filters.status) {
      whereClause += ` AND s.status = $${paramIndex}`;
      params.push(filters.status);
      paramIndex++;
    }

    if (filters.search) {
      whereClause += ` AND (s.title ILIKE $${paramIndex} OR s.description ILIKE $${paramIndex})`;
      params.push(`%${filters.search}%`);
      paramIndex++;
    }

    const countResult = await db.query(
      `SELECT COUNT(*) FROM surveys s
       JOIN tenants t ON s.tenant_id = t.id
       ${whereClause}`,
      params
    );

    params.push(limit, offset);

    const result = await db.query(
      `SELECT s.*, t.name as tenant_name, o.name as organization_name,
        (SELECT COUNT(*) FROM questions WHERE survey_id = s.id) as question_count,
        (SELECT COUNT(*) FROM survey_responses WHERE survey_id = s.id) as response_count
       FROM surveys s
       JOIN tenants t ON s.tenant_id = t.id
       LEFT JOIN organizations o ON s.organization_id = o.id
       ${whereClause}
       ORDER BY s.created_at DESC
       LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`,
      params
    );

    return {
      surveys: result.rows,
      total: parseInt(countResult.rows[0].count, 10),
    };
  }

  async getById(surveyId, userId) {
    const result = await db.query(
      `SELECT s.*, t.name as tenant_name, o.name as organization_name,
        (SELECT COUNT(*) FROM questions WHERE survey_id = s.id) as question_count,
        (SELECT COUNT(*) FROM survey_responses WHERE survey_id = s.id) as response_count
       FROM surveys s
       JOIN tenants t ON s.tenant_id = t.id
       LEFT JOIN organizations o ON s.organization_id = o.id
       WHERE s.id = $1 AND t.owner_id = $2`,
      [surveyId, userId]
    );

    if (result.rows.length === 0) {
      throw ApiError.notFound('Survey not found');
    }

    return result.rows[0];
  }

  async update(surveyId, userId, updates) {
    const survey = await this.getById(surveyId, userId);

    // Don't allow updates to published surveys
    if (survey.status === 'published' && !updates.allowPublishedUpdate) {
      throw ApiError.badRequest('Cannot update published survey. Unpublish first or create a new version.');
    }

    // Update in Micro-Survey if needed
    if (updates.title || updates.description || updates.questions) {
      try {
        await microSurveyClient.updateSurvey(survey.microsurvey_id, updates);
      } catch (error) {
        logger.error('Failed to update survey in Micro-Survey', {
          error: error.message,
          surveyId,
        });
      }
    }

    // Update in dashboard
    const result = await db.query(
      `UPDATE surveys 
       SET 
         title = COALESCE($1, title),
         description = COALESCE($2, description),
         config = COALESCE($3, config),
         updated_at = NOW()
       WHERE id = $4
       RETURNING *`,
      [updates.title, updates.description, updates.config ? JSON.stringify(updates.config) : null, surveyId]
    );

    return result.rows[0];
  }

  async delete(surveyId, userId) {
    await this.getById(surveyId, userId);
    
    // Soft delete - set status to archived
    await db.query(
      `UPDATE surveys SET status = 'archived', archived_at = NOW() WHERE id = $1`,
      [surveyId]
    );
  }

  /**
   * Publish survey - create snapshot and update status
   */
  async publish(surveyId, userId, snapshotId) {
    const survey = await this.getById(surveyId, userId);

    if (survey.status === 'published') {
      throw ApiError.badRequest('Survey is already published');
    }

    try {
      // Update Micro-Survey status
      await microSurveyClient.updateSurvey(survey.microsurvey_id, {
        status: 'published',
      });

      // Update survey in dashboard
      const result = await db.query(
        `UPDATE surveys 
         SET status = 'published', 
             published_snapshot_id = $1,
             published_at = NOW(),
             updated_at = NOW()
         WHERE id = $2
         RETURNING *`,
        [snapshotId, surveyId]
      );

      logger.info('Survey published', { surveyId, snapshotId });

      return result.rows[0];
    } catch (error) {
      throw ApiError.internal(`Failed to publish survey: ${error.message}`);
    }
  }

  /**
   * Unpublish survey - revert to draft
   */
  async unpublish(surveyId, userId) {
    const survey = await this.getById(surveyId, userId);

    if (survey.status !== 'published') {
      throw ApiError.badRequest('Survey is not published');
    }

    try {
      // Update Micro-Survey status
      await microSurveyClient.updateSurvey(survey.microsurvey_id, {
        status: 'draft',
      });

      // Update survey in dashboard
      const result = await db.query(
        `UPDATE surveys 
         SET status = 'draft',
             updated_at = NOW()
         WHERE id = $1
         RETURNING *`,
        [surveyId]
      );

      logger.info('Survey unpublished', { surveyId });

      return result.rows[0];
    } catch (error) {
      throw ApiError.internal(`Failed to unpublish survey: ${error.message}`);
    }
  }

  /**
   * Duplicate survey
   */
  async duplicate(surveyId, userId, options = {}) {
    const original = await this.getById(surveyId, userId);
    const { newTitle, includeQuestions = true } = options;

    const title = newTitle || `Copy of ${original.title}`;

    // Create new survey
    const newSurveyData = {
      tenantId: original.tenant_id,
      organizationId: original.organization_id,
      title,
      description: original.description,
      surveyType: original.survey_type,
      questions: [],
    };

    // Get questions if including them
    if (includeQuestions && original.organization_id) {
      const questionsResult = await db.query(
        `SELECT * FROM questions WHERE survey_id = $1 ORDER BY position ASC`,
        [surveyId]
      );

      newSurveyData.questions = questionsResult.rows.map(q => ({
        questionText: q.label,
        questionType: q.type,
        options: q.meta?.options || [],
        required: q.required,
        position: q.position,
      }));
    }

    const duplicated = await this.create(userId, newSurveyData);

    logger.info('Survey duplicated', {
      originalId: surveyId,
      duplicatedId: duplicated.id,
      includeQuestions,
    });

    return duplicated;
  }

  /**
   * Get survey preview data
   */
  async getPreview(surveyId, userId) {
    const survey = await this.getById(surveyId, userId);

    // Get questions
    const questionsResult = await db.query(
      `SELECT * FROM questions WHERE survey_id = $1 ORDER BY position ASC`,
      [surveyId]
    );

    return {
      survey: {
        id: survey.id,
        title: survey.title,
        description: survey.description,
        type: survey.survey_type,
        config: survey.config,
      },
      questions: questionsResult.rows.map(q => ({
        id: q.id,
        key: q.key,
        text: q.label,
        type: q.type,
        options: q.meta?.options || [],
        required: q.required,
        position: q.position,
      })),
    };
  }

  async getResults(surveyId, userId, filters = {}) {
    const survey = await this.getById(surveyId, userId);

    // Check cache first
    const cacheResult = await db.query(
      `SELECT analytics_data FROM survey_analytics_cache
       WHERE survey_id = $1 AND expires_at > NOW()
       ORDER BY cached_at DESC LIMIT 1`,
      [surveyId]
    );

    if (cacheResult.rows.length > 0) {
      logger.debug('Returning cached analytics', { surveyId });
      return cacheResult.rows[0].analytics_data;
    }

    // Fetch from Micro-Survey
    try {
      const results = await microSurveyClient.getResults(survey.microsurvey_id, filters);

      // Cache for 5 minutes
      await db.query(
        `INSERT INTO survey_analytics_cache (
          id, survey_id, analytics_data, cached_at, expires_at
        )
        VALUES ($1, $2, $3, NOW(), NOW() + INTERVAL '5 minutes')`,
        [uuidv4(), surveyId, JSON.stringify(results)]
      );

      return results;
    } catch (error) {
      throw ApiError.internal(`Failed to fetch results: ${error.message}`);
    }
  }

  async requestExport(surveyId, userId, options) {
    const survey = await this.getById(surveyId, userId);

    try {
      const exportResponse = await microSurveyClient.requestExport(
        survey.microsurvey_id,
        options
      );

      // Create export job record
      const result = await db.query(
        `INSERT INTO export_jobs (
          id, survey_id, tenant_id, status, export_type,
          requested_by, created_at
        )
        VALUES ($1, $2, $3, 'pending', $4, $5, NOW())
        RETURNING *`,
        [uuidv4(), surveyId, survey.tenant_id, options.format || 'csv', userId]
      );

      return result.rows[0];
    } catch (error) {
      throw ApiError.internal(`Failed to request export: ${error.message}`);
    }
  }

  async getEmbedCode(surveyId, userId) {
    const survey = await this.getById(surveyId, userId);

    if (survey.status !== 'published') {
      throw ApiError.badRequest('Survey must be published to get embed code');
    }

    const baseUrl = process.env.FRONTEND_URL || 'http://localhost:5173';
    const apiUrl = process.env.API_URL || 'http://localhost:5000';
    const surveyKey = survey.survey_key;

    return {
      iframe: `<iframe src="${baseUrl}/embed/${surveyKey}" width="100%" height="600" frameborder="0"></iframe>`,
      script: `<div id="microsurvey-${surveyKey}"></div>
<script src="${apiUrl}/embed/widget.js" data-survey-key="${surveyKey}"></script>`,
      link: `${baseUrl}/s/${surveyKey}`,
      surveyKey,
    };
  }
}

export default new SurveysService();
</file>

<file path="backend/src/modules/surveys/surveys.validation.js">
// ============================================
// FILE: backend/src/modules/surveys/surveys.validation.js
// ============================================
import Joi from 'joi';

export const createSurveySchema = Joi.object({
  tenantId: Joi.string().uuid().required(),
  organizationId: Joi.string().uuid().optional(),
  title: Joi.string().min(3).max(500).required(),
  description: Joi.string().max(2000).optional(),
  surveyType: Joi.string().valid('poll', 'quiz', 'feedback', 'nps').required(),
  questions: Joi.array().items(Joi.object()).optional(),
});

export const updateSurveySchema = Joi.object({
  title: Joi.string().min(3).max(500).optional(),
  description: Joi.string().max(2000).optional(),
  questions: Joi.array().items(Joi.object()).optional(),
});
</file>

<file path="backend/src/modules/surveys/surveys.validators.js">
// ============================================
// FILE: backend/src/modules/surveys/surveys.validators.js
// Validation schemas for survey operations
// ============================================
import Joi from 'joi';

const questionSchema = Joi.object({
  key: Joi.string().optional(),
  questionText: Joi.string().min(5).max(500).required(),
  questionType: Joi.string().valid('multiple_choice', 'text', 'rating', 'yes_no').required(),
  options: Joi.array().items(
    Joi.alternatives().try(
      Joi.string(),
      Joi.object({
        text: Joi.string().required(),
        imageUrl: Joi.string().uri().allow('').optional(),
      })
    )
  ).when('questionType', {
    is: 'multiple_choice',
    then: Joi.array().min(2).required(),
    otherwise: Joi.array().optional(),
  }),
  required: Joi.boolean().default(false),
  position: Joi.number().integer().min(0).optional(),
  validation: Joi.object().optional(),
  conditional: Joi.object().optional(),
});

export const createSurveySchema = Joi.object({
  tenantId: Joi.string().uuid().required(),
  organizationId: Joi.string().uuid().optional(),
  title: Joi.string().min(3).max(500).required(),
  description: Joi.string().max(2000).allow('').optional(),
  surveyType: Joi.string().valid('poll', 'quiz', 'feedback', 'nps').required(),
  questions: Joi.array().items(questionSchema).min(1).optional(),
  config: Joi.object({
    theme: Joi.string().valid('light', 'dark', 'auto').optional(),
    showProgressBar: Joi.boolean().optional(),
    allowBack: Joi.boolean().optional(),
    shuffleQuestions: Joi.boolean().optional(),
    requireAll: Joi.boolean().optional(),
  }).optional(),
});

export const updateSurveySchema = Joi.object({
  title: Joi.string().min(3).max(500).optional(),
  description: Joi.string().max(2000).allow('').optional(),
  questions: Joi.array().items(questionSchema).min(1).optional(),
  config: Joi.object({
    theme: Joi.string().valid('light', 'dark', 'auto').optional(),
    showProgressBar: Joi.boolean().optional(),
    allowBack: Joi.boolean().optional(),
    shuffleQuestions: Joi.boolean().optional(),
    requireAll: Joi.boolean().optional(),
  }).optional(),
});

export const reorderQuestionsSchema = Joi.object({
  questionIds: Joi.array().items(Joi.string().uuid()).min(1).required(),
});

export const duplicateSurveySchema = Joi.object({
  newTitle: Joi.string().min(3).max(500).optional(),
  includeQuestions: Joi.boolean().default(true),
});

export const exportRequestSchema = Joi.object({
  format: Joi.string().valid('csv', 'json', 'xlsx').default('csv'),
  dateRange: Joi.object({
    startDate: Joi.date().iso().optional(),
    endDate: Joi.date().iso().optional(),
  }).optional(),
  includeMetadata: Joi.boolean().default(true),
});
</file>

<file path="backend/src/modules/tenants/tenants.controller.js">
// ============================================
// FILE: backend/src/modules/tenants/tenants.controller.js
// ============================================
import { asyncHandler } from '../../utils/asyncHandler.js';
import tenantsService from './tenants.service.js';
import apiKeyService from '../../services/apiKeyService.js';
import { ApiResponse } from '../../utils/ApiResponse.js';

class TenantsController {
  createTenant = asyncHandler(async (req, res) => {
    const tenant = await tenantsService.create(req.user.userId, req.body);
    ApiResponse.created(res, 'Tenant created successfully', { tenant });
  });

  getAllTenants = asyncHandler(async (req, res) => {
    const { page = 1, limit = 10 } = req.query;
    const { tenants, total } = await tenantsService.getAll(
      req.user.userId,
      parseInt(page, 10),
      parseInt(limit, 10)
    );
    ApiResponse.paginated(res, tenants, page, limit, total, 'Tenants retrieved successfully');
  });

  getTenantById = asyncHandler(async (req, res) => {
    const tenant = await tenantsService.getById(req.params.id, req.user.userId);
    ApiResponse.success(res, 200, 'Tenant retrieved successfully', { tenant });
  });

  updateTenant = asyncHandler(async (req, res) => {
    const tenant = await tenantsService.update(req.params.id, req.user.userId, req.body);
    ApiResponse.success(res, 200, 'Tenant updated successfully', { tenant });
  });

  deleteTenant = asyncHandler(async (req, res) => {
    await tenantsService.delete(req.params.id, req.user.userId);
    ApiResponse.success(res, 200, 'Tenant deleted successfully');
  });

  // API Key Management
  createApiKey = asyncHandler(async (req, res) => {
    const { name } = req.body;
    const apiKey = await apiKeyService.createApiKey(req.params.tenantId, name, req.user.userId);
    ApiResponse.created(res, 'API key created successfully', {
      apiKey,
      warning: 'Store this key securely. It will not be shown again.',
    });
  });

  listApiKeys = asyncHandler(async (req, res) => {
    const keys = await apiKeyService.listApiKeys(req.params.tenantId);
    ApiResponse.success(res, 200, 'API keys retrieved successfully', { keys });
  });

  revokeApiKey = asyncHandler(async (req, res) => {
    const result = await apiKeyService.revokeApiKey(
      req.params.tenantId,
      req.params.keyId,
      req.user.userId
    );
    ApiResponse.success(res, 200, 'API key revoked successfully', result);
  });

  getApiKeyStats = asyncHandler(async (req, res) => {
    const stats = await apiKeyService.getApiKeyStats(req.params.tenantId);
    ApiResponse.success(res, 200, 'API key statistics retrieved', { stats });
  });
}

export default new TenantsController();
</file>

<file path="backend/src/modules/tenants/tenants.routes.js">
// ============================================
// FILE: backend/src/modules/tenants/tenants.routes.js
// ============================================
import { Router } from 'express';
import tenantsController from './tenants.controller.js';
import { validate } from '../../middleware/validate.js';
import { authRequired } from '../../middleware/auth.js';
import { apiKeyRateLimiter } from '../../middleware/rateLimit.middleware.js';
import { createTenantSchema, updateTenantSchema, createApiKeySchema } from './tenants.validation.js';

const router = Router();

router.use(authRequired);

// Tenant CRUD
router.post('/', validate(createTenantSchema), tenantsController.createTenant);
router.get('/', tenantsController.getAllTenants);
router.get('/:id', tenantsController.getTenantById);
router.put('/:id', validate(updateTenantSchema), tenantsController.updateTenant);
router.delete('/:id', tenantsController.deleteTenant);

// API Key Management
router.post('/:tenantId/keys', apiKeyRateLimiter, validate(createApiKeySchema), tenantsController.createApiKey);
router.get('/:tenantId/keys', tenantsController.listApiKeys);
router.delete('/:tenantId/keys/:keyId', tenantsController.revokeApiKey);
router.get('/:tenantId/keys/stats', tenantsController.getApiKeyStats);

export default router;
</file>

<file path="backend/src/modules/tenants/tenants.service.js">
// ============================================
// FILE: backend/src/modules/tenants/tenants.service.js
// ============================================
import { v4 as uuidv4 } from 'uuid';
import db from '../../config/db.js';
import { ApiError } from '../../utils/ApiError.js';

class TenantsService {
  async create(userId, { name, slug, email, microsurveyBaseUrl }) {
    const tenantSlug = slug || name.toLowerCase().replace(/[^a-z0-9-]/g, '-');

    const existing = await db.query(
      'SELECT id FROM tenants WHERE slug = $1',
      [tenantSlug]
    );

    if (existing.rows.length > 0) {
      throw new ApiError('Tenant slug already exists', 409);
    }

    const result = await db.query(
      `INSERT INTO tenants (
        id, name, slug, email, owner_id, microsurvey_base_url, 
        is_active, created_at, updated_at
      )
      VALUES ($1, $2, $3, $4, $5, $6, true, NOW(), NOW())
      RETURNING *`,
      [uuidv4(), name, tenantSlug, email, userId, microsurveyBaseUrl || null]
    );

    return result.rows[0];
  }

  async getAll(userId, page = 1, limit = 10) {
    const offset = (page - 1) * limit;

    const countResult = await db.query(
      'SELECT COUNT(*) FROM tenants WHERE owner_id = $1',
      [userId]
    );

    const result = await db.query(
      `SELECT * FROM tenants 
       WHERE owner_id = $1 
       ORDER BY created_at DESC
       LIMIT $2 OFFSET $3`,
      [userId, limit, offset]
    );

    return {
      tenants: result.rows,
      total: parseInt(countResult.rows[0].count, 10),
    };
  }

  async getById(tenantId, userId) {
    const result = await db.query(
      'SELECT * FROM tenants WHERE id = $1 AND owner_id = $2',
      [tenantId, userId]
    );

    if (result.rows.length === 0) {
      throw new ApiError('Tenant not found', 404);
    }

    return result.rows[0];
  }

  async update(tenantId, userId, updates) {
    await this.getById(tenantId, userId);

    const result = await db.query(
      `UPDATE tenants 
       SET 
         name = COALESCE($1, name),
         email = COALESCE($2, email),
         microsurvey_base_url = COALESCE($3, microsurvey_base_url),
         is_active = COALESCE($4, is_active),
         updated_at = NOW()
       WHERE id = $5 AND owner_id = $6
       RETURNING *`,
      [updates.name, updates.email, updates.microsurveyBaseUrl, updates.isActive, tenantId, userId]
    );

    return result.rows[0];
  }

  async delete(tenantId, userId) {
    await this.getById(tenantId, userId);
    await db.query('DELETE FROM tenants WHERE id = $1', [tenantId]);
  }
}

export default new TenantsService();
</file>

<file path="backend/src/modules/tenants/tenants.validation.js">
// ============================================
// FILE: backend/src/modules/tenants/tenants.validation.js
// ============================================
import Joi from 'joi';

export const createTenantSchema = Joi.object({
  name: Joi.string().min(2).max(255).required(),
  slug: Joi.string().pattern(/^[a-z0-9-]+$/).min(2).max(100).optional(),
  email: Joi.string().email().required(),
  microsurveyBaseUrl: Joi.string().uri().optional(),
});

export const updateTenantSchema = Joi.object({
  name: Joi.string().min(2).max(255).optional(),
  email: Joi.string().email().optional(),
  microsurveyBaseUrl: Joi.string().uri().allow(null).optional(),
  isActive: Joi.boolean().optional(),
});

export const createApiKeySchema = Joi.object({
  name: Joi.string().min(2).max(100).required(),
});
</file>

<file path="backend/src/modules/webhooks/webhooks.controller.js">
import { asyncHandler } from '../../utils/asyncHandler.js';
import webhooksService from './webhooks.service.js';
import { ApiResponse } from '../../utils/ApiResponse.js';

class WebhooksController {
  receiveMicroSurveyWebhook = asyncHandler(async (req, res) => {
    const signature = req.headers['x-microsurvey-signature'];
    const result = await webhooksService.process(req.body, signature);
    ApiResponse.success(res, 200, 'Webhook processed', result);
  });
}

export default new WebhooksController();
</file>

<file path="backend/src/modules/webhooks/webhooks.routes.js">
// ============================================
// FILE: backend/src/modules/webhooks/webhooks.routes.js (COMPLETE)
// ============================================
import { Router } from 'express';
import webhooksController from './webhooks.controller.js';
import { webhookRateLimiter } from '../../middleware/rateLimit.middleware.js';

const router = Router();

// Webhook endpoint for Micro-Survey callbacks
router.post('/microsurvey', webhookRateLimiter, webhooksController.receiveMicroSurveyWebhook);

// Health check for webhook endpoint
router.get('/health', (req, res) => {
  res.json({ success: true, status: 'healthy' });
});

export default router;
</file>

<file path="backend/src/modules/webhooks/webhooks.service.js">
import crypto from 'crypto';
import { v4 as uuidv4 } from 'uuid';
import db from '../../config/db.js';
import { config } from '../../config/index.js';
import { logger } from '../../lib/logger.js';
import { ApiError } from '../../utils/ApiError.js';

class WebhooksService {
  verifySignature(payload, signature) {
    if (!config.features.enableWebhooks) return true;
    
    const secret = config.microSurvey.webhookSecret || config.microSurvey.apiKey;
    const computed = crypto
      .createHmac('sha256', secret)
      .update(JSON.stringify(payload))
      .digest('hex');
    
    return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(computed));
  }

  async process(payload, signature) {
    const verified = this.verifySignature(payload, signature);
    
    // Log webhook
    await db.query(
      `INSERT INTO webhook_logs (
        id, webhook_type, payload, signature, verified, created_at
      ) VALUES ($1, $2, $3, $4, $5, NOW())`,
      [uuidv4(), payload.type, JSON.stringify(payload), signature, verified]
    );

    if (!verified) {
      throw new ApiError('Invalid webhook signature', 401);
    }

    // Process based on type
    switch (payload.type) {
      case 'export.completed':
        await this.handleExportCompleted(payload);
        break;
      case 'response.received':
        await this.handleResponseReceived(payload);
        break;
      default:
        logger.warn('Unknown webhook type', { type: payload.type });
    }

    return { processed: true };
  }

  async handleExportCompleted(payload) {
    const { surveyId, exportUrl } = payload.data;
    
    await db.query(
      `UPDATE export_jobs 
       SET status = 'completed', file_url = $1, completed_at = NOW()
       WHERE survey_id = (SELECT id FROM surveys WHERE microsurvey_id = $2)
       AND status = 'pending'`,
      [exportUrl, surveyId]
    );

    logger.info('Export completed', { surveyId, exportUrl });
  }

  async handleResponseReceived(payload) {
    // Invalidate analytics cache for this survey
    const { surveyId } = payload.data;
    
    await db.query(
      `DELETE FROM survey_analytics_cache
       WHERE survey_id = (SELECT id FROM surveys WHERE microsurvey_id = $1)`,
      [surveyId]
    );

    logger.info('Analytics cache invalidated', { surveyId });
  }
}

export default new WebhooksService();
</file>

<file path="backend/src/routes/index.js">
// ============================================
// FILE: backend/src/routes/index.js (UPDATED)
// Add embed routes for widget
// ============================================
import { Router } from "express";
import authRoutes from "../modules/auth/auth.routes.js";
import organizationsRoutes from "../modules/organizations/organizations.routes.js";
import questionsRoutes from "../modules/questions/questions.routes.js";
import analyticsRoutes from "../modules/analytics/analytics.routes.js";
import integrationRoutes from "../modules/integration/integration.routes.js";
import tenantsRoutes from "../modules/tenants/tenants.routes.js";
import surveysRoutes from "../modules/surveys/surveys.routes.js";
import webhooksRoutes from "../modules/webhooks/webhooks.routes.js";
import embedRoutes from "../modules/embed/embed.routes.js";

const router = Router();

router.get("/", (req, res) => {
  res.json({
    success: true,
    message: "Survey CAPTCHA Dashboard API",
    version: "2.0.0",
    endpoints: {
      auth: "/api/auth",
      tenants: "/api/tenants",
      surveys: "/api/surveys",
      organizations: "/api/organizations",
      questions: "/api/questions",
      analytics: "/api/analytics",
      integration: "/api/integration",
      webhooks: "/api/webhooks",
      embed: "/api/embed (PUBLIC)",
    },
  });
});

// Protected routes (require authentication)
router.use("/auth", authRoutes);
router.use("/organizations", organizationsRoutes);
router.use("/questions", questionsRoutes);
router.use("/analytics", analyticsRoutes);
router.use("/integration", integrationRoutes);
router.use("/tenants", tenantsRoutes);
router.use("/surveys", surveysRoutes);
router.use("/webhooks", webhooksRoutes);

// Public routes (no auth required)
router.use("/embed", embedRoutes);

router.get("/health", (req, res) => {
  res.json({ 
    success: true, 
    status: "healthy",
    timestamp: new Date().toISOString(),
  });
});

export default router;
</file>

<file path="backend/src/services/apiKeyService.js">
// ============================================
// API Key Management Service
// ============================================
import crypto from 'crypto';
import { v4 as uuidv4 } from 'uuid';
import db from '../config/db.js';
import { config } from '../config/index.js';
import { ApiError } from '../utils/ApiError.js';
import { logger } from '../lib/logger.js';

class ApiKeyService {
  /**
   * Generate a secure API key
   */
  generateApiKey() {
    return `msk_${crypto.randomBytes(32).toString('hex')}`;
  }

  /**
   * Hash API key with pepper
   */
  hashApiKey(key) {
    return crypto
      .createHmac('sha256', config.security.apiKeyPepper)
      .update(key)
      .digest('hex');
  }

  /**
   * Get key prefix for identification
   */
  getKeyPrefix(key) {
    return key.substring(0, 12); // "msk_" + 8 chars
  }

  /**
   * Create new API key for tenant
   */
  async createApiKey(tenantId, name, userId) {
    // Verify tenant exists
    const tenantCheck = await db.query(
      'SELECT id FROM tenants WHERE id = $1 AND is_active = true',
      [tenantId]
    );

    if (tenantCheck.rows.length === 0) {
      throw new ApiError('Tenant not found or inactive', 404);
    }

    // Generate key
    const apiKey = this.generateApiKey();
    const keyHash = this.hashApiKey(apiKey);
    const keyPrefix = this.getKeyPrefix(apiKey);

    // Store in database
    const result = await db.query(
      `INSERT INTO tenant_api_keys (
        id, tenant_id, name, key_hash, key_prefix, created_by, created_at
      )
      VALUES ($1, $2, $3, $4, $5, $6, NOW())
      RETURNING id, tenant_id, name, key_prefix, created_at`,
      [uuidv4(), tenantId, name, keyHash, keyPrefix, userId]
    );

    logger.info('API key created', {
      tenantId,
      keyPrefix,
      name,
      userId,
    });

    return {
      ...result.rows[0],
      key: apiKey, // Return raw key only once
    };
  }

  /**
   * List API keys for tenant (no raw keys)
   */
  async listApiKeys(tenantId) {
    const result = await db.query(
      `SELECT 
        id, tenant_id, name, key_prefix, last_used_at,
        revoked_at, created_at, created_by
      FROM tenant_api_keys
      WHERE tenant_id = $1
      ORDER BY created_at DESC`,
      [tenantId]
    );

    return result.rows.map(key => ({
      ...key,
      is_active: !key.revoked_at,
    }));
  }

  /**
   * Revoke API key
   */
  async revokeApiKey(tenantId, keyId, userId) {
    const result = await db.query(
      `UPDATE tenant_api_keys
      SET revoked_at = NOW()
      WHERE id = $1 AND tenant_id = $2 AND revoked_at IS NULL
      RETURNING id, name, key_prefix`,
      [keyId, tenantId]
    );

    if (result.rows.length === 0) {
      throw new ApiError('API key not found or already revoked', 404);
    }

    logger.info('API key revoked', {
      tenantId,
      keyId,
      keyPrefix: result.rows[0].key_prefix,
      userId,
    });

    return result.rows[0];
  }

  /**
   * Verify and get tenant from API key
   */
  async verifyApiKey(apiKey) {
    if (!apiKey || !apiKey.startsWith('msk_')) {
      throw new ApiError('Invalid API key format', 401);
    }

    const keyHash = this.hashApiKey(apiKey);
    const keyPrefix = this.getKeyPrefix(apiKey);

    const result = await db.query(
      `SELECT 
        k.id as key_id, 
        k.tenant_id, 
        k.name as key_name,
        t.name as tenant_name,
        t.slug as tenant_slug,
        t.is_active as tenant_active,
        k.revoked_at
      FROM tenant_api_keys k
      JOIN tenants t ON k.tenant_id = t.id
      WHERE k.key_hash = $1 AND k.key_prefix = $2`,
      [keyHash, keyPrefix]
    );

    if (result.rows.length === 0) {
      throw new ApiError('Invalid API key', 401);
    }

    const keyData = result.rows[0];

    if (keyData.revoked_at) {
      throw new ApiError('API key has been revoked', 401);
    }

    if (!keyData.tenant_active) {
      throw new ApiError('Tenant account is inactive', 403);
    }

    // Update last used timestamp (async, don't wait)
    db.query(
      'UPDATE tenant_api_keys SET last_used_at = NOW() WHERE id = $1',
      [keyData.key_id]
    ).catch(err => logger.error('Failed to update API key last_used_at', { error: err.message }));

    return {
      tenantId: keyData.tenant_id,
      tenantName: keyData.tenant_name,
      tenantSlug: keyData.tenant_slug,
      keyName: keyData.key_name,
    };
  }

  /**
   * Get API key statistics for tenant
   */
  async getApiKeyStats(tenantId) {
    const result = await db.query(
      `SELECT
        COUNT(*) as total,
        COUNT(*) FILTER (WHERE revoked_at IS NULL) as active,
        COUNT(*) FILTER (WHERE revoked_at IS NOT NULL) as revoked,
        MAX(last_used_at) as last_activity
      FROM tenant_api_keys
      WHERE tenant_id = $1`,
      [tenantId]
    );

    return result.rows[0];
  }
}

export default new ApiKeyService();
</file>

<file path="backend/src/services/imageService.js">
// ============================================
// FILE: backend/src/services/imageService.js
// Low-compute image processing with Sharp
// ============================================
import sharp from 'sharp';
import crypto from 'crypto';
import path from 'path';
import fs from 'fs/promises';
import { existsSync } from 'fs';
import { PassThrough } from 'stream';
import { config } from '../config/index.js';
import { logger } from '../lib/logger.js';
import { ApiError } from '../utils/ApiError.js';
import { uploadToS3, deleteFromS3 } from './s3Service.js';

class ImageService {
  constructor() {
    this.maxFileSize = parseInt(config.image.maxSize, 10);
    this.allowedMimeTypes = config.image.allowedTypes;
    this.quality = parseInt(config.image.quality, 10);
    this.maxWidth = parseInt(config.image.maxWidth, 10);
    this.maxHeight = parseInt(config.image.maxHeight, 10);
    this.thumbnailSize = parseInt(config.image.thumbnailSize, 10);
    this.storageType = config.image.storage;
    this.uploadDir = config.image.uploadDir;
    
    // Concurrency limiter
    this.processing = 0;
    this.maxConcurrent = parseInt(config.image.parallel, 10);
    this.queue = [];
  }

  /**
   * Validate file before processing
   */
  async validateFile(file) {
    // Size check
    if (file.size > this.maxFileSize) {
      throw ApiError.badRequest(
        `File too large. Maximum size is ${this.maxFileSize / 1024 / 1024}MB`
      );
    }

    // MIME type check
    if (!this.allowedMimeTypes.includes(file.mimetype)) {
      throw ApiError.badRequest(
        `Invalid file type. Allowed types: ${this.allowedMimeTypes.join(', ')}`
      );
    }

    // Magic bytes check (verify actual file type)
    const buffer = file.buffer.slice(0, 12);
    const signatures = {
      'image/jpeg': [[0xFF, 0xD8, 0xFF]],
      'image/png': [[0x89, 0x50, 0x4E, 0x47]],
      'image/webp': [[0x52, 0x49, 0x46, 0x46]], // RIFF
      'image/gif': [[0x47, 0x49, 0x46]],
    };

    const matchesSignature = signatures[file.mimetype]?.some(sig =>
      sig.every((byte, i) => buffer[i] === byte)
    );

    if (!matchesSignature) {
      throw ApiError.badRequest('File content does not match declared type');
    }

    return true;
  }

  /**
   * Sanitize filename to prevent directory traversal
   */
  sanitizeFilename(filename) {
    // Remove path separators and dangerous characters
    const sanitized = filename
      .replace(/[\/\\]/g, '')
      .replace(/['"<>|:*?]/g, '')
      .replace(/\.\./g, '')
      .trim();

    if (!sanitized || sanitized.length === 0) {
      return `file_${Date.now()}.webp`;
    }

    return sanitized;
  }

  /**
   * Generate unique filename
   */
  generateFilename(originalName, suffix = '') {
    const hash = crypto.randomBytes(16).toString('hex');
    const timestamp = Date.now();
    const ext = path.extname(originalName) || '.webp';
    const safe = this.sanitizeFilename(path.basename(originalName, ext));
    return `${safe}_${timestamp}_${hash}${suffix}${ext}`;
  }

  /**
   * Process image with streaming to minimize memory
   */
  async processImage(fileBuffer, options = {}) {
    const {
      maxWidth = this.maxWidth,
      maxHeight = this.maxHeight,
      quality = this.quality,
      generateThumbnail = true,
    } = options;

    try {
      // Create Sharp instance with streaming
      const image = sharp(fileBuffer, {
        failOnError: false,
        density: 72, // Reduce DPI for web
        limitInputPixels: 268402689, // ~16k x 16k limit
      });

      // Get metadata
      const metadata = await image.metadata();

      // Configure processing pipeline
      let pipeline = image
        .rotate() // Auto-rotate based on EXIF
        .resize(maxWidth, maxHeight, {
          fit: 'inside',
          withoutEnlargement: true,
        })
        .webp({
          quality,
          effort: 2, // Low CPU effort (0-6, where 0 is fastest)
          smartSubsample: true,
        })
        .withMetadata({
          // Strip most EXIF but keep orientation
          orientation: metadata.orientation,
        });

      // Process main image
      const processed = await pipeline.toBuffer({ resolveWithObject: true });

      let thumbnail = null;
      if (generateThumbnail) {
        thumbnail = await sharp(fileBuffer)
          .rotate()
          .resize(this.thumbnailSize, this.thumbnailSize, {
            fit: 'cover',
            position: 'center',
          })
          .webp({ quality: quality - 10, effort: 2 })
          .toBuffer({ resolveWithObject: true });
      }

      return {
        main: {
          buffer: processed.data,
          info: processed.info,
        },
        thumbnail: thumbnail ? {
          buffer: thumbnail.data,
          info: thumbnail.info,
        } : null,
        originalMetadata: {
          width: metadata.width,
          height: metadata.height,
          format: metadata.format,
          size: fileBuffer.length,
        },
      };
    } catch (error) {
      logger.error('Image processing error', { error: error.message });
      throw ApiError.badRequest('Failed to process image: ' + error.message);
    }
  }

  /**
   * Save to local storage
   */
  async saveLocal(buffer, filename) {
    const uploadPath = path.join(process.cwd(), this.uploadDir);
    
    // Ensure directory exists
    if (!existsSync(uploadPath)) {
      await fs.mkdir(uploadPath, { recursive: true });
    }

    const filePath = path.join(uploadPath, filename);
    await fs.writeFile(filePath, buffer);

    return `/${this.uploadDir}/${filename}`;
  }

  /**
   * Save to S3
   */
  async saveS3(buffer, filename, contentType = 'image/webp') {
    return await uploadToS3(buffer, filename, contentType);
  }

  /**
   * Acquire processing slot (concurrency control)
   */
  async acquireSlot() {
    while (this.processing >= this.maxConcurrent) {
      await new Promise(resolve => {
        this.queue.push(resolve);
      });
    }
    this.processing++;
  }

  /**
   * Release processing slot
   */
  releaseSlot() {
    this.processing--;
    if (this.queue.length > 0) {
      const resolve = this.queue.shift();
      resolve();
    }
  }

  /**
   * Main upload handler
   */
  async upload(file, options = {}) {
    // Validate
    await this.validateFile(file);

    // Acquire concurrency slot
    await this.acquireSlot();

    try {
      // Process image
      const { main, thumbnail, originalMetadata } = await this.processImage(
        file.buffer,
        options
      );

      // Generate filenames
      const mainFilename = this.generateFilename(file.originalname);
      const thumbFilename = thumbnail
        ? this.generateFilename(file.originalname, '_thumb')
        : null;

      // Save based on storage type
      let mainUrl, thumbnailUrl;

      if (this.storageType === 's3') {
        mainUrl = await this.saveS3(main.buffer, mainFilename);
        if (thumbnail) {
          thumbnailUrl = await this.saveS3(thumbnail.buffer, thumbFilename);
        }
      } else {
        mainUrl = await this.saveLocal(main.buffer, mainFilename);
        if (thumbnail) {
          thumbnailUrl = await this.saveLocal(thumbnail.buffer, thumbFilename);
        }
      }

      logger.info('Image uploaded successfully', {
        mainUrl,
        thumbnailUrl,
        originalSize: originalMetadata.size,
        processedSize: main.info.size,
        compression: ((1 - main.info.size / originalMetadata.size) * 100).toFixed(1) + '%',
      });

      return {
        image_url: mainUrl,
        thumbnail_url: thumbnailUrl,
        width: main.info.width,
        height: main.info.height,
        size_bytes: main.info.size,
        format: 'webp',
        original: originalMetadata,
      };
    } finally {
      this.releaseSlot();
    }
  }

  /**
   * Delete image
   */
  async delete(imageUrl) {
    if (this.storageType === 's3') {
      await deleteFromS3(imageUrl);
    } else {
      const filename = path.basename(imageUrl);
      const filePath = path.join(process.cwd(), this.uploadDir, filename);
      try {
        await fs.unlink(filePath);
      } catch (error) {
        logger.warn('Failed to delete local file', { error: error.message });
      }
    }
  }
}

export default new ImageService();
</file>

<file path="backend/src/services/microSurveyClient.js">
// ============================================
// Micro-Survey API Client
// Resilient integration with retries, circuit breaker, timeout
// ============================================
import axios from 'axios';
import { config } from '../config/index.js';
import { logger } from '../lib/logger.js';

class CircuitBreaker {
  constructor(threshold, timeout) {
    this.threshold = threshold;
    this.timeout = timeout;
    this.failures = 0;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.nextAttempt = Date.now();
  }

  recordSuccess() {
    this.failures = 0;
    this.state = 'CLOSED';
  }

  recordFailure() {
    this.failures++;
    if (this.failures >= this.threshold) {
      this.state = 'OPEN';
      this.nextAttempt = Date.now() + this.timeout;
      logger.warn('Circuit breaker opened', { failures: this.failures });
    }
  }

  canAttempt() {
    if (this.state === 'CLOSED') return true;
    if (this.state === 'OPEN' && Date.now() > this.nextAttempt) {
      this.state = 'HALF_OPEN';
      logger.info('Circuit breaker half-open, attempting request');
      return true;
    }
    return false;
  }
}

class MicroSurveyClient {
  constructor() {
    this.baseUrl = config.microSurvey.baseUrl;
    this.apiKey = config.microSurvey.apiKey;
    this.timeout = config.microSurvey.timeout;
    this.retryAttempts = config.microSurvey.retryAttempts;
    this.useMock = config.features.useMockMicroSurvey;
    
    this.circuitBreaker = new CircuitBreaker(
      config.microSurvey.circuitBreaker.threshold,
      config.microSurvey.circuitBreaker.timeout
    );

    this.client = axios.create({
      baseURL: this.baseUrl,
      timeout: this.timeout,
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': 'Dashboard-Backend/2.0',
      },
    });

    // Request interceptor
    this.client.interceptors.request.use(
      (config) => {
        logger.debug('MicroSurvey API request', {
          method: config.method,
          url: config.url,
          useMock: this.useMock,
        });
        return config;
      },
      (error) => Promise.reject(error)
    );

    // Response interceptor
    this.client.interceptors.response.use(
      (response) => {
        this.circuitBreaker.recordSuccess();
        logger.debug('MicroSurvey API response', {
          status: response.status,
          url: response.config.url,
        });
        return response;
      },
      (error) => {
        this.circuitBreaker.recordFailure();
        logger.error('MicroSurvey API error', {
          message: error.message,
          status: error.response?.status,
          url: error.config?.url,
        });
        return Promise.reject(error);
      }
    );
  }

  /**
   * Retry logic with exponential backoff
   */
  async retryRequest(fn, attempt = 1) {
    try {
      if (!this.circuitBreaker.canAttempt()) {
        throw new Error('Circuit breaker is open');
      }
      return await fn();
    } catch (error) {
      if (attempt >= this.retryAttempts) {
        logger.error('Max retry attempts reached', { attempt, error: error.message });
        throw error;
      }

      const delay = Math.min(1000 * Math.pow(2, attempt), 10000);
      logger.warn(`Retry attempt ${attempt}/${this.retryAttempts} after ${delay}ms`);
      
      await new Promise(resolve => setTimeout(resolve, delay));
      return this.retryRequest(fn, attempt + 1);
    }
  }

  /**
   * Get authorization header (can be overridden per-tenant)
   */
  getAuthHeader(tenantApiKey = null) {
    const key = tenantApiKey || this.apiKey;
    return { 'x-api-key': key };
  }

  /**
   * Create a new survey
   */
  async createSurvey(surveyData, tenantApiKey = null) {
    return this.retryRequest(async () => {
      const response = await this.client.post('/v1/surveys', surveyData, {
        headers: this.getAuthHeader(tenantApiKey),
      });
      return response.data;
    });
  }

  /**
   * Get survey by ID
   */
  async getSurvey(surveyId, tenantApiKey = null) {
    return this.retryRequest(async () => {
      const response = await this.client.get(`/v1/surveys/${surveyId}`, {
        headers: this.getAuthHeader(tenantApiKey),
      });
      return response.data;
    });
  }

  /**
   * Update survey (publish, unpublish, edit)
   */
  async updateSurvey(surveyId, updates, tenantApiKey = null) {
    return this.retryRequest(async () => {
      const response = await this.client.put(`/v1/surveys/${surveyId}`, updates, {
        headers: this.getAuthHeader(tenantApiKey),
      });
      return response.data;
    });
  }

  /**
   * Submit a response (public endpoint, usually no auth needed)
   */
  async submitResponse(surveyKey, responseData) {
    return this.retryRequest(async () => {
      const response = await this.client.post(
        `/v1/surveys/${surveyKey}/responses`,
        responseData
      );
      return response.data;
    });
  }

  /**
   * Get aggregated analytics/results
   */
  async getResults(surveyId, filters = {}, tenantApiKey = null) {
    return this.retryRequest(async () => {
      const response = await this.client.get(`/v1/surveys/${surveyId}/results`, {
        headers: this.getAuthHeader(tenantApiKey),
        params: filters,
      });
      return response.data;
    });
  }

  /**
   * Request CSV export
   */
  async requestExport(surveyId, options = {}, tenantApiKey = null) {
    return this.retryRequest(async () => {
      const response = await this.client.post(
        `/v1/surveys/${surveyId}/export`,
        options,
        {
          headers: this.getAuthHeader(tenantApiKey),
        }
      );
      return response.data;
    });
  }

  /**
   * Health check
   */
  async healthCheck() {
    try {
      const response = await this.client.get('/health', { timeout: 2000 });
      return response.status === 200;
    } catch (error) {
      return false;
    }
  }
}

// Singleton instance
export const microSurveyClient = new MicroSurveyClient();
export default microSurveyClient;
</file>

<file path="backend/src/utils/ApiError.js">
// ============================================
// Custom Error Class for API Errors
// Standardized error handling across the app
// ============================================

export class ApiError extends Error {
  constructor(message, statusCode = 500, details = null) {
    super(message);
    this.name = "ApiError";
    this.statusCode = statusCode;
    this.details = details;
    this.isOperational = true;
    Error.captureStackTrace(this, this.constructor);
  }

  static badRequest(message, details) { 
    return new ApiError(message, 400, details); 
  }
  
  static unauthorized(message) { 
    return new ApiError(message, 401); 
  }
  
  static forbidden(message) { 
    return new ApiError(message, 403); 
  }
  
  static notFound(message) { 
    return new ApiError(message, 404); 
  }
  
  static conflict(message) { 
    return new ApiError(message, 409); 
  }
}
</file>

<file path="backend/src/utils/ApiResponse.js">
export class ApiResponse {
  static success(res, statusCode = 200, message = "Success", data = {}) {
    return res.status(statusCode).json({
      success: true,
      message,
      data,
    });
  }

  static created(res, message = "Created", data = {}) {
    return res.status(201).json({
      success: true,
      message,
      data,
    });
  }

  static paginated(res, data, page, limit, total, message = "Success") {
    return res.status(200).json({
      success: true,
      message,
      data,
      pagination: {
        page: parseInt(page, 10),
        limit: parseInt(limit, 10),
        total,
        pages: Math.ceil(total / limit),
      },
    });
  }
}
</file>

<file path="backend/src/utils/asyncHandler.js">
export function asyncHandler(fn) {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}
</file>

<file path="backend/src/utils/bcrypt.js">
import bcrypt from 'bcryptjs';
import { config } from '../config/env.js';

/**
 * Bcrypt utility functions for password hashing
 */

/**
 * Hash a password
 * @param {string} password - Plain text password
 * @returns {Promise<string>} Hashed password
 */
export const hashPassword = async (password) => {
  return bcrypt.hash(password, config.bcrypt.saltRounds);
};

/**
 * Compare password with hash
 * @param {string} password - Plain text password
 * @param {string} hash - Hashed password
 * @returns {Promise<boolean>} True if password matches
 */
export const comparePassword = async (password, hash) => {
  return bcrypt.compare(password, hash);
};
</file>

<file path="backend/src/utils/jwt.js">
import jwt from "jsonwebtoken";
import { config } from "../config/index.js";

export function signAccessToken(payload) {
  return jwt.sign(payload, config.jwt.secret, {
    expiresIn: config.jwt.accessTokenExpiry,
  });
}

export function signRefreshToken(payload) {
  return jwt.sign(payload, config.jwt.secret, {
    expiresIn: config.jwt.refreshTokenExpiry,
  });
}

export function verifyToken(token) {
  try {
    return jwt.verify(token, config.jwt.secret);
  } catch (error) {
    throw new Error("Invalid or expired token");
  }
}
</file>

<file path="backend/src/utils/logger.js">
import winston from 'winston';
import { config } from '../config/env.js';

const { combine, timestamp, printf, colorize, errors } = winston.format;

// Custom log format
const logFormat = printf(({ level, message, timestamp, stack, ...metadata }) => {
  let msg = `${timestamp} [${level}]: ${message}`;
  
  // Add metadata if present
  if (Object.keys(metadata).length > 0) {
    msg += ` ${JSON.stringify(metadata)}`;
  }
  
  // Add stack trace for errors
  if (stack) {
    msg += `\n${stack}`;
  }
  
  return msg;
});

/**
 * Winston logger instance
 * Configured for different environments
 */
export const logger = winston.createLogger({
  level: config.logging.level,
  format: combine(
    errors({ stack: true }),
    timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    logFormat
  ),
  transports: [
    // Console transport with colors for development
    new winston.transports.Console({
      format: combine(
        colorize(),
        timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
        logFormat
      ),
    }),
  ],
});

// Add file transports in production
if (config.nodeEnv === 'production') {
  logger.add(
    new winston.transports.File({
      filename: 'logs/error.log',
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5,
    })
  );
  
  logger.add(
    new winston.transports.File({
      filename: 'logs/combined.log',
      maxsize: 5242880, // 5MB
      maxFiles: 5,
    })
  );
}

// Create a stream for morgan HTTP logger
logger.stream = {
  write: (message) => {
    logger.info(message.trim());
  },
};
</file>

<file path="backend/src/workers/analytics.worker.js">
// ============================================
// FILE: backend/src/workers/analytics.worker.js
// Background worker for analytics aggregation
// Runs periodically to update cached analytics
// ============================================
import { Worker, Queue } from 'bullmq';
import { config } from '../config/index.js';
import { logger } from '../lib/logger.js';
import db from '../config/db.js';
import analyticsService from '../modules/analytics/analytics.service.js';

const connection = {
  host: config.redis.host,
  port: config.redis.port,
};

const queueName = `${config.queue.prefix}:analytics`;

// Create queue for analytics jobs
const analyticsQueue = new Queue(queueName, { connection });

/**
 * Enqueue analytics aggregation for a survey
 */
export async function enqueueAnalyticsAggregation(surveyId) {
  const job = await analyticsQueue.add(
    'aggregate-analytics',
    { surveyId },
    {
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 5000,
      },
      removeOnComplete: {
        age: 24 * 3600, // Keep for 24 hours
        count: 1000,
      },
      removeOnFail: {
        age: 7 * 24 * 3600, // Keep failed jobs for 7 days
      },
    }
  );

  logger.info('Analytics aggregation job enqueued', {
    jobId: job.id,
    surveyId,
  });

  return job.id;
}

/**
 * Enqueue aggregation for all active surveys
 */
export async function enqueueAllSurveys() {
  const result = await db.query(
    `SELECT id FROM surveys WHERE status = 'published'`
  );

  const surveys = result.rows;
  logger.info(`Enqueueing analytics for ${surveys.length} surveys`);

  for (const survey of surveys) {
    await enqueueAnalyticsAggregation(survey.id);
  }

  return surveys.length;
}

// Worker process
if (config.nodeEnv !== 'test') {
  const worker = new Worker(
    queueName,
    async (job) => {
      logger.info('Processing analytics aggregation job', {
        jobId: job.id,
        surveyId: job.data.surveyId,
      });

      const { surveyId } = job.data;

      try {
        // Update progress
        await job.updateProgress(10);

        // Fetch events and aggregate
        const events = await db.query(
          `SELECT 
            event_type,
            COUNT(*) as count,
            MAX(created_at) as last_event
          FROM survey_events
          WHERE survey_id = $1
          GROUP BY event_type`,
          [surveyId]
        );

        await job.updateProgress(30);

        // Get response count
        const responsesResult = await db.query(
          `SELECT COUNT(*) as count FROM survey_responses WHERE survey_id = $1`,
          [surveyId]
        );

        const views = events.rows.find(e => e.event_type === 'survey_view')?.count || 0;
        const starts = events.rows.find(e => e.event_type === 'survey_start')?.count || 0;
        const completions = parseInt(responsesResult.rows[0]?.count || 0);

        await job.updateProgress(60);

        // Aggregate question stats
        const questionStats = await aggregateQuestionStats(surveyId);

        await job.updateProgress(80);

        // Update cache
        const analyticsData = {
          surveyId,
          views: parseInt(views),
          starts: parseInt(starts),
          completions,
          completionRate: starts > 0 ? ((completions / starts) * 100).toFixed(2) : 0,
          questionStats,
          lastUpdated: new Date().toISOString(),
        };

        // Clear old cache and insert new
        await db.query(
          'DELETE FROM survey_analytics_cache WHERE survey_id = $1',
          [surveyId]
        );

        await db.query(
          `INSERT INTO survey_analytics_cache (
            id, survey_id, views, starts, completions, question_stats,
            analytics_data, cached_at, expires_at
          ) VALUES (gen_random_uuid(), $1, $2, $3, $4, $5, $6, NOW(), NOW() + INTERVAL '1 hour')`,
          [
            surveyId,
            analyticsData.views,
            analyticsData.starts,
            analyticsData.completions,
            JSON.stringify(analyticsData.questionStats),
            JSON.stringify(analyticsData),
          ]
        );

        await job.updateProgress(100);

        logger.info('Analytics aggregation completed', {
          jobId: job.id,
          surveyId,
          views: analyticsData.views,
          starts: analyticsData.starts,
          completions: analyticsData.completions,
        });

        return analyticsData;
      } catch (error) {
        logger.error('Analytics aggregation failed', {
          jobId: job.id,
          surveyId,
          error: error.message,
          stack: error.stack,
        });
        throw error;
      }
    },
    {
      connection,
      concurrency: config.queue.concurrency,
    }
  );

  // Event handlers
  worker.on('completed', (job) => {
    logger.info('Analytics job completed', { jobId: job.id });
  });

  worker.on('failed', (job, err) => {
    logger.error('Analytics job failed', {
      jobId: job?.id,
      error: err.message,
      surveyId: job?.data?.surveyId,
    });
  });

  worker.on('error', (err) => {
    logger.error('Analytics worker error', { error: err.message });
  });

  logger.info('Analytics worker started', {
    queue: queueName,
    concurrency: config.queue.concurrency,
  });

  // Schedule periodic aggregation (every 10 minutes)
  setInterval(async () => {
    try {
      const count = await enqueueAllSurveys();
      logger.info(`Scheduled analytics aggregation for ${count} surveys`);
    } catch (error) {
      logger.error('Failed to schedule analytics', { error: error.message });
    }
  }, 10 * 60 * 1000); // 10 minutes

  // Graceful shutdown
  process.on('SIGTERM', async () => {
    logger.info('SIGTERM received, closing analytics worker...');
    await worker.close();
    process.exit(0);
  });
}

/**
 * Helper: Aggregate question-level statistics
 */
async function aggregateQuestionStats(surveyId) {
  const survey = await db.query(
    `SELECT ss.snapshot FROM surveys s
     LEFT JOIN survey_snapshots ss ON s.published_snapshot_id = ss.id
     WHERE s.id = $1`,
    [surveyId]
  );

  if (survey.rows.length === 0 || !survey.rows[0].snapshot) {
    return {};
  }

  const questions = survey.rows[0].snapshot.questions || [];
  const stats = {};

  for (const question of questions) {
    const responses = await db.query(
      `SELECT response_data FROM survey_responses 
       WHERE survey_id = $1`,
      [surveyId]
    );

    // Simple aggregation per question
    const questionResponses = responses.rows
      .map(r => r.response_data?.answers?.find(a => a.questionId === question.id))
      .filter(Boolean);

    stats[question.id] = {
      totalResponses: questionResponses.length,
      type: question.type,
    };

    // Type-specific aggregation
    if (question.type === 'multiple_choice') {
      const optionCounts = {};
      questionResponses.forEach(r => {
        const answer = r.answer;
        optionCounts[answer] = (optionCounts[answer] || 0) + 1;
      });
      stats[question.id].optionCounts = optionCounts;
    } else if (question.type === 'rating') {
      const ratings = questionResponses.map(r => r.answer).filter(a => typeof a === 'number');
      if (ratings.length > 0) {
        const sum = ratings.reduce((acc, val) => acc + val, 0);
        stats[question.id].average = (sum / ratings.length).toFixed(2);
      }
    }
  }

  return stats;
}

export { analyticsQueue };
export default worker;
</file>

<file path="backend/src/workers/imageWorker.js">
// ============================================
// FILE: backend/src/workers/imageWorker.js
// Async image processing with BullMQ
// ============================================
import { Worker, Queue } from 'bullmq';
import { config } from '../config/index.js';
import { logger } from '../lib/logger.js';
import imageService from '../services/imageService.js';

const connection = {
  host: config.redis.host,
  port: config.redis.port,
};

const queueName = config.queue.imageQueueName;

// Create queue for enqueueing jobs
const imageQueue = new Queue(queueName, { connection });

/**
 * Enqueue image processing job
 */
export async function enqueueImageProcessing(data) {
  const job = await imageQueue.add('process-image', data, {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 2000,
    },
    removeOnComplete: {
      age: 24 * 3600, // Keep completed jobs for 24 hours
      count: 1000,
    },
    removeOnFail: {
      age: 7 * 24 * 3600, // Keep failed jobs for 7 days
    },
  });

  logger.info('Image processing job enqueued', {
    jobId: job.id,
    userId: data.userId,
  });

  return job.id;
}

/**
 * Worker process (run in separate process)
 */
if (config.image.async) {
  const worker = new Worker(
    queueName,
    async (job) => {
      logger.info('Processing image job', {
        jobId: job.id,
        userId: job.data.userId,
      });

      const { file, options, userId } = job.data;

      // Update progress
      await job.updateProgress(10);

      // Recreate file object from serialized data
      const fileObj = {
        buffer: Buffer.from(file.buffer),
        originalname: file.originalname,
        mimetype: file.mimetype,
        size: file.size,
      };

      await job.updateProgress(25);

      // Process image
      const result = await imageService.upload(fileObj, options);

      await job.updateProgress(100);

      logger.info('Image processing completed', {
        jobId: job.id,
        userId,
        url: result.image_url,
      });

      return result;
    },
    {
      connection,
      concurrency: config.queue.concurrency,
    }
  );

  worker.on('completed', (job) => {
    logger.info('Image job completed', { jobId: job.id });
  });

  worker.on('failed', (job, err) => {
    logger.error('Image job failed', {
      jobId: job?.id,
      error: err.message,
      stack: err.stack,
    });
  });

  worker.on('error', (err) => {
    logger.error('Image worker error', { error: err.message });
  });

  logger.info('Image worker started', {
    queue: queueName,
    concurrency: config.queue.concurrency,
  });

  // Graceful shutdown
  process.on('SIGTERM', async () => {
    logger.info('SIGTERM received, closing image worker...');
    await worker.close();
    process.exit(0);
  });
}

export { imageQueue };
</file>

<file path="backend/src/workers/responseQueue.js">
import { Queue, Worker } from 'bullmq';
import { config } from '../config/index.js';
import * as integrationService from '../modules/integration/integration.service.js';

const responseQueue = new Queue('responses', {
  connection: {
    host: config.redis.host,
    port: config.redis.port,
  },
});

const worker = new Worker
</file>

<file path="backend/src/workers/surveyWorker.js">
// backend/src/workers/surveyWorker.js
import { Worker } from 'bullmq';
import Redis from 'ioredis';
import { config } from '../config/index.js';
import { logger } from '../lib/logger.js';
import microSurveyClient from '../services/microSurveyClient.js';

const connection = new Redis(config.redis.url, {
  maxRetriesPerRequest: null,
});

const worker = new Worker(
  `${config.queue.prefix}:surveys`,
  async (job) => {
    logger.info('Processing survey job', { jobId: job.id, type: job.name });

    switch (job.name) {
      case 'sync-analytics':
        return await syncAnalytics(job.data);
      case 'export-survey':
        return await exportSurvey(job.data);
      default:
        throw new Error(`Unknown job type: ${job.name}`);
    }
  },
  {
    connection,
    concurrency: config.queue.concurrency,
  }
);

async function syncAnalytics({ surveyId, microsurveyId }) {
  const results = await microSurveyClient.getResults(microsurveyId);
  // Cache results...
  return { synced: true, responseCount: results.totalResponses };
}

async function exportSurvey({ surveyId, microsurveyId, format }) {
  const result = await microSurveyClient.requestExport(microsurveyId, { format });
  return { exportId: result.exportId };
}

worker.on('completed', (job) => {
  logger.info('Job completed', { jobId: job.id });
});

worker.on('failed', (job, err) => {
  logger.error('Job failed', { jobId: job?.id, error: err.message });
});

logger.info('Survey worker started');

export default worker;
</file>

<file path="backend/src/app.js">
// ============================================
// DEPRECATED: This file is no longer used
// The app initialization is now in server.js
// Keeping for backwards compatibility
// ============================================

import express from "express";
const app = express();

console.warn("⚠️  app.js is deprecated. Application logic moved to server.js");

export default app;
</file>

<file path="backend/src/server.js">
// ============================================
// Server Entry Point - FIXED
// Secure startup with validation and proper error handling
// ============================================
import express from "express";
import cookieParser from "cookie-parser";
import cors from "cors";
import helmet from "helmet";
import morgan from "morgan";
import compression from "compression";
import { config } from "./config/index.js";
import db from "./config/db.js";
import routes from "./routes/index.js";
import { errorHandler } from "./middleware/errorHandler.js";
import { logSanitizerMiddleware } from "./middleware/logSanitizer.js";
import { setCsrfToken, verifyCsrfToken } from "./middleware/csrf.js";
import { rateLimitMiddleware, authRateLimiter } from "./middleware/rateLimit.middleware.js";
import { logger } from "./lib/logger.js";

const app = express();

// Security middleware
app.use(
  helmet({
    contentSecurityPolicy: config.nodeEnv === "production",
  })
);

// =============================================
// CORS configuration - FIXED (string OR array)
// =============================================
const corsOrigins =
  typeof config.cors.origins === "string"
    ? config.cors.origins.split(",").map((o) => o.trim())
    : config.cors.origins;

app.use(
  cors({
    origin: corsOrigins,
    credentials: config.cors.credentials,
  })
);

// Trust proxy if configured
if (config.security.trustProxy) {
  app.set("trust proxy", 1);
  logger.info("Trust proxy enabled");
}

// Rate limiting
app.use("/api/", rateLimitMiddleware);

// Body parsing
// Normalize Content-Type charset (some test clients send uppercase or quoted charset)
app.use((req, res, next) => {
  const ct = req.headers['content-type'];
  if (ct) {
    // Robustly parse content-type parameters and normalize charset to utf-8 (lowercase, no quotes)
    const parts = ct.split(';').map(p => p.trim());
    const type = parts[0];
    const params = parts.slice(1).map(p => {
      const [k, v] = p.split('=');
      if (!v) return p;
      if (k.trim().toLowerCase() === 'charset') {
        // strip quotes and normalize
        const cleaned = v.replace(/"/g, '').trim().toLowerCase();
        return `charset=${cleaned}`;
      }
      return p;
    });
    req.headers['content-type'] = [type, ...params].join('; ');
  }
  next();
});

app.use(express.json({ limit: "1mb" }));
app.use(express.urlencoded({ extended: true, limit: "1mb" }));
app.use(cookieParser());
app.use(compression());

// Log sanitizer
app.use(logSanitizerMiddleware);

// CSRF protection
app.use(setCsrfToken);
app.use("/api/auth/refresh", verifyCsrfToken);
app.use("/api/auth/logout", verifyCsrfToken);

// Auth rate limiter
app.use("/api/auth/login", authRateLimiter);
app.use("/api/auth/register", authRateLimiter);

// Logging
if (config.nodeEnv === "development") {
  app.use(morgan("dev"));
} else {
  app.use(
    morgan("combined", {
      skip: (req) => req.path === "/api/health",
      stream: {
        write: (message) => logger.info(message.trim()),
      },
    })
  );
}

// API routes
app.use("/api", routes);

// Root endpoint
app.get("/", (req, res) => {
  res.json({
    success: true,
    message: "Micro-Survey Dashboard API",
    version: "2.0.0",
    status: "running",
    environment: config.nodeEnv,
  });
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({
    success: false,
    message: `Route ${req.method} ${req.path} not found`,
  });
});

// Error handler (must be last)
app.use(errorHandler);

// Graceful shutdown
process.on("SIGTERM", gracefulShutdown);
process.on("SIGINT", gracefulShutdown);

let server;

async function gracefulShutdown(signal) {
  logger.info(`${signal} received. Starting graceful shutdown...`);

  if (server) {
    server.close(() => {
      logger.info("HTTP server closed");
      db.pool.end(() => {
        logger.info("Database pool closed");
        process.exit(0);
      });
    });

    setTimeout(() => {
      logger.error("Forced shutdown after timeout");
      process.exit(1);
    }, 10000);
  } else {
    process.exit(0);
  }
}

// Start server
async function startServer() {
  try {
    await db.testConnection();

    const PORT = config.port;
    server = app.listen(PORT, () => {
      logger.info(`
╔═══════════════════════════════════════════════════════╗
║   🚀 Micro-Survey Dashboard API                       ║
║                                                       ║
║   Environment: ${config.nodeEnv.padEnd(33)}║
║   Port:        ${PORT.toString().padEnd(33)}║
║   Database:    Connected ✅                           ║
║                                                       ║
║   API:         http://localhost:${PORT}/api              ║
║   Health:      http://localhost:${PORT}/api/health       ║
║   Tenants:     http://localhost:${PORT}/api/tenants      ║
║   Surveys:     http://localhost:${PORT}/api/surveys      ║
╚═══════════════════════════════════════════════════════╝
      `);
    });
  } catch (error) {
    logger.error("❌ Failed to start server:", error);
    // During tests we should not exit the process; throw the error so the test runner can handle it.
    if (process.env.NODE_ENV === 'test') {
      throw error;
    }
    process.exit(1);
  }
}

// Only start the server automatically when not running in test environment.
if (process.env.NODE_ENV !== 'test') {
  startServer();
}

export default app;
</file>

<file path="backend/tests/auth.integration.test.js">
// ============================================
// FILE: backend/tests/auth.integration.test.js
// Integration tests for auth flows
// ============================================
import { describe, it, expect, beforeAll, afterAll, beforeEach } from '@jest/globals';
import request from 'supertest';
import app from '../src/server.js';
import db from '../src/config/db.js';

describe('Auth Integration Tests', () => {
  let testUser = {
    email: `test-${Date.now()}@example.com`,
    password: 'TestPassword123!',
    fullName: 'Test User',
  };
  
  let accessToken;
  let refreshToken;
  
  afterAll(async () => {
    // Cleanup
    await db.query('DELETE FROM users WHERE email = $1', [testUser.email]);
    await db.pool.end();
  });
  
  describe('POST /api/auth/signup', () => {
    it('should register a new user', async () => {
      const res = await request(app)
        .post('/api/auth/signup')
        .send(testUser)
        .expect(201);
      
      expect(res.body.success).toBe(true);
      expect(res.body.data.user).toBeDefined();
      expect(res.body.data.user.email).toBe(testUser.email);
      expect(res.body.data.accessToken).toBeDefined();
      
      // Should set cookie
      const cookies = res.headers['set-cookie'];
      expect(cookies).toBeDefined();
      expect(cookies.some(c => c.startsWith('refreshToken='))).toBe(true);
      
      accessToken = res.body.data.accessToken;
    });
    
    it('should reject duplicate email', async () => {
      const res = await request(app)
        .post('/api/auth/signup')
        .send(testUser)
        .expect(409);
      
      expect(res.body.success).toBe(false);
      expect(res.body.message).toContain('already registered');
    });
    
    it('should reject invalid email', async () => {
      const res = await request(app)
        .post('/api/auth/signup')
        .send({ ...testUser, email: 'invalid-email' })
        .expect(400);
      
      expect(res.body.success).toBe(false);
    });
    
    it('should reject weak password', async () => {
      const res = await request(app)
        .post('/api/auth/signup')
        .send({ ...testUser, email: 'new@test.com', password: 'weak' })
        .expect(400);
      
      expect(res.body.success).toBe(false);
    });
  });
  
  describe('POST /api/auth/login', () => {
    it('should login with correct credentials', async () => {
      const res = await request(app)
        .post('/api/auth/login')
        .send({
          email: testUser.email,
          password: testUser.password,
        })
        .expect(200);
      
      expect(res.body.success).toBe(true);
      expect(res.body.data.accessToken).toBeDefined();
      
      const cookies = res.headers['set-cookie'];
      expect(cookies).toBeDefined();
      
      // Extract refresh token from cookie
      const refreshCookie = cookies.find(c => c.startsWith('refreshToken='));
      refreshToken = refreshCookie.split(';')[0].split('=')[1];
      
      accessToken = res.body.data.accessToken;
    });
    
    it('should reject invalid credentials', async () => {
      const res = await request(app)
        .post('/api/auth/login')
        .send({
          email: testUser.email,
          password: 'WrongPassword123',
        })
        .expect(401);
      
      expect(res.body.success).toBe(false);
    });
  });
  
  describe('GET /api/auth/me', () => {
    it('should return current user with valid token', async () => {
      const res = await request(app)
        .get('/api/auth/me')
        .set('Authorization', `Bearer ${accessToken}`)
        .expect(200);
      
      expect(res.body.success).toBe(true);
      expect(res.body.data.user.email).toBe(testUser.email);
    });
    
    it('should reject request without token', async () => {
      const res = await request(app)
        .get('/api/auth/me')
        .expect(401);
      
      expect(res.body.success).toBe(false);
    });
    
    it('should reject request with invalid token', async () => {
      const res = await request(app)
        .get('/api/auth/me')
        .set('Authorization', 'Bearer invalid-token')
        .expect(401);
      
      expect(res.body.success).toBe(false);
    });
  });
  
  describe('POST /api/auth/refresh', () => {
    it('should refresh access token with valid refresh token', async () => {
      const res = await request(app)
        .post('/api/auth/refresh')
        .set('Cookie', `refreshToken=${refreshToken}`)
        .expect(200);
      
      expect(res.body.success).toBe(true);
      expect(res.body.data.accessToken).toBeDefined();
      expect(res.body.data.accessToken).not.toBe(accessToken);
      
      // Should set new refresh token cookie
      const cookies = res.headers['set-cookie'];
      expect(cookies).toBeDefined();
      
      accessToken = res.body.data.accessToken;
    });
    
    it('should reject reuse of old refresh token', async () => {
      // Try to use the old refresh token again
      const res = await request(app)
        .post('/api/auth/refresh')
        .set('Cookie', `refreshToken=${refreshToken}`)
        .expect(401);
      
      expect(res.body.success).toBe(false);
    });
  });
  
  describe('POST /api/auth/logout', () => {
    it('should logout and clear cookie', async () => {
      const res = await request(app)
        .post('/api/auth/logout')
        .set('Cookie', `refreshToken=${refreshToken}`)
        .expect(200);
      
      expect(res.body.success).toBe(true);
      
      // Cookie should be cleared
      const cookies = res.headers['set-cookie'];
      expect(cookies).toBeDefined();
      expect(cookies.some(c => c.includes('refreshToken=;'))).toBe(true);
    });
  });
  
  describe('Password Reset Flow', () => {
    it('should request password reset', async () => {
      const res = await request(app)
        .post('/api/auth/request-password-reset')
        .send({ email: testUser.email })
        .expect(200);
      
      expect(res.body.success).toBe(true);
      expect(res.body.message).toBeDefined();
    });
    
    it('should not reveal if email does not exist', async () => {
      const res = await request(app)
        .post('/api/auth/request-password-reset')
        .send({ email: 'nonexistent@test.com' })
        .expect(200);
      
      // Same response for security
      expect(res.body.success).toBe(true);
    });
    
    // Note: Full password reset test would require accessing the reset token
    // from the database or email service. Left as TODO for comprehensive suite.
  });
});
</file>

<file path="backend/tests/auth.test.js">
import { describe, it, before, after } from 'node:test';
import assert from 'node:assert';
import request from 'supertest';
import app from '../src/server.js';
import db from '../src/config/db.js';

describe('Authentication Flow', () => {
  const testUser = {
    email: `test-${Date.now()}@example.com`,
    password: 'TestPass123!',
    fullName: 'Test User',
  };

  let accessToken, refreshToken, csrfToken;

  after(async () => {
    await db.query('DELETE FROM users WHERE email = $1', [testUser.email]);
    await db.pool.end();
  });

  it('should register a new user', async () => {
    const res = await request(app)
      .post('/api/auth/register')
      .send(testUser)
      .expect(201);

    assert.strictEqual(res.body.success, true);
    assert.ok(res.body.data.accessToken);
    accessToken = res.body.data.accessToken;
  });

  it('should login existing user', async () => {
    const res = await request(app)
      .post('/api/auth/login')
      .send({ email: testUser.email, password: testUser.password })
      .expect(200);

    assert.strictEqual(res.body.success, true);
    assert.ok(res.body.data.accessToken);
    
    // Extract cookies
    const cookies = res.headers['set-cookie'];
    refreshToken = cookies.find(c => c.startsWith('refreshToken='));
    csrfToken = res.body.data.csrfToken;
  });

  it('should refresh access token with cookie', async () => {
    const res = await request(app)
      .post('/api/auth/refresh')
      .set('Cookie', refreshToken)
      .set('x-csrf-token', csrfToken)
      .expect(200);

    assert.strictEqual(res.body.success, true);
    assert.ok(res.body.data.accessToken);
  });

  it('should get current user with token', async () => {
    const res = await request(app)
      .get('/api/auth/me')
      .set('Authorization', `Bearer ${accessToken}`)
      .expect(200);

    assert.strictEqual(res.body.data.user.email, testUser.email);
  });

  it('should logout and clear cookies', async () => {
    const res = await request(app)
      .post('/api/auth/logout')
      .set('Cookie', refreshToken)
      .set('x-csrf-token', csrfToken)
      .expect(200);

    assert.strictEqual(res.body.success, true);
  });
});
</file>

<file path="backend/tests/auth.unit.test.js">
// ============================================
// FILE: backend/tests/auth.unit.test.js
// Unit tests for auth utilities
// ============================================
import { describe, it, expect, beforeAll } from '@jest/globals';
import { hashPassword, comparePassword, validatePasswordStrength } from '../src/modules/auth/password.utils.js';
import { generateAccessToken, verifyAccessToken, hashToken } from '../src/modules/auth/jwt.utils.js';

describe('Password Utilities', () => {
  describe('hashPassword', () => {
    it('should hash a valid password', async () => {
      const password = 'TestPassword123';
      const hash = await hashPassword(password);
      
      expect(hash).toBeTruthy();
      expect(hash).not.toBe(password);
      expect(hash.startsWith('$2')).toBe(true); // bcrypt prefix
    });
    
    it('should reject passwords under 8 characters', async () => {
      await expect(hashPassword('short')).rejects.toThrow('at least 8 characters');
    });
    
    it('should reject non-string passwords', async () => {
      await expect(hashPassword(null)).rejects.toThrow('must be a non-empty string');
    });
  });
  
  describe('comparePassword', () => {
    it('should return true for matching password', async () => {
      const password = 'TestPassword123';
      const hash = await hashPassword(password);
      const isValid = await comparePassword(password, hash);
      
      expect(isValid).toBe(true);
    });
    
    it('should return false for non-matching password', async () => {
      const hash = await hashPassword('Correct1');
      const isValid = await comparePassword('wrong', hash);
      
      expect(isValid).toBe(false);
    });
  });
  
  describe('validatePasswordStrength', () => {
    it('should validate a strong password', () => {
      const result = validatePasswordStrength('StrongPass123');
      expect(result.valid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });
    
    it('should reject weak passwords', () => {
      const result = validatePasswordStrength('weak');
      expect(result.valid).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
    });
  });
});

describe('JWT Utilities', () => {
  const mockUser = {
    userId: '123e4567-e89b-12d3-a456-426614174000',
    email: 'test@example.com',
    role: 'user',
  };
  
  describe('generateAccessToken', () => {
    it('should generate a valid JWT', () => {
      const token = generateAccessToken(mockUser);
      
      expect(token).toBeTruthy();
      expect(typeof token).toBe('string');
      expect(token.split('.').length).toBe(3); // JWT format
    });
  });
  
  describe('verifyAccessToken', () => {
    it('should verify and decode a valid token', () => {
      const token = generateAccessToken(mockUser);
      const decoded = verifyAccessToken(token);
      
      expect(decoded.userId).toBe(mockUser.userId);
      expect(decoded.email).toBe(mockUser.email);
      expect(decoded.role).toBe(mockUser.role);
    });
    
    it('should reject invalid tokens', () => {
      expect(() => verifyAccessToken('invalid.token.here')).toThrow();
    });
    
    it('should reject expired tokens', () => {
      // This would require mocking time or using a very short expiry
      // Left as TODO for comprehensive test suite
    });
  });
  
  describe('hashToken', () => {
    it('should consistently hash the same token', () => {
      const token = 'test-refresh-token-abc123';
      const hash1 = hashToken(token);
      const hash2 = hashToken(token);
      
      expect(hash1).toBe(hash2);
      expect(hash1).toHaveLength(64); // SHA-256 hex length
    });
    
    it('should produce different hashes for different tokens', () => {
      const hash1 = hashToken('token1');
      const hash2 = hashToken('token2');
      
      expect(hash1).not.toBe(hash2);
    });
  });
});
</file>

<file path="backend/tests/batching.test.js">
import { describe, it, before, after } from 'node:test';
import assert from 'node:assert';
import { pushResponses } from '../src/modules/integration/integration.service.js';
import db from '../src/config/db.js';

describe('Batch Insert Performance', () => {
  let siteKey, orgId, questionId;

  before(async () => {
    // Create test data
    const org = await db.query(
      `INSERT INTO organizations (id, name, slug, owner_id) 
       VALUES (gen_random_uuid(), 'Test Org', 'test-org', gen_random_uuid()) 
       RETURNING id`
    );
    orgId = org.rows[0].id;

    const question = await db.query(
      `INSERT INTO questions (id, organization_id, question_text, question_type) 
       VALUES (gen_random_uuid(), $1, 'Test Question', 'text') 
       RETURNING id`,
      [orgId]
    );
    questionId = question.rows[0].id;

    const site = await db.query(
      `INSERT INTO captcha_sites (id, site_name, site_url, site_key, site_secret, organization_id) 
       VALUES (gen_random_uuid(), 'Test Site', 'http://test.com', 'test-key', 'test-secret', $1) 
       RETURNING site_key`,
      [orgId]
    );
    siteKey = site.rows[0].site_key;
  });

  after(async () => {
    await db.query('DELETE FROM organizations WHERE id = $1', [orgId]);
  });

  it('should batch insert 250 responses efficiently', async () => {
    const responses = Array.from({ length: 250 }, (_, i) => ({
      questionId,
      responseText: `Response ${i}`,
      sessionId: `session-${i}`,
      ipAddress: '127.0.0.1',
      userAgent: 'Test Agent',
    }));

    const start = Date.now();
    const result = await pushResponses(siteKey, responses);
    const duration = Date.now() - start;

    assert.strictEqual(result.inserted, 250);
    assert.strictEqual(result.batches, 3); // 100, 100, 50
    assert.ok(duration < 1000, `Batch insert took ${duration}ms (should be <1000ms)`);
  });
});
</file>

<file path="backend/tests/imageUpload.test.js">
// ============================================
// FILE: backend/tests/imageUpload.test.js
// Integration tests for image upload
// ============================================
import { describe, it, before, after, beforeEach } from 'node:test';
import assert from 'node:assert';
import request from 'supertest';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import app from '../src/server.js';
import db from '../src/config/db.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

describe.skip('Image Upload API (skipped - uploads removed)', () => {
  let accessToken;
  let userId;

  // Create test user and get token
  before(async () => {
    const testUser = {
      email: `imagetest-${Date.now()}@example.com`,
      password: 'TestPass123!',
      fullName: 'Image Test User',
    };

    const registerRes = await request(app)
      .post('/api/auth/register')
      .send(testUser);

    assert.strictEqual(registerRes.status, 201);
    accessToken = registerRes.body.data.accessToken;
    userId = registerRes.body.data.user.id;
  });

  after(async () => {
    // Cleanup test user
    if (userId) {
      await db.query('DELETE FROM users WHERE id = $1', [userId]);
    }
    await db.pool.end();
  });

  describe('POST /api/uploads/image', () => {
    it('should upload a valid JPEG image', async () => {
      // Create a test image buffer (1x1 red JPEG)
      const testImage = Buffer.from(
        '/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAP/bAEMAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCAABAAEDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlbaWmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9/KKKKAP/2Q==',
        'base64'
      );

      const res = await request(app)
        .post('/api/uploads/image')
        .set('Authorization', `Bearer ${accessToken}`)
        .attach('image', testImage, 'test.jpg')
        .expect(201);

      assert.strictEqual(res.body.success, true);
      assert.ok(res.body.data.image_url);
      assert.ok(res.body.data.thumbnail_url);
      assert.strictEqual(res.body.data.format, 'webp');
      assert.ok(res.body.data.size_bytes < testImage.length);
    });

    it('should reject file that is too large', async () => {
      // Create a mock large file (9MB, over default 8MB limit)
      const largeBuffer = Buffer.alloc(9 * 1024 * 1024, 0xFF);

      const res = await request(app)
        .post('/api/uploads/image')
        .set('Authorization', `Bearer ${accessToken}`)
        .attach('image', largeBuffer, 'large.jpg')
        .expect(400);

      assert.ok(res.body.message.includes('too large'));
    });

    it('should reject non-image file', async () => {
      const textFile = Buffer.from('This is not an image');

      const res = await request(app)
        .post('/api/uploads/image')
        .set('Authorization', `Bearer ${accessToken}`)
        .attach('image', textFile, 'test.txt')
        .expect(400);

      assert.ok(res.body.message.toLowerCase().includes('invalid'));
    });

    it('should reject request without authentication', async () => {
      const testImage = Buffer.from('fake-image');

      const res = await request(app)
        .post('/api/uploads/image')
        .attach('image', testImage, 'test.jpg')
        .expect(401);

      assert.strictEqual(res.body.success, false);
    });

    it('should respect rate limiting', async () => {
      // Create minimal valid JPEG
      const testImage = Buffer.from(
        '/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAP/bAEMAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCAABAAEDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlbaWmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9/KKKKAP/2Q==',
        'base64'
      );

      // Make 11 requests (limit is 10 per 15 minutes)
      for (let i = 0; i < 11; i++) {
        const res = await request(app)
          .post('/api/uploads/image')
          .set('Authorization', `Bearer ${accessToken}`)
          .attach('image', testImage, `test${i}.jpg`);

        if (i < 10) {
          assert.ok([201, 202].includes(res.status)); // Allow async response
        } else {
          assert.strictEqual(res.status, 429); // Too many requests
        }
      }
    });
  });

  describe('GET /api/uploads/config', () => {
    it('should return upload configuration', async () => {
      const res = await request(app)
        .get('/api/uploads/config')
        .set('Authorization', `Bearer ${accessToken}`)
        .expect(200);

      assert.strictEqual(res.body.success, true);
      assert.ok(res.body.data.maxFileSize);
      assert.ok(Array.isArray(res.body.data.allowedTypes));
      assert.ok(res.body.data.storageType);
    });
  });

  describe('DELETE /api/uploads/image', () => {
    it('should delete uploaded image', async () => {
      // First upload an image
      const testImage = Buffer.from(
        '/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAP/bAEMAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCAABAAEDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlbaWmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9/KKKKAP/2Q==',
        'base64'
      );

      const uploadRes = await request(app)
        .post('/api/uploads/image')
        .set('Authorization', `Bearer ${accessToken}`)
        .attach('image', testImage, 'test.jpg');

      const imageUrl = uploadRes.body.data.image_url;

      // Then delete it
      const deleteRes = await request(app)
        .delete('/api/uploads/image')
        .set('Authorization', `Bearer ${accessToken}`)
        .send({ imageUrl })
        .expect(200);

      assert.strictEqual(deleteRes.body.success, true);
    });
  });
});
</file>

<file path="backend/complete_backend_fix.sh">
#!/bin/bash
# Complete Backend Fix Script
# Run this from the backend directory

cd ~/project/dashboard/backend

echo "🔧 Creating all missing files..."

# ============================================
# 1. CREATE MISSING MIDDLEWARE FILES
# ============================================

# middleware/validate.js
cat > src/middleware/validate.js << 'EOF'
export function validate(schema) {
  return (req, res, next) => {
    const { error, value } = schema.validate(req.body, {
      abortEarly: false,
      stripUnknown: true,
    });

    if (error) {
      const errors = error.details.map((detail) => ({
        field: detail.path.join("."),
        message: detail.message,
      }));

      return res.status(400).json({
        success: false,
        message: "Validation failed",
        errors,
      });
    }

    req.body = value;
    next();
  };
}
EOF

# middleware/auth.js (FIXED)
cat > src/middleware/auth.js << 'EOF'
import { verifyToken } from "../utils/jwt.js";

export function authRequired(req, res, next) {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return res.status(401).json({ 
        success: false, 
        message: "No token provided" 
      });
    }

    const token = authHeader.substring(7);
    const decoded = verifyToken(token);
    
    req.user = {
      userId: decoded.userId,
      email: decoded.email,
      role: decoded.role,
    };
    
    next();
  } catch (error) {
    return res.status(401).json({ 
      success: false, 
      message: "Invalid or expired token" 
    });
  }
}

export default authRequired;
EOF

# ============================================
# 2. CREATE MISSING UTILS FILES
# ============================================

# utils/jwt.js
cat > src/utils/jwt.js << 'EOF'
import jwt from "jsonwebtoken";
import { config } from "../config/index.js";

export function signAccessToken(payload) {
  return jwt.sign(payload, config.jwt.secret, {
    expiresIn: config.jwt.accessTokenExpiry,
  });
}

export function signRefreshToken(payload) {
  return jwt.sign(payload, config.jwt.secret, {
    expiresIn: config.jwt.refreshTokenExpiry,
  });
}

export function verifyToken(token) {
  try {
    return jwt.verify(token, config.jwt.secret);
  } catch (error) {
    throw new Error("Invalid or expired token");
  }
}
EOF

# utils/ApiResponse.js
cat > src/utils/ApiResponse.js << 'EOF'
export class ApiResponse {
  static success(res, statusCode = 200, message = "Success", data = {}) {
    return res.status(statusCode).json({
      success: true,
      message,
      data,
    });
  }

  static created(res, message = "Created", data = {}) {
    return res.status(201).json({
      success: true,
      message,
      data,
    });
  }

  static paginated(res, data, page, limit, total, message = "Success") {
    return res.status(200).json({
      success: true,
      message,
      data,
      pagination: {
        page: parseInt(page, 10),
        limit: parseInt(limit, 10),
        total,
        pages: Math.ceil(total / limit),
      },
    });
  }
}
EOF

# utils/asyncHandler.js
cat > src/utils/asyncHandler.js << 'EOF'
export function asyncHandler(fn) {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}
EOF

# ============================================
# 3. FIX CONFIG FILES
# ============================================

# config/index.js (COMPLETE)
cat > src/config/index.js << 'EOF'
import dotenv from "dotenv";
dotenv.config();

export const config = {
  port: process.env.PORT || 5000,
  nodeEnv: process.env.NODE_ENV || "development",
  
  database: {
    url: process.env.DATABASE_URL,
    poolMax: 10,
    poolMin: 2,
    idleTimeout: 30000,
    connectionTimeout: 2000,
  },

  jwt: {
    secret: process.env.JWT_SECRET || "your-secret-key-change-in-production",
    accessTokenExpiry: process.env.ACCESS_TOKEN_EXP || "15m",
    refreshTokenExpiry: process.env.REFRESH_TOKEN_EXP || "7d",
  },

  cors: {
    origin: process.env.CORS_ORIGIN || "http://localhost:5173",
    credentials: true,
  },

  rateLimit: {
    windowMs: 15 * 60 * 1000,
    maxRequests: 100,
  },
};

// Legacy exports for backwards compatibility
export const DATABASE_URL = config.database.url;
export const JWT_SECRET = config.jwt.secret;
export const ACCESS_TOKEN_EXP = config.jwt.accessTokenExpiry;
export const REFRESH_TOKEN_EXP = config.jwt.refreshTokenExpiry;
EOF

# ============================================
# 4. FIX AUTH MODULE
# ============================================

# auth.service.js (COMPLETE)
cat > src/modules/auth/auth.service.js << 'EOF'
import bcrypt from "bcryptjs";
import { v4 as uuidv4 } from "uuid";
import db from "../../config/db.js";
import { signAccessToken, signRefreshToken, verifyToken } from "../../utils/jwt.js";
import { AppError } from "../../middleware/errorHandler.js";

export async function register({ email, password, fullName }) {
  const existing = await db.query(
    "SELECT id FROM users WHERE email = $1",
    [email]
  );

  if (existing.rows.length > 0) {
    throw new AppError("Email already registered", 400);
  }

  const passwordHash = await bcrypt.hash(password, 10);

  const result = await db.query(
    `INSERT INTO users (id, email, password_hash, full_name, role, created_at, updated_at)
     VALUES ($1, $2, $3, $4, $5, NOW(), NOW())
     RETURNING id, email, full_name, role, created_at`,
    [uuidv4(), email, passwordHash, fullName, "user"]
  );

  const user = result.rows[0];

  const accessToken = signAccessToken({ 
    userId: user.id, 
    email: user.email, 
    role: user.role 
  });
  
  const refreshToken = signRefreshToken({ 
    userId: user.id 
  });

  await db.query(
    `INSERT INTO refresh_tokens (id, token, user_id, expires_at, created_at)
     VALUES ($1, $2, $3, NOW() + INTERVAL '7 days', NOW())`,
    [uuidv4(), refreshToken, user.id]
  );

  return {
    user: {
      id: user.id,
      email: user.email,
      fullName: user.full_name,
      role: user.role,
    },
    accessToken,
    refreshToken,
  };
}

export async function login({ email, password }) {
  const result = await db.query(
    "SELECT id, email, password_hash, full_name, role, is_active FROM users WHERE email = $1",
    [email]
  );

  const user = result.rows[0];
  
  if (!user) {
    throw new AppError("Invalid email or password", 401);
  }

  if (!user.is_active) {
    throw new AppError("Account is disabled", 403);
  }

  const isValidPassword = await bcrypt.compare(password, user.password_hash);
  
  if (!isValidPassword) {
    throw new AppError("Invalid email or password", 401);
  }

  await db.query(
    "UPDATE users SET last_login_at = NOW() WHERE id = $1",
    [user.id]
  );

  const accessToken = signAccessToken({ 
    userId: user.id, 
    email: user.email, 
    role: user.role 
  });
  
  const refreshToken = signRefreshToken({ 
    userId: user.id 
  });

  await db.query(
    `INSERT INTO refresh_tokens (id, token, user_id, expires_at, created_at)
     VALUES ($1, $2, $3, NOW() + INTERVAL '7 days', NOW())`,
    [uuidv4(), refreshToken, user.id]
  );

  return {
    user: {
      id: user.id,
      email: user.email,
      fullName: user.full_name,
      role: user.role,
    },
    accessToken,
    refreshToken,
  };
}

export async function refreshAccessToken(refreshToken) {
  try {
    const decoded = verifyToken(refreshToken);

    const result = await db.query(
      "SELECT user_id, expires_at FROM refresh_tokens WHERE token = $1",
      [refreshToken]
    );

    if (result.rows.length === 0) {
      throw new AppError("Invalid refresh token", 401);
    }

    const tokenData = result.rows[0];

    if (new Date(tokenData.expires_at) < new Date()) {
      throw new AppError("Refresh token expired", 401);
    }

    const userResult = await db.query(
      "SELECT id, email, role FROM users WHERE id = $1 AND is_active = true",
      [tokenData.user_id]
    );

    if (userResult.rows.length === 0) {
      throw new AppError("User not found", 404);
    }

    const user = userResult.rows[0];

    const accessToken = signAccessToken({ 
      userId: user.id, 
      email: user.email, 
      role: user.role 
    });

    return { accessToken };
  } catch (error) {
    if (error instanceof AppError) throw error;
    throw new AppError("Invalid refresh token", 401);
  }
}

export async function logout(refreshToken) {
  await db.query(
    "DELETE FROM refresh_tokens WHERE token = $1",
    [refreshToken]
  );
}

export async function getCurrentUser(userId) {
  const result = await db.query(
    `SELECT id, email, full_name, role, is_email_verified, created_at, last_login_at
     FROM users WHERE id = $1`,
    [userId]
  );

  if (result.rows.length === 0) {
    throw new AppError("User not found", 404);
  }

  const user = result.rows[0];
  
  return {
    id: user.id,
    email: user.email,
    fullName: user.full_name,
    role: user.role,
    isEmailVerified: user.is_email_verified,
    createdAt: user.created_at,
    lastLoginAt: user.last_login_at,
  };
}

export async function changePassword(userId, currentPassword, newPassword) {
  const result = await db.query(
    "SELECT password_hash FROM users WHERE id = $1",
    [userId]
  );

  if (result.rows.length === 0) {
    throw new AppError("User not found", 404);
  }

  const user = result.rows[0];
  const isValidPassword = await bcrypt.compare(currentPassword, user.password_hash);

  if (!isValidPassword) {
    throw new AppError("Current password is incorrect", 400);
  }

  const newPasswordHash = await bcrypt.hash(newPassword, 10);

  await db.query(
    "UPDATE users SET password_hash = $1, updated_at = NOW() WHERE id = $2",
    [newPasswordHash, userId]
  );

  await db.query("DELETE FROM refresh_tokens WHERE user_id = $1", [userId]);
}
EOF

# auth.controller.js (COMPLETE)
cat > src/modules/auth/auth.controller.js << 'EOF'
import { asyncHandler } from "../../utils/asyncHandler.js";
import * as authService from "./auth.service.js";

export const register = asyncHandler(async (req, res) => {
  const result = await authService.register(req.body);

  res.status(201).json({
    success: true,
    message: "Registration successful",
    data: result,
  });
});

export const login = asyncHandler(async (req, res) => {
  const result = await authService.login(req.body);

  res.cookie("refreshToken", result.refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    maxAge: 7 * 24 * 60 * 60 * 1000,
  });

  res.json({
    success: true,
    message: "Login successful",
    data: {
      user: result.user,
      accessToken: result.accessToken,
    },
  });
});

export const refresh = asyncHandler(async (req, res) => {
  const { refreshToken } = req.body;

  if (!refreshToken) {
    return res.status(400).json({
      success: false,
      message: "Refresh token required",
    });
  }

  const result = await authService.refreshAccessToken(refreshToken);

  res.json({
    success: true,
    data: result,
  });
});

export const logout = asyncHandler(async (req, res) => {
  const { refreshToken } = req.body;

  if (refreshToken) {
    await authService.logout(refreshToken);
  }

  res.clearCookie("refreshToken");

  res.json({
    success: true,
    message: "Logout successful",
  });
});

export const getCurrentUser = asyncHandler(async (req, res) => {
  const user = await authService.getCurrentUser(req.user.userId);

  res.json({
    success: true,
    data: { user },
  });
});

export const changePassword = asyncHandler(async (req, res) => {
  const { currentPassword, newPassword } = req.body;

  await authService.changePassword(req.user.userId, currentPassword, newPassword);

  res.json({
    success: true,
    message: "Password changed successfully",
  });
});

export default {
  register,
  login,
  refresh,
  logout,
  getCurrentUser,
  changePassword,
};
EOF

# ============================================
# 5. CREATE ANALYTICS CONTROLLER
# ============================================

cat > src/modules/analytics/analytics.controller.js << 'EOF'
import { asyncHandler } from "../../utils/asyncHandler.js";
import * as analyticsService from "./analytics.service.js";

export const getQuestionAnalytics = asyncHandler(async (req, res) => {
  const { questionId } = req.params;
  const { startDate, endDate, countryCode } = req.query;

  const analytics = await analyticsService.getQuestionAnalytics(
    req.user.userId,
    questionId,
    { startDate, endDate, countryCode }
  );

  res.json({
    success: true,
    data: analytics,
  });
});

export const getOrganizationAnalytics = asyncHandler(async (req, res) => {
  const { organizationId } = req.params;

  const analytics = await analyticsService.getOrganizationAnalytics(
    req.user.userId,
    organizationId
  );

  res.json({
    success: true,
    data: analytics,
  });
});

export const recordResponse = asyncHandler(async (req, res) => {
  const result = await analyticsService.recordResponse(req.body);

  res.status(201).json({
    success: true,
    message: "Response recorded",
    data: result,
  });
});

export default {
  getQuestionAnalytics,
  getOrganizationAnalytics,
  recordResponse,
};
EOF

# ============================================
# 6. CREATE INTEGRATION CONTROLLER
# ============================================

cat > src/modules/integration/integration.controller.js << 'EOF'
import { asyncHandler } from "../../utils/asyncHandler.js";
import * as integrationService from "./integration.service.js";

export const registerSite = asyncHandler(async (req, res) => {
  const result = await integrationService.registerSite(req.user.userId, req.body);

  res.status(201).json({
    success: true,
    message: "Site registered successfully",
    data: result,
  });
});

export const getSiteStats = asyncHandler(async (req, res) => {
  const { siteKey } = req.params;

  const stats = await integrationService.getSiteStats(siteKey);

  res.json({
    success: true,
    data: stats,
  });
});

export const pushResponses = asyncHandler(async (req, res) => {
  const { siteKey, responses } = req.body;

  const result = await integrationService.pushResponses(siteKey, responses);

  res.status(201).json({
    success: true,
    message: "Responses recorded successfully",
    data: result,
  });
});

export const getActiveQuestions = asyncHandler(async (req, res) => {
  const { siteKey } = req.query;

  const questions = await integrationService.getActiveQuestions(siteKey);

  res.json({
    success: true,
    data: { questions },
  });
});

export default {
  registerSite,
  getSiteStats,
  pushResponses,
  getActiveQuestions,
};
EOF

# ============================================
# 7. FIX QUESTIONS SERVICE
# ============================================

cat > src/modules/questions/questions.service.js << 'EOF'
import { v4 as uuidv4 } from 'uuid';
import db from '../../config/db.js';
import { AppError } from '../../middleware/errorHandler.js';

class QuestionsService {
  async create(userId, data) {
    const orgCheck = await db.query(
      'SELECT id FROM organizations WHERE id = $1 AND owner_id = $2',
      [data.organizationId, userId]
    );

    if (orgCheck.rows.length === 0) {
      throw new AppError('Organization not found or access denied', 403);
    }

    const result = await db.query(
      `INSERT INTO questions (
        id, organization_id, question_text, question_type, 
        options, is_active, created_at, updated_at
      )
       VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
       RETURNING *`,
      [
        uuidv4(),
        data.organizationId,
        data.questionText,
        data.questionType,
        JSON.stringify(data.options || []),
        data.isActive !== false,
      ]
    );

    const question = result.rows[0];
    question.options = JSON.parse(question.options);
    return question;
  }

  async getAll(userId, filters = {}, page = 1, limit = 10) {
    const offset = (page - 1) * limit;
    let whereClause = 'WHERE o.owner_id = $1';
    const params = [userId];
    let paramIndex = 2;

    if (filters.organizationId) {
      whereClause += ` AND q.organization_id = $${paramIndex}`;
      params.push(filters.organizationId);
      paramIndex++;
    }

    if (filters.isActive !== undefined) {
      whereClause += ` AND q.is_active = $${paramIndex}`;
      params.push(filters.isActive);
      paramIndex++;
    }

    const countResult = await db.query(
      `SELECT COUNT(*) FROM questions q
       JOIN organizations o ON q.organization_id = o.id
       ${whereClause}`,
      params
    );

    params.push(limit, offset);

    const result = await db.query(
      `SELECT q.*, o.name as organization_name
       FROM questions q
       JOIN organizations o ON q.organization_id = o.id
       ${whereClause}
       ORDER BY q.created_at DESC
       LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`,
      params
    );

    const questions = result.rows.map(q => ({
      ...q,
      options: JSON.parse(q.options),
    }));

    return {
      questions,
      total: parseInt(countResult.rows[0].count, 10),
    };
  }

  async getById(questionId, userId) {
    const result = await db.query(
      `SELECT q.*, o.name as organization_name
       FROM questions q
       JOIN organizations o ON q.organization_id = o.id
       WHERE q.id = $1 AND o.owner_id = $2`,
      [questionId, userId]
    );

    if (result.rows.length === 0) {
      throw new AppError('Question not found', 404);
    }

    const question = result.rows[0];
    question.options = JSON.parse(question.options);
    return question;
  }

  async update(questionId, userId, updates) {
    await this.getById(questionId, userId);

    const setClauses = [];
    const params = [];
    let paramIndex = 1;

    if (updates.questionText) {
      setClauses.push(`question_text = $${paramIndex}`);
      params.push(updates.questionText);
      paramIndex++;
    }

    if (updates.questionType) {
      setClauses.push(`question_type = $${paramIndex}`);
      params.push(updates.questionType);
      paramIndex++;
    }

    if (updates.options) {
      setClauses.push(`options = $${paramIndex}`);
      params.push(JSON.stringify(updates.options));
      paramIndex++;
    }

    if (updates.isActive !== undefined) {
      setClauses.push(`is_active = $${paramIndex}`);
      params.push(updates.isActive);
      paramIndex++;
    }

    setClauses.push(`updated_at = NOW()`);
    params.push(questionId);

    const result = await db.query(
      `UPDATE questions 
       SET ${setClauses.join(', ')}
       WHERE id = $${paramIndex}
       RETURNING *`,
      params
    );

    const question = result.rows[0];
    question.options = JSON.parse(question.options);
    return question;
  }

  async delete(questionId, userId) {
    await this.getById(questionId, userId);
    await db.query('DELETE FROM questions WHERE id = $1', [questionId]);
  }
}

export default new QuestionsService();
EOF

# ============================================
# 8. FIX ORGANIZATIONS ROUTES
# ============================================

cat > src/modules/organizations/organizations.routes.js << 'EOF'
import { Router } from 'express';
import organizationsController from './organizations.controller.js';
import { validate } from '../../middleware/validate.js';
import { authRequired } from '../../middleware/auth.js';
import { createOrganizationSchema, updateOrganizationSchema } from './organizations.validation.js';

const router = Router();

router.use(authRequired);

router.post('/', validate(createOrganizationSchema), organizationsController.create);
router.get('/', organizationsController.getAll);
router.get('/:id', organizationsController.getById);
router.put('/:id', validate(updateOrganizationSchema), organizationsController.update);
router.delete('/:id', organizationsController.delete);

export default router;
EOF

# ============================================
# 9. FIX QUESTIONS ROUTES
# ============================================

cat > src/modules/questions/questions.routes.js << 'EOF'
import { Router } from 'express';
import questionsController from './questions.controller.js';
import { validate } from '../../middleware/validate.js';
import { authRequired } from '../../middleware/auth.js';
import { createQuestionSchema, updateQuestionSchema } from './questions.validation.js';

const router = Router();

router.use(authRequired);

router.post('/', validate(createQuestionSchema), questionsController.create);
router.get('/', questionsController.getAll);
router.get('/:id', questionsController.getById);
router.put('/:id', validate(updateQuestionSchema), questionsController.update);
router.delete('/:id', questionsController.delete);

export default router;
EOF

# ============================================
# 10. FIX ROUTES INDEX
# ============================================

cat > src/routes/index.js << 'EOF'
import { Router } from "express";
import authRoutes from "../modules/auth/auth.routes.js";
import organizationsRoutes from "../modules/organizations/organizations.routes.js";
import questionsRoutes from "../modules/questions/questions.routes.js";
import analyticsRoutes from "../modules/analytics/analytics.routes.js";
import integrationRoutes from "../modules/integration/integration.routes.js";

const router = Router();

router.get("/", (req, res) => {
  res.json({
    success: true,
    message: "Survay CAPTCHA Dashboard API",
    version: "1.0.0",
    endpoints: {
      auth: "/api/auth",
      organizations: "/api/organizations",
      questions: "/api/questions",
      analytics: "/api/analytics",
      integration: "/api/integration",
    },
  });
});

router.use("/auth", authRoutes);
router.use("/organizations", organizationsRoutes);
router.use("/questions", questionsRoutes);
router.use("/analytics", analyticsRoutes);
router.use("/integration", integrationRoutes);

router.get("/health", (req, res) => {
  res.json({ 
    success: true, 
    status: "healthy",
    timestamp: new Date().toISOString(),
  });
});

export default router;
EOF

echo "✅ All files created successfully!"
echo ""
echo "🔧 Now running migrations and starting server..."

# Reset database
PGPASSWORD=H@bib123 psql -U postgres -d dashboard -c "DROP TABLE IF EXISTS migrations CASCADE;" 2>/dev/null || true

# Run migrations
npm run migrate

# Start server
echo ""
echo "🚀 Starting server..."
npm start
EOF

chmod +x complete_backend_fix.sh
</file>

<file path="backend/Dockerfile">
# ============================================
# Multi-stage Dockerfile for production
# ============================================
FROM node:18-alpine AS base
WORKDIR /app
RUN apk add --no-cache postgresql-client wget

# Dependencies stage
FROM base AS deps
COPY package*.json ./
RUN npm ci --only=production

# Development stage
FROM base AS dev
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 5000
CMD ["npm", "run", "dev"]

# Production stage
FROM base AS prod
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN rm -f .env
EXPOSE 5000
USER node
CMD ["npm", "start"]
</file>

<file path="backend/Dockerfile.nosharp">
# ============================================
# FILE: backend/Dockerfile.nosharp (ALTERNATIVE)
# Lightweight build without image processing
# Use this if you handle images client-side only
# ============================================

FROM node:18-alpine AS base
WORKDIR /app
RUN apk add --no-cache postgresql-client wget

# Dependencies stage
FROM base AS deps
COPY package*.json ./

# Remove sharp and multer from dependencies before install
RUN npm pkg delete dependencies.sharp dependencies.multer dependencies.@aws-sdk/client-s3 && \
    npm ci --only=production && \
    npm cache clean --force

# Development stage
FROM base AS dev
COPY package*.json ./
RUN npm pkg delete dependencies.sharp dependencies.multer dependencies.@aws-sdk/client-s3 && \
    npm install && \
    npm cache clean --force
COPY . .
EXPOSE 5000
CMD ["npm", "run", "dev"]

# Production stage
FROM base AS prod
COPY --from=deps /app/node_modules ./node_modules
COPY --from=deps /app/package*.json ./
COPY . .

RUN rm -f .env

EXPOSE 5000
USER node

HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD wget --quiet --tries=1 --spider http://localhost:5000/api/health || exit 1

CMD ["npm", "start"]

# ============================================
# USAGE:
# docker build -f Dockerfile.nosharp -t dashboard-api:nosharp .
# 
# NOTE: With this image, you must:
# 1. Remove IMAGE_STORAGE, IMAGE_* env vars
# 2. Handle image compression client-side
# 3. Pass image_url directly to Micro-Survey API
# ============================================
</file>

<file path="backend/package.json">
{
  "name": "survay-captcha-dashboard-backend",
  "version": "2.0.0",
  "description": "Dashboard backend for Survey SaaS platform with Micro-Survey integration",
  "type": "module",
  "main": "src/server.js",
  "scripts": {
    "start": "NODE_ENV=development node src/server.js",
    "dev": "NODE_ENV=development nodemon src/server.js",
    "migrate": "node src/migrations/run.js",
    "test": "NODE_ENV=test node --experimental-vm-modules node_modules/jest/bin/jest.js",
    "test:watch": "npm run test -- --watch",
    "test:coverage": "npm run test -- --coverage",
    "lint": "eslint src/",
    "lint:fix": "eslint src/ --fix"
  },
  "keywords": ["survey", "saas", "dashboard", "nodejs", "express"],
  "author": "Your Team",
  "license": "MIT",
  "dependencies": {
    "express": "^4.18.2",
    "pg": "^8.11.3",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "joi": "^17.12.0",
    "dotenv": "^16.3.1",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "express-rate-limit": "^7.1.5",
    "rate-limit-redis": "^4.2.0",
    "ioredis": "^5.3.2",
    "pino": "^8.17.2",
    "pino-pretty": "^10.3.1",
    "uuid": "^9.0.1",
    "compression": "^1.7.4",
    "cookie-parser": "^1.4.6",
    "morgan": "^1.10.0",
    "axios": "^1.6.5",
    "bullmq": "^5.1.0",
    "winston": "^3.11.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.2",
    "eslint": "^8.56.0",
    "jest": "^29.7.0",
    "supertest": "^7.0.0",
    "@types/jest": "^29.5.11"
  },
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  }
}
</file>

<file path="frontend/src/components/layout/DashboardLayout.jsx">
// frontend/src/components/layout/DashboardLayout.jsx
import React, { useState } from 'react';
import { Outlet } from 'react-router-dom';
import Sidebar from './Sidebar';
import Topbar from './Topbar';

export default function DashboardLayout() {
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const [mobileSidebarOpen, setMobileSidebarOpen] = useState(false);

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Mobile sidebar backdrop */}
      {mobileSidebarOpen && (
        <div
          className="fixed inset-0 bg-gray-900 bg-opacity-50 z-40 lg:hidden"
          onClick={() => setMobileSidebarOpen(false)}
        />
      )}

      {/* Sidebar */}
      <Sidebar
        isOpen={sidebarOpen}
        isMobileOpen={mobileSidebarOpen}
        onClose={() => setMobileSidebarOpen(false)}
      />

      {/* Main content area */}
      <div
        className={`transition-all duration-300 ${
          sidebarOpen ? 'lg:ml-64' : 'lg:ml-20'
        }`}
      >
        {/* Top navigation bar */}
        <Topbar
          onToggleSidebar={() => setSidebarOpen(!sidebarOpen)}
          onToggleMobileSidebar={() => setMobileSidebarOpen(true)}
        />

        {/* Page content */}
        <main className="p-4 lg:p-8">
          <Outlet />
        </main>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/layout/Sidebar.jsx">
// ============================================
// FILE: frontend/src/components/layout/Sidebar.jsx (NEW)
// Complete sidebar navigation component
// ============================================
import React from 'react';
import { Link, useLocation } from 'react-router-dom';

export default function Sidebar({ isOpen, isMobileOpen, onClose }) {
  const location = useLocation();

  const navigation = [
    {
      name: 'Dashboard',
      icon: '📊',
      href: '/dashboard',
      active: location.pathname === '/dashboard',
    },
    {
      name: 'Organizations',
      icon: '🏢',
      href: '/organizations',
      active: location.pathname.startsWith('/organizations'),
    },
    {
      name: 'Questions',
      icon: '📝',
      href: '/questions',
      active: location.pathname.startsWith('/questions'),
    },
    {
      name: 'Surveys',
      icon: '📋',
      href: '/surveys',
      active: location.pathname.startsWith('/surveys'),
    },
    {
      name: 'Analytics',
      icon: '📈',
      href: '/analytics',
      active: location.pathname.startsWith('/analytics'),
    },
    {
      name: 'API Keys',
      icon: '🔑',
      href: '/api-keys',
      active: location.pathname.startsWith('/api-keys'),
    },
    {
      name: 'Webhooks',
      icon: '🔗',
      href: '/webhooks',
      active: location.pathname.startsWith('/webhooks'),
    },
    {
      name: 'Settings',
      icon: '⚙️',
      href: '/settings',
      active: location.pathname.startsWith('/settings'),
    },
  ];

  return (
    <>
      {/* Desktop sidebar */}
      <aside
        className={`fixed top-0 left-0 h-full bg-white border-r border-gray-200 z-50 transition-all duration-300 hidden lg:block ${
          isOpen ? 'w-64' : 'w-20'
        }`}
      >
        <div className="flex flex-col h-full">
          {/* Logo */}
          <div className="flex items-center justify-center h-16 border-b border-gray-200">
            <div className="flex items-center gap-3 px-4">
              <div className="text-3xl">📊</div>
              {isOpen && (
                <div className="font-bold text-xl text-gray-900 whitespace-nowrap">
                  Dashboard
                </div>
              )}
            </div>
          </div>

          {/* Navigation */}
          <nav className="flex-1 overflow-y-auto py-4">
            {navigation.map((item) => (
              <Link
                key={item.name}
                to={item.href}
                className={`flex items-center gap-3 px-4 py-3 mx-2 rounded-lg transition-colors ${
                  item.active
                    ? 'bg-blue-50 text-blue-600 font-medium'
                    : 'text-gray-700 hover:bg-gray-50'
                }`}
                title={!isOpen ? item.name : undefined}
              >
                <span className="text-2xl">{item.icon}</span>
                {isOpen && <span>{item.name}</span>}
              </Link>
            ))}
          </nav>

          {/* Footer */}
          <div className="border-t border-gray-200 p-4">
            <div className="text-sm text-gray-500 text-center">
              {isOpen ? 'v2.0.0' : 'v2'}
            </div>
          </div>
        </div>
      </aside>

      {/* Mobile sidebar */}
      <aside
        className={`fixed top-0 left-0 h-full w-64 bg-white border-r border-gray-200 z-50 transition-transform duration-300 lg:hidden ${
          isMobileOpen ? 'translate-x-0' : '-translate-x-full'
        }`}
      >
        <div className="flex flex-col h-full">
          {/* Logo & Close button */}
          <div className="flex items-center justify-between h-16 border-b border-gray-200 px-4">
            <div className="flex items-center gap-3">
              <div className="text-3xl">📊</div>
              <div className="font-bold text-xl text-gray-900">Dashboard</div>
            </div>
            <button
              onClick={onClose}
              className="p-2 rounded-lg hover:bg-gray-100"
              aria-label="Close menu"
            >
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>

          {/* Navigation */}
          <nav className="flex-1 overflow-y-auto py-4">
            {navigation.map((item) => (
              <Link
                key={item.name}
                to={item.href}
                onClick={onClose}
                className={`flex items-center gap-3 px-4 py-3 mx-2 rounded-lg transition-colors ${
                  item.active
                    ? 'bg-blue-50 text-blue-600 font-medium'
                    : 'text-gray-700 hover:bg-gray-50'
                }`}
              >
                <span className="text-2xl">{item.icon}</span>
                <span>{item.name}</span>
              </Link>
            ))}
          </nav>
        </div>
      </aside>
    </>
  );
}
</file>

<file path="frontend/src/components/layout/Topbar.jsx">
// frontend/src/components/layout/Topbar.jsx
import React, { useState, useContext, useRef, useEffect } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { AuthContext } from '../../context/AuthContext';

export default function Topbar({ onToggleSidebar, onToggleMobileSidebar }) {
  const { user, logout } = useContext(AuthContext);
  const navigate = useNavigate();
  const [userMenuOpen, setUserMenuOpen] = useState(false);
  const menuRef = useRef(null);

  // Close menu on outside click
  useEffect(() => {
    function handleClickOutside(event) {
      if (menuRef.current && !menuRef.current.contains(event.target)) {
        setUserMenuOpen(false);
      }
    }
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  async function handleLogout() {
    await logout();
    navigate('/login');
  }

  const userInitials = user?.fullName
    ?.split(' ')
    .map(n => n[0])
    .join('')
    .toUpperCase() || user?.email?.[0]?.toUpperCase() || 'U';

  return (
    <header className="h-16 bg-white border-b border-gray-200 sticky top-0 z-30">
      <div className="h-full flex items-center justify-between px-4 lg:px-8">
        {/* Left section */}
        <div className="flex items-center gap-4">
          {/* Mobile menu button */}
          <button
            onClick={onToggleMobileSidebar}
            className="p-2 rounded-lg hover:bg-gray-100 transition-colors lg:hidden"
            aria-label="Open menu"
          >
            <svg className="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
            </svg>
          </button>

          {/* Desktop sidebar toggle */}
          <button
            onClick={onToggleSidebar}
            className="hidden lg:block p-2 rounded-lg hover:bg-gray-100 transition-colors"
            aria-label="Toggle sidebar"
          >
            <svg className="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
            </svg>
          </button>

          {/* Search bar (placeholder) */}
          <div className="hidden md:flex items-center gap-2 bg-gray-100 rounded-lg px-4 py-2 w-64 lg:w-96">
            <svg className="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
            <input
              type="text"
              placeholder="Search..."
              className="bg-transparent border-none outline-none text-gray-700 placeholder-gray-400 w-full"
            />
          </div>
        </div>

        {/* Right section */}
        <div className="flex items-center gap-4">
          {/* Notifications button (placeholder) */}
          <button
            className="relative p-2 rounded-lg hover:bg-gray-100 transition-colors"
            aria-label="Notifications"
          >
            <svg className="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" />
            </svg>
            {/* Notification badge */}
            <span className="absolute top-1 right-1 w-2 h-2 bg-red-500 rounded-full"></span>
          </button>

          {/* User menu */}
          <div className="relative" ref={menuRef}>
            <button
              onClick={() => setUserMenuOpen(!userMenuOpen)}
              className="flex items-center gap-3 p-2 rounded-lg hover:bg-gray-100 transition-colors"
              aria-label="User menu"
            >
              {/* Avatar */}
              <div className="w-9 h-9 bg-gradient-to-br from-blue-600 to-purple-600 rounded-full flex items-center justify-center">
                <span className="text-white font-semibold text-sm">{userInitials}</span>
              </div>

              {/* User info - hidden on mobile */}
              <div className="hidden lg:block text-left">
                <div className="text-sm font-medium text-gray-900">
                  {user?.fullName || 'User'}
                </div>
                <div className="text-xs text-gray-500">
                  {user?.email}
                </div>
              </div>

              {/* Chevron */}
              <svg
                className={`w-5 h-5 text-gray-400 transition-transform ${
                  userMenuOpen ? 'rotate-180' : ''
                }`}
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
              </svg>
            </button>

            {/* Dropdown menu */}
            {userMenuOpen && (
              <div className="absolute right-0 mt-2 w-56 bg-white rounded-lg shadow-xl border border-gray-200 py-2 z-50">
                {/* User info in dropdown (mobile only) */}
                <div className="lg:hidden px-4 py-3 border-b border-gray-100">
                  <div className="font-medium text-gray-900">{user?.fullName || 'User'}</div>
                  <div className="text-sm text-gray-500">{user?.email}</div>
                </div>

                <Link
                  to="/settings/profile"
                  className="flex items-center gap-3 px-4 py-2 text-gray-700 hover:bg-gray-50 transition-colors"
                  onClick={() => setUserMenuOpen(false)}
                >
                  <svg className="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                  </svg>
                  <span>Profile</span>
                </Link>

                <Link
                  to="/settings"
                  className="flex items-center gap-3 px-4 py-2 text-gray-700 hover:bg-gray-50 transition-colors"
                  onClick={() => setUserMenuOpen(false)}
                >
                  <svg className="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                  </svg>
                  <span>Settings</span>
                </Link>

                <div className="border-t border-gray-100 my-2"></div>

                <button
                  onClick={handleLogout}
                  className="flex items-center gap-3 px-4 py-2 text-red-600 hover:bg-red-50 transition-colors w-full text-left"
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                  </svg>
                  <span>Logout</span>
                </button>
              </div>
            )}
          </div>
        </div>
      </div>
    </header>
  );
}
</file>

<file path="frontend/src/components/questions/QuestionEditor.jsx">
// frontend/src/components/questions/QuestionEditor.jsx
import React, { useEffect, useState } from "react";
import { useParams, useNavigate } from "react-router-dom";
import { listQuestions, createQuestion } from "../../services/apiService";
import QuestionForm from "./QuestionForm";

export default function QuestionEditor() {
  const { id } = useParams();
  const navigate = useNavigate();
  const [initialData, setInitialData] = useState(null);

  async function loadExisting() {
    if (!id) return;
    try {
      const data = await listQuestions();
      const q = data.questions.find((x) => x.id.toString() === id);
      if (q) setInitialData(q);
    } catch (err) {
      alert(err.message);
    }
  }

  async function handleSave(formData) {
    try {
      await createQuestion(formData);
      navigate("/dashboard/questions/list");
    } catch (err) {
      alert(err.message);
    }
  }

  useEffect(() => {
    loadExisting();
  }, [id]);

  return (
    <div className="p-4">
      <h2 className="text-xl font-bold mb-4">
        {id ? "Edit Question" : "Create Question"}
      </h2>

      <QuestionForm initialData={initialData} onSubmit={handleSave} />
    </div>
  );
}
</file>

<file path="frontend/src/components/questions/QuestionForm.jsx">
// frontend/src/components/questions/QuestionForm.jsx
import React, { useState } from "react";

export default function QuestionForm({ initialData, onSubmit }) {
  const [text, setText] = useState(initialData?.text || "");
  const [options, setOptions] = useState(initialData?.options || [""]);

  function updateOption(index, value) {
    const copy = [...options];
    copy[index] = value;
    setOptions(copy);
  }

  function addOption() {
    setOptions([...options, ""]);
  }

  function removeOption(index) {
    setOptions(options.filter((_, i) => i !== index));
  }

  function handleSubmit(e) {
    e.preventDefault();
    if (!text.trim()) return alert("Question text required");
    if (options.filter((o) => o.trim()).length < 2)
      return alert("Minimum 2 options required");

    onSubmit({ text, options });
  }

  return (
    <form className="space-y-4" onSubmit={handleSubmit}>
      <div>
        <label className="block mb-1">Question Text</label>
        <input
          className="input"
          value={text}
          onChange={(e) => setText(e.target.value)}
          placeholder="Write your question here..."
        />
      </div>

      <div>
        <label className="block mb-1">Options</label>
        {options.map((opt, i) => (
          <div key={i} className="flex items-center mb-2">
            <input
              className="input flex-1"
              value={opt}
              onChange={(e) => updateOption(i, e.target.value)}
              placeholder={`Option ${i + 1}`}
            />
            {options.length > 1 && (
              <button
                type="button"
                className="ml-2 text-red-600"
                onClick={() => removeOption(i)}
              >
                X
              </button>
            )}
          </div>
        ))}

        <button
          type="button"
          onClick={addOption}
          className="btn-secondary mt-2"
        >
          + Add Option
        </button>
      </div>

      <button className="btn-primary">Save</button>
    </form>
  );
}
</file>

<file path="frontend/src/components/questions/QuestionList.jsx">
// frontend/src/components/questions/QuestionList.jsx
import React, { useEffect, useState } from "react";
import { listQuestions, deleteQuestion } from "../../services/apiService";
import { Link } from "react-router-dom";

export default function QuestionList() {
  const [questions, setQuestions] = useState([]);
  const [loading, setLoading] = useState(true);

  async function load() {
    try {
      const data = await listQuestions();
      setQuestions(data.questions || []);
    } catch (err) {
      alert(err.message);
    }
    setLoading(false);
  }

  async function handleDelete(id) {
    if (!confirm("Delete this question?")) return;
    try {
      await deleteQuestion(id);
      load();
    } catch (err) {
      alert(err.message);
    }
  }

  useEffect(() => {
    load();
  }, []);

  if (loading) return <p>Loading...</p>;

  return (
    <div className="p-4">
      <div className="flex justify-between mb-4">
        <h2 className="text-xl font-bold">Survey Questions</h2>
        <Link to="/dashboard/questions/new" className="btn-primary">
          + New Question
        </Link>
      </div>

      <table className="w-full border">
        <thead>
          <tr className="bg-gray-100">
            <th className="p-2">Question</th>
            <th className="p-2">Options</th>
            <th className="p-2">Actions</th>
          </tr>
        </thead>

        <tbody>
          {questions.map((q) => (
            <tr key={q.id} className="border-t">
              <td className="p-2">{q.text}</td>
              <td className="p-2">{q.options.join(", ")}</td>
              <td className="p-2">
                <Link
                  className="text-blue-600 mr-3"
                  to={`/dashboard/questions/${q.id}/edit`}
                >
                  Edit
                </Link>
                <button
                  onClick={() => handleDelete(q.id)}
                  className="text-red-600"
                >
                  Delete
                </button>
              </td>
            </tr>
          ))}

          {questions.length === 0 && (
            <tr>
              <td colSpan="3" className="p-4 text-center text-gray-500">
                No questions yet
              </td>
            </tr>
          )}
        </tbody>
      </table>
    </div>
  );
}
</file>

<file path="frontend/src/components/ui/ErrorBoundary.jsx">
// ============================================
// FILE: frontend/src/components/ui/ErrorBoundary.jsx (NEW)
// ============================================
import React from 'react';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen flex items-center justify-center bg-gray-50 px-4">
          <div className="text-center max-w-md">
            <div className="text-9xl mb-4">💥</div>
            <h1 className="text-3xl font-bold text-gray-900 mb-4">
              Something went wrong
            </h1>
            <p className="text-gray-600 mb-8">
              {this.state.error?.message || 'An unexpected error occurred'}
            </p>
            <button
              onClick={() => window.location.reload()}
              className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-medium"
            >
              Reload Page
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
</file>

<file path="frontend/src/components/ui/LoadingSpinner.jsx">
// frontend/src/components/ui/LoadingSpinner.jsx
import React from 'react';

export default function LoadingSpinner({ size = 'md', text = '' }) {
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-8 h-8',
    lg: 'w-12 h-12',
    xl: 'w-16 h-16',
  };

  return (
    <div className="flex flex-col items-center justify-center gap-3">
      <div
        className={`${sizeClasses[size]} border-4 border-gray-200 border-t-blue-600 rounded-full animate-spin`}
      ></div>
      {text && <p className="text-gray-600 text-sm">{text}</p>}
    </div>
  );
}

// Full page loading component
export function PageLoader({ text = 'Loading...' }) {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="text-center">
        <LoadingSpinner size="xl" />
        <p className="mt-4 text-gray-600 font-medium">{text}</p>
      </div>
    </div>
  );
}

// Inline loading component
export function InlineLoader({ text = 'Loading...' }) {
  return (
    <div className="flex items-center justify-center py-8">
      <LoadingSpinner size="md" text={text} />
    </div>
  );
}
</file>

<file path="frontend/src/components/Layout.jsx">
import React, { useContext } from "react";
import { Outlet, Link, useNavigate } from "react-router-dom";
import { AuthContext } from "../context/AuthContext";

export default function Layout() {
  const { user, logout } = useContext(AuthContext);
  const navigate = useNavigate();

  async function handleLogout() {
    await logout();
    navigate("/login");
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <nav className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between h-16">
            <div className="flex space-x-8">
              <Link to="/dashboard" className="flex items-center text-gray-900 font-semibold">
                Dashboard
              </Link>
              <Link to="/organizations" className="flex items-center text-gray-600 hover:text-gray-900">
                Organizations
              </Link>
              <Link to="/questions" className="flex items-center text-gray-600 hover:text-gray-900">
                Questions
              </Link>
            </div>
            <div className="flex items-center space-x-4">
              <span className="text-gray-700">{user?.email}</span>
              <button
                onClick={handleLogout}
                className="text-gray-600 hover:text-gray-900"
              >
                Logout
              </button>
            </div>
          </div>
        </div>
      </nav>
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <Outlet />
      </main>
    </div>
  );
}
</file>

<file path="frontend/src/components/ProtectedRoute.jsx">
// frontend/src/components/ProtectedRoute.jsx - ENHANCED
import React, { useContext } from "react";
import { Navigate, useLocation } from "react-router-dom";
import { AuthContext } from "../context/AuthContext";
import { PageLoader } from "./ui/LoadingSpinner";

export default function ProtectedRoute({ children, requireAuth = true }) {
  const { user, loading, isAuthenticated } = useContext(AuthContext);
  const location = useLocation();

  // Show loading spinner while checking authentication
  if (loading) {
    return <PageLoader text="Checking authentication..." />;
  }

  // Redirect to login if not authenticated and auth is required
  if (requireAuth && !isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  // Render children if authenticated or auth not required
  return children;
}
</file>

<file path="frontend/src/context/AuthContext.jsx">
// frontend/src/context/AuthContext.jsx - ENHANCED
import React, { createContext, useState, useEffect, useCallback } from "react";
import api from "../services/api";

export const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  // Check if access token exists and is valid
  const checkAuth = useCallback(async () => {
    const token = localStorage.getItem("accessToken");
    
    if (!token) {
      setLoading(false);
      return;
    }

    try {
      const response = await api.getCurrentUser();
      setUser(response.data.user);
      setIsAuthenticated(true);
    } catch (error) {
      console.error("Auth check failed:", error);
      
      // Try to refresh token
      const refreshToken = localStorage.getItem("refreshToken");
      if (refreshToken) {
        try {
          await refreshAccessToken();
        } catch (refreshError) {
          // Refresh failed, clear tokens
          localStorage.removeItem("accessToken");
          localStorage.removeItem("refreshToken");
          setIsAuthenticated(false);
        }
      }
    } finally {
      setLoading(false);
    }
  }, []);

  // Auto-refresh token before expiry
  useEffect(() => {
    checkAuth();

    // Set up auto-refresh every 10 minutes
    const refreshInterval = setInterval(async () => {
      const token = localStorage.getItem("accessToken");
      const refreshToken = localStorage.getItem("refreshToken");
      
      if (token && refreshToken) {
        try {
          await refreshAccessToken();
        } catch (error) {
          console.error("Auto-refresh failed:", error);
        }
      }
    }, 10 * 60 * 1000); // 10 minutes

    return () => clearInterval(refreshInterval);
  }, [checkAuth]);

  // Login function
  async function login(email, password) {
    try {
      const response = await api.login(email, password);
      setUser(response.data.user);
      setIsAuthenticated(true);
      return response;
    } catch (error) {
      throw error;
    }
  }

  // Register function
  async function register(email, password, fullName) {
    try {
      const response = await api.register(email, password, fullName);
      setUser(response.data.user);
      setIsAuthenticated(true);
      return response;
    } catch (error) {
      throw error;
    }
  }

  // Refresh access token
  async function refreshAccessToken() {
    const refreshToken = localStorage.getItem("refreshToken");
    
    if (!refreshToken) {
      throw new Error("No refresh token available");
    }

    try {
      const response = await fetch(`${api.baseUrl}/auth/refresh`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ refreshToken }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || "Token refresh failed");
      }

      // Update access token
      api.setToken(data.data.accessToken);
      
      return data;
    } catch (error) {
      console.error("Token refresh error:", error);
      throw error;
    }
  }

  // Logout function
  async function logout() {
    try {
      const refreshToken = localStorage.getItem("refreshToken");
      if (refreshToken) {
        await api.logout(refreshToken);
      }
    } catch (error) {
      console.error("Logout error:", error);
    } finally {
      setUser(null);
      setIsAuthenticated(false);
      localStorage.removeItem("accessToken");
      localStorage.removeItem("refreshToken");
    }
  }

  // Update user data
  function updateUser(userData) {
    setUser(prevUser => ({
      ...prevUser,
      ...userData,
    }));
  }

  const value = {
    user,
    loading,
    isAuthenticated,
    login,
    register,
    logout,
    refresh: refreshAccessToken,
    setUser: updateUser,
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}
</file>

<file path="frontend/src/hooks/useAuth.js">
// frontend/src/hooks/useAuth.js
import { useContext } from 'react';
import { AuthContext } from '../context/AuthContext';

/**
 * Custom hook to access authentication context
 * Throws error if used outside AuthProvider
 */
export function useAuth() {
  const context = useContext(AuthContext);
  
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  
  return context;
}

export default useAuth;
</file>

<file path="frontend/src/pages/dashboard/analytics/AnalyticsOverview.jsx">
// ============================================
// FILE: frontend/src/pages/dashboard/analytics/AnalyticsOverview.jsx
// Main analytics overview page
// ============================================
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import api from '../../../services/api';
import LoadingSpinner from '../../../components/ui/LoadingSpinner';

export default function AnalyticsOverview() {
  const [surveys, setSurveys] = useState([]);
  const [stats, setStats] = useState({
    totalSurveys: 0,
    totalResponses: 0,
    avgCompletionRate: 0,
    activeThisWeek: 0,
  });
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadData();
  }, []);

  async function loadData() {
    try {
      const [surveysRes] = await Promise.all([
        api.getSurveys({ status: 'published' }),
      ]);

      const surveysData = surveysRes.data.surveys || [];
      setSurveys(surveysData);

      // Calculate aggregate stats
      const totalResponses = surveysData.reduce((sum, s) => sum + (s.response_count || 0), 0);
      const avgRate = surveysData.length > 0
        ? surveysData.reduce((sum, s) => sum + parseFloat(s.completion_rate || 0), 0) / surveysData.length
        : 0;

      setStats({
        totalSurveys: surveysData.length,
        totalResponses,
        avgCompletionRate: avgRate.toFixed(1),
        activeThisWeek: surveysData.filter(s => {
          const created = new Date(s.created_at);
          const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
          return created > weekAgo;
        }).length,
      });
    } catch (error) {
      console.error('Failed to load analytics:', error);
    } finally {
      setLoading(false);
    }
  }

  if (loading) {
    return (
      <div className="flex items-center justify-center h-64">
        <LoadingSpinner size="lg" text="Loading analytics..." />
      </div>
    );
  }

  return (
    <div>
      {/* Header */}
      <div className="mb-8">
        <h1 className="text-3xl font-bold text-gray-900">Analytics Overview</h1>
        <p className="text-gray-600 mt-2">Track performance across all your surveys</p>
      </div>

      {/* Key Metrics */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-6 mb-8">
        <MetricCard
          title="Total Surveys"
          value={stats.totalSurveys}
          icon="📋"
          color="blue"
        />
        <MetricCard
          title="Total Responses"
          value={stats.totalResponses}
          icon="💬"
          color="green"
        />
        <MetricCard
          title="Avg Completion Rate"
          value={`${stats.avgCompletionRate}%`}
          icon="✅"
          color="purple"
        />
        <MetricCard
          title="Active This Week"
          value={stats.activeThisWeek}
          icon="🔥"
          color="orange"
        />
      </div>

      {/* Top Surveys */}
      <div className="bg-white rounded-xl shadow-lg p-6 border-2 border-gray-100 mb-8">
        <h2 className="text-xl font-bold text-gray-900 mb-4">Top Performing Surveys</h2>
        
        {surveys.length === 0 ? (
          <div className="text-center py-12">
            <div className="text-6xl mb-4">📊</div>
            <p className="text-gray-600 mb-4">No published surveys yet</p>
            <Link
              to="/surveys/new"
              className="inline-block bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700"
            >
              Create Your First Survey
            </Link>
          </div>
        ) : (
          <div className="space-y-3">
            {surveys.slice(0, 5).map((survey) => (
              <Link
                key={survey.id}
                to={`/analytics/surveys/${survey.id}`}
                className="block p-4 border-2 border-gray-200 rounded-lg hover:border-blue-300 hover:bg-blue-50 transition-colors"
              >
                <div className="flex items-center justify-between">
                  <div className="flex-1">
                    <h3 className="font-semibold text-gray-900">{survey.title}</h3>
                    <div className="flex items-center gap-4 mt-2 text-sm text-gray-600">
                      <span>👁️ {survey.response_count || 0} responses</span>
                      <span>•</span>
                      <span>✅ {survey.completion_rate || 0}% completion</span>
                    </div>
                  </div>
                  <div className="text-blue-600">→</div>
                </div>
              </Link>
            ))}
          </div>
        )}
      </div>

      {/* Recent Activity */}
      <div className="bg-white rounded-xl shadow-lg p-6 border-2 border-gray-100">
        <h2 className="text-xl font-bold text-gray-900 mb-4">Recent Activity</h2>
        <div className="space-y-3">
          {surveys.slice(0, 5).map((survey) => (
            <div key={survey.id} className="flex items-center gap-3 p-3 bg-gray-50 rounded-lg">
              <div className="w-10 h-10 bg-blue-100 rounded-full flex items-center justify-center text-blue-600 font-bold">
                {survey.title[0]}
              </div>
              <div className="flex-1">
                <div className="font-medium text-gray-900">{survey.title}</div>
                <div className="text-sm text-gray-500">
                  Published {new Date(survey.published_at).toLocaleDateString()}
                </div>
              </div>
              <Link
                to={`/analytics/surveys/${survey.id}`}
                className="text-blue-600 hover:text-blue-800 text-sm font-medium"
              >
                View Analytics →
              </Link>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

function MetricCard({ title, value, icon, color }) {
  const colorClasses = {
    blue: 'bg-blue-500',
    green: 'bg-green-500',
    purple: 'bg-purple-500',
    orange: 'bg-orange-500',
  };

  return (
    <div className="bg-white rounded-xl shadow-lg p-6 border-2 border-gray-100">
      <div className="flex items-center justify-between mb-4">
        <div className="text-3xl">{icon}</div>
        <div className={`w-3 h-3 rounded-full ${colorClasses[color]}`}></div>
      </div>
      <div className="text-3xl font-bold text-gray-900 mb-1">{value}</div>
      <div className="text-sm text-gray-600">{title}</div>
    </div>
  );
}
</file>

<file path="frontend/src/pages/errors/NotFound.jsx">
// frontend/src/pages/errors/NotFound.jsx
import React from 'react';
import { Link } from 'react-router-dom';

export function NotFound() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 px-4">
      <div className="text-center max-w-md">
        <div className="text-9xl font-bold text-blue-600 mb-4">404</div>
        <h1 className="text-3xl font-bold text-gray-900 mb-4">
          Page Not Found
        </h1>
        <p className="text-gray-600 mb-8">
          The page you're looking for doesn't exist or has been moved.
        </p>
        <div className="flex gap-4 justify-center">
          <Link
            to="/dashboard"
            className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-medium"
          >
            Go to Dashboard
          </Link>
          <button
            onClick={() => window.history.back()}
            className="px-6 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors font-medium"
          >
            Go Back
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/pages/errors/Unauthorized.jsx">
// frontend/src/pages/errors/Unauthorized.jsx
export function Unauthorized() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 px-4">
      <div className="text-center max-w-md">
        <div className="text-9xl font-bold text-red-600 mb-4">403</div>
        <h1 className="text-3xl font-bold text-gray-900 mb-4">
          Access Denied
        </h1>
        <p className="text-gray-600 mb-8">
          You don't have permission to access this page. Please contact your administrator if you believe this is an error.
        </p>
        <div className="flex gap-4 justify-center">
          <Link
            to="/dashboard"
            className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-medium"
          >
            Go to Dashboard
          </Link>
          <Link
            to="/login"
            className="px-6 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors font-medium"
          >
            Login Again
          </Link>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/pages/Analytics.jsx">
import React from "react";
import { useParams } from "react-router-dom";

export default function AnalyticsPage() {
  const { questionId } = useParams();

  return (
    <div>
      <h1 className="text-2xl font-bold mb-6">Analytics</h1>
      <div className="bg-white p-6 rounded-lg shadow">
        <p className="text-gray-600">
          Analytics for question: {questionId}
        </p>
        <p className="mt-4 text-sm text-gray-500">
          Analytics feature coming soon...
        </p>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/pages/Dashboard.jsx">
import React, { useState, useEffect, useContext } from "react";
import { Link } from "react-router-dom";
import { AuthContext } from "../context/AuthContext";
import api from "../services/api";

export default function DashboardPage() {
  const { user } = useContext(AuthContext);
  const [stats, setStats] = useState({
    organizations: 0,
    questions: 0,
    responses: 0,
  });
  const [recentQuestions, setRecentQuestions] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadDashboardData();
  }, []);

  async function loadDashboardData() {
    try {
      const [orgs, questions] = await Promise.all([
        api.getOrganizations(1, 100),
        api.getQuestions(),
      ]);

      setStats({
        organizations: orgs.data.total || 0,
        questions: questions.data.total || 0,
        responses: 0,
      });

      setRecentQuestions((questions.data.questions || []).slice(0, 5));
    } catch (error) {
      console.error("Failed to load stats:", error);
    } finally {
      setLoading(false);
    }
  }

  if (loading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
          <p className="mt-4 text-gray-600">Loading dashboard...</p>
        </div>
      </div>
    );
  }

  return (
    <div>
      {/* Welcome Header */}
      <div className="mb-8">
        <h1 className="text-3xl font-bold text-gray-900">
          Welcome back, {user?.fullName || user?.email?.split('@')[0] || 'User'}! 👋
        </h1>
        <p className="text-gray-600 mt-2">
          Here's what's happening with your surveys today
        </p>
      </div>

      {/* Stats Grid */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
        <div className="bg-gradient-to-br from-blue-500 to-blue-600 rounded-xl shadow-lg p-6 text-white">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-blue-100 text-sm font-medium">Organizations</p>
              <p className="text-4xl font-bold mt-2">{stats.organizations}</p>
              <p className="text-blue-100 text-sm mt-2">Total active</p>
            </div>
            <div className="text-6xl opacity-20">🏢</div>
          </div>
          <Link
            to="/organizations"
            className="mt-4 inline-block text-sm text-blue-100 hover:text-white underline"
          >
            Manage organizations →
          </Link>
        </div>

        <div className="bg-gradient-to-br from-green-500 to-green-600 rounded-xl shadow-lg p-6 text-white">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-green-100 text-sm font-medium">Questions</p>
              <p className="text-4xl font-bold mt-2">{stats.questions}</p>
              <p className="text-green-100 text-sm mt-2">Survey questions</p>
            </div>
            <div className="text-6xl opacity-20">📝</div>
          </div>
          <Link
            to="/questions"
            className="mt-4 inline-block text-sm text-green-100 hover:text-white underline"
          >
            View all questions →
          </Link>
        </div>

        <div className="bg-gradient-to-br from-purple-500 to-purple-600 rounded-xl shadow-lg p-6 text-white">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-purple-100 text-sm font-medium">Responses</p>
              <p className="text-4xl font-bold mt-2">{stats.responses}</p>
              <p className="text-purple-100 text-sm mt-2">Total collected</p>
            </div>
            <div className="text-6xl opacity-20">📊</div>
          </div>
          <div className="mt-4 text-sm text-purple-100">
            Coming soon
          </div>
        </div>
      </div>

      {/* Quick Actions */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
        <div className="bg-white rounded-xl shadow-lg p-6 border-2 border-gray-100">
          <h2 className="text-xl font-bold text-gray-900 mb-4 flex items-center gap-2">
            <span className="text-2xl">⚡</span>
            Quick Actions
          </h2>
          <div className="space-y-3">
            <Link
              to="/questions/new"
              className="block p-4 bg-blue-50 hover:bg-blue-100 rounded-lg transition-colors border-2 border-blue-200"
            >
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 bg-blue-600 rounded-lg flex items-center justify-center text-white text-xl">
                  +
                </div>
                <div>
                  <div className="font-semibold text-gray-900">Create Question</div>
                  <div className="text-sm text-gray-600">Build a new survey question</div>
                </div>
              </div>
            </Link>

            <Link
              to="/organizations"
              className="block p-4 bg-green-50 hover:bg-green-100 rounded-lg transition-colors border-2 border-green-200"
            >
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 bg-green-600 rounded-lg flex items-center justify-center text-white text-xl">
                  🏢
                </div>
                <div>
                  <div className="font-semibold text-gray-900">Manage Organizations</div>
                  <div className="text-sm text-gray-600">View and edit organizations</div>
                </div>
              </div>
            </Link>

            <Link
              to="/questions"
              className="block p-4 bg-purple-50 hover:bg-purple-100 rounded-lg transition-colors border-2 border-purple-200"
            >
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 bg-purple-600 rounded-lg flex items-center justify-center text-white text-xl">
                  📋
                </div>
                <div>
                  <div className="font-semibold text-gray-900">View All Questions</div>
                  <div className="text-sm text-gray-600">Browse your question library</div>
                </div>
              </div>
            </Link>
          </div>
        </div>

        {/* Recent Questions */}
        <div className="bg-white rounded-xl shadow-lg p-6 border-2 border-gray-100">
          <h2 className="text-xl font-bold text-gray-900 mb-4 flex items-center gap-2">
            <span className="text-2xl">📝</span>
            Recent Questions
          </h2>
          {recentQuestions.length === 0 ? (
            <div className="text-center py-8">
              <div className="text-4xl mb-2">🎯</div>
              <p className="text-gray-600 mb-4">No questions yet</p>
              <Link
                to="/questions/new"
                className="inline-block bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700"
              >
                Create Your First Question
              </Link>
            </div>
          ) : (
            <div className="space-y-3">
              {recentQuestions.map((q) => (
                <div
                  key={q.id}
                  className="p-3 border-2 border-gray-200 rounded-lg hover:border-blue-300 transition-colors"
                >
                  <div className="flex items-start justify-between">
                    <div className="flex-1">
                      <div className="font-medium text-gray-900 text-sm line-clamp-1">
                        {q.question_text}
                      </div>
                      <div className="flex items-center gap-2 mt-1">
                        <span className="text-xs text-gray-500">
                          {q.question_type === "multiple_choice" && "📋 Multiple Choice"}
                          {q.question_type === "text" && "✍️ Text"}
                          {q.question_type === "rating" && "⭐ Rating"}
                        </span>
                        <span
                          className={`text-xs px-2 py-0.5 rounded ${
                            q.is_active
                              ? "bg-green-100 text-green-700"
                              : "bg-gray-100 text-gray-700"
                          }`}
                        >
                          {q.is_active ? "Active" : "Inactive"}
                        </span>
                      </div>
                    </div>
                    <Link
                      to={`/questions/${q.id}/edit`}
                      className="ml-2 text-blue-600 hover:text-blue-800 text-sm"
                    >
                      Edit
                    </Link>
                  </div>
                </div>
              ))}
              <Link
                to="/questions"
                className="block text-center text-blue-600 hover:text-blue-800 text-sm font-medium pt-2"
              >
                View all questions →
              </Link>
            </div>
          )}
        </div>
      </div>

      {/* Getting Started Guide */}
      {stats.questions === 0 && (
        <div className="bg-gradient-to-r from-blue-50 to-purple-50 rounded-xl shadow-lg p-8 border-2 border-blue-200">
          <h2 className="text-2xl font-bold text-gray-900 mb-4 flex items-center gap-2">
            <span className="text-3xl">🚀</span>
            Getting Started
          </h2>
          <p className="text-gray-700 mb-6">
            Follow these steps to create your first survey question:
          </p>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div className="bg-white rounded-lg p-4 border-2 border-gray-200">
              <div className="w-8 h-8 bg-blue-600 text-white rounded-full flex items-center justify-center font-bold mb-3">
                1
              </div>
              <h3 className="font-semibold text-gray-900 mb-2">Create Organization</h3>
              <p className="text-sm text-gray-600">Set up your organization to group questions</p>
              <Link to="/organizations" className="text-blue-600 text-sm mt-2 inline-block">
                Go to Organizations →
              </Link>
            </div>
            <div className="bg-white rounded-lg p-4 border-2 border-gray-200">
              <div className="w-8 h-8 bg-green-600 text-white rounded-full flex items-center justify-center font-bold mb-3">
                2
              </div>
              <h3 className="font-semibold text-gray-900 mb-2">Build Question</h3>
              <p className="text-sm text-gray-600">Create engaging questions with images</p>
              <Link to="/questions/new" className="text-green-600 text-sm mt-2 inline-block">
                Create Question →
              </Link>
            </div>
            <div className="bg-white rounded-lg p-4 border-2 border-gray-200">
              <div className="w-8 h-8 bg-purple-600 text-white rounded-full flex items-center justify-center font-bold mb-3">
                3
              </div>
              <h3 className="font-semibold text-gray-900 mb-2">View Analytics</h3>
              <p className="text-sm text-gray-600">Track responses and insights</p>
              <span className="text-purple-600 text-sm mt-2 inline-block">
                Coming Soon
              </span>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/pages/ForgotPassword.jsx">
import React, { useState } from 'react';
import { Link } from 'react-router-dom';

export default function ForgotPasswordPage() {
  const [email, setEmail] = useState('');
  const [loading, setLoading] = useState(false);
  const [success, setSuccess] = useState(false);
  const [error, setError] = useState('');

  async function handleSubmit(e) {
    e.preventDefault();
    setError('');
    setLoading(true);

    try {
      const response = await fetch('http://localhost:5000/api/auth/request-password-reset', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || 'Request failed');
      }

      setSuccess(true);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }

  if (success) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-100">
        <div className="bg-white p-8 rounded-lg shadow-md w-full max-w-md">
          <div className="text-center">
            <div className="text-6xl mb-4">✅</div>
            <h2 className="text-2xl font-bold mb-4">Check Your Email</h2>
            <p className="text-gray-600 mb-6">
              If an account exists for {email}, we've sent password reset instructions.
            </p>
            <Link
              to="/login"
              className="inline-block bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700"
            >
              Back to Login
            </Link>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="bg-white p-8 rounded-lg shadow-md w-full max-w-md">
        <h1 className="text-2xl font-bold mb-2 text-center">Forgot Password?</h1>
        <p className="text-gray-600 text-center mb-6">
          Enter your email and we'll send you reset instructions
        </p>

        {error && (
          <div className="bg-red-50 text-red-600 p-3 rounded mb-4 text-sm">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit}>
          <div className="mb-6">
            <label className="block text-gray-700 mb-2">Email Address</label>
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="you@example.com"
              required
            />
          </div>

          <button
            type="submit"
            disabled={loading}
            className="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700 disabled:opacity-50 mb-4"
          >
            {loading ? 'Sending...' : 'Send Reset Link'}
          </button>
        </form>

        <div className="text-center text-sm text-gray-600">
          Remember your password?{' '}
          <Link to="/login" className="text-blue-600 hover:underline">
            Back to Login
          </Link>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/pages/Login.jsx">
// ============================================
// frontend/src/pages/Login.jsx (Updated)
// ============================================
import React, { useState, useContext } from "react";
import { useNavigate, Link } from "react-router-dom";
import { AuthContext } from "../context/AuthContext";

export default function LoginPage() {
  const navigate = useNavigate();
  const { login } = useContext(AuthContext);
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);

  async function handleSubmit(e) {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      await login(email, password);
      navigate("/dashboard");
    } catch (err) {
      setError(err.message || "Login failed");
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="bg-white p-8 rounded-lg shadow-md w-full max-w-md">
        <h1 className="text-2xl font-bold mb-6 text-center">Login</h1>

        {error && (
          <div className="bg-red-50 text-red-600 p-3 rounded mb-4 text-sm">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label className="block text-gray-700 mb-2">Email</label>
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              required
            />
          </div>

          <div className="mb-6">
            <label className="block text-gray-700 mb-2">Password</label>
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              required
            />
          </div>

          <button
            type="submit"
            disabled={loading}
            className="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700 disabled:opacity-50"
          >
            {loading ? "Logging in..." : "Login"}
          </button>
        </form>

        {/* Added Forgot Password Link */}
        <div className="text-center text-sm text-gray-600 mt-3">
          <Link to="/forgot-password" className="text-blue-600 hover:underline">
            Forgot your password?
          </Link>
        </div>

        <p className="mt-4 text-center text-gray-600 text-sm">
          Don't have an account?{" "}
          <Link to="/register" className="text-blue-600 hover:underline">
            Register
          </Link>
        </p>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/pages/Organizations.jsx">
import React, { useState, useEffect } from "react";
import api from "../services/api";

export default function OrganizationsPage() {
  const [organizations, setOrganizations] = useState([]);
  const [showForm, setShowForm] = useState(false);
  const [name, setName] = useState("");
  const [slug, setSlug] = useState("");
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    loadOrganizations();
  }, []);

  async function loadOrganizations() {
    try {
      const response = await api.getOrganizations();
      setOrganizations(response.data.organizations || []);
    } catch (error) {
      alert("Failed to load organizations");
    }
  }

  async function handleCreate(e) {
    e.preventDefault();
    setLoading(true);

    try {
      await api.createOrganization(name, slug);
      setShowForm(false);
      setName("");
      setSlug("");
      loadOrganizations();
    } catch (error) {
      alert(error.message);
    } finally {
      setLoading(false);
    }
  }

  async function handleDelete(id) {
    if (!confirm("Delete this organization?")) return;

    try {
      await api.deleteOrganization(id);
      loadOrganizations();
    } catch (error) {
      alert(error.message);
    }
  }

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Organizations</h1>
        <button
          onClick={() => setShowForm(!showForm)}
          className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
        >
          + New Organization
        </button>
      </div>

      {showForm && (
        <div className="bg-white p-6 rounded-lg shadow mb-6">
          <h2 className="text-xl font-bold mb-4">Create Organization</h2>
          <form onSubmit={handleCreate}>
            <div className="mb-4">
              <label className="block text-gray-700 mb-2">Name</label>
              <input
                type="text"
                value={name}
                onChange={(e) => setName(e.target.value)}
                className="w-full border rounded px-3 py-2"
                required
              />
            </div>

            <div className="mb-4">
              <label className="block text-gray-700 mb-2">Slug (optional)</label>
              <input
                type="text"
                value={slug}
                onChange={(e) => setSlug(e.target.value)}
                className="w-full border rounded px-3 py-2"
                placeholder="my-organization"
              />
            </div>

            <div className="flex space-x-2">
              <button
                type="submit"
                disabled={loading}
                className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 disabled:opacity-50"
              >
                {loading ? "Creating..." : "Create"}
              </button>
              <button
                type="button"
                onClick={() => setShowForm(false)}
                className="bg-gray-300 text-gray-700 px-4 py-2 rounded hover:bg-gray-400"
              >
                Cancel
              </button>
            </div>
          </form>
        </div>
      )}

      <div className="bg-white rounded-lg shadow overflow-hidden">
        <table className="w-full">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                Name
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                Slug
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                Created
              </th>
              <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase">
                Actions
              </th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-200">
            {organizations.map((org) => (
              <tr key={org.id}>
                <td className="px-6 py-4">{org.name}</td>
                <td className="px-6 py-4 text-gray-500">{org.slug}</td>
                <td className="px-6 py-4 text-gray-500">
                  {new Date(org.created_at).toLocaleDateString()}
                </td>
                <td className="px-6 py-4 text-right">
                  <button
                    onClick={() => handleDelete(org.id)}
                    className="text-red-600 hover:text-red-800"
                  >
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>

        {organizations.length === 0 && (
          <div className="text-center py-12 text-gray-500">
            No organizations yet
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/pages/QuestionBuilder.jsx">
import React, { useState, useEffect } from "react";
import { useParams, useNavigate } from "react-router-dom";
import api from "../services/api";

export default function QuestionBuilderPage() {
  const { id } = useParams();
  const navigate = useNavigate();
  const [organizations, setOrganizations] = useState([]);
  const [formData, setFormData] = useState({
    organizationId: "",
    questionText: "",
    questionType: "multiple_choice",
    options: [
      { text: "", imageUrl: "" },
      { text: "", imageUrl: "" }
    ],
    ratingMin: 1,
    ratingMax: 5,
    ratingLabel: "stars",
    isActive: true,
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [currentStep, setCurrentStep] = useState(1);

  useEffect(() => {
    loadOrganizations();
    if (id) loadQuestion();
  }, [id]);

  async function loadOrganizations() {
    try {
      const response = await api.getOrganizations(1, 100);
      setOrganizations(response.data.organizations || []);
    } catch (err) {
      console.error("Failed to load organizations:", err);
    }
  }

  async function loadQuestion() {
    try {
      const response = await api.getQuestion(id);
      const question = response.data.question;
      
      let options = question.options || [{ text: "", imageUrl: "" }, { text: "", imageUrl: "" }];
      
      // Convert old string format to new object format
      if (options.length > 0 && typeof options[0] === 'string') {
        options = options.map(opt => ({ text: opt, imageUrl: "" }));
      }

      setFormData({
        organizationId: question.organization_id,
        questionText: question.question_text,
        questionType: question.question_type,
        options: options,
        ratingMin: question.rating_min || 1,
        ratingMax: question.rating_max || 5,
        ratingLabel: question.rating_label || "stars",
        isActive: question.is_active,
      });
    } catch (err) {
      setError("Failed to load question");
    }
  }

  function updateOption(index, field, value) {
    const newOptions = [...formData.options];
    newOptions[index][field] = value;
    setFormData({ ...formData, options: newOptions });
  }

  function addOption() {
    setFormData({
      ...formData,
      options: [...formData.options, { text: "", imageUrl: "" }],
    });
  }

  function removeOption(index) {
    if (formData.options.length > 2) {
      const newOptions = formData.options.filter((_, i) => i !== index);
      setFormData({ ...formData, options: newOptions });
    }
  }

  async function handleSubmit(e) {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      const submitData = { ...formData };
      
      // For API compatibility, convert options format if needed
      if (formData.questionType === 'text') {
        submitData.options = [];
      } else if (formData.questionType === 'rating') {
        submitData.options = [{
          min: formData.ratingMin,
          max: formData.ratingMax,
          label: formData.ratingLabel
        }];
      }

      if (id) {
        await api.updateQuestion(id, submitData);
      } else {
        await api.createQuestion(submitData);
      }
      navigate("/questions");
    } catch (err) {
      setError(err.message || "Failed to save question");
    } finally {
      setLoading(false);
    }
  }

  const questionTypeIcons = {
    multiple_choice: "📋",
    text: "✍️",
    rating: "⭐",
  };

  return (
    <div className="max-w-4xl mx-auto">
      <div className="mb-8">
        <button
          onClick={() => navigate("/questions")}
          className="text-blue-600 hover:text-blue-800 mb-4 flex items-center"
        >
          ← Back to Questions
        </button>
        <h1 className="text-3xl font-bold text-gray-900">
          {id ? "Edit Question" : "Create New Question"}
        </h1>
        <p className="text-gray-600 mt-2">
          {id ? "Update your survey question" : "Build an engaging survey question for your audience"}
        </p>
      </div>

      {/* Progress Steps */}
      <div className="mb-8">
        <div className="flex items-center justify-center space-x-4">
          <div className={`flex items-center ${currentStep >= 1 ? 'text-blue-600' : 'text-gray-400'}`}>
            <div className={`w-10 h-10 rounded-full flex items-center justify-center border-2 ${currentStep >= 1 ? 'border-blue-600 bg-blue-50' : 'border-gray-300'}`}>
              1
            </div>
            <span className="ml-2 font-medium hidden sm:inline">Basic Info</span>
          </div>
          <div className="w-12 h-1 bg-gray-300"></div>
          <div className={`flex items-center ${currentStep >= 2 ? 'text-blue-600' : 'text-gray-400'}`}>
            <div className={`w-10 h-10 rounded-full flex items-center justify-center border-2 ${currentStep >= 2 ? 'border-blue-600 bg-blue-50' : 'border-gray-300'}`}>
              2
            </div>
            <span className="ml-2 font-medium hidden sm:inline">Question Details</span>
          </div>
          <div className="w-12 h-1 bg-gray-300"></div>
          <div className={`flex items-center ${currentStep >= 3 ? 'text-blue-600' : 'text-gray-400'}`}>
            <div className={`w-10 h-10 rounded-full flex items-center justify-center border-2 ${currentStep >= 3 ? 'border-blue-600 bg-blue-50' : 'border-gray-300'}`}>
              3
            </div>
            <span className="ml-2 font-medium hidden sm:inline">Review</span>
          </div>
        </div>
      </div>

      {error && (
        <div className="bg-red-50 border-l-4 border-red-500 p-4 mb-6 rounded">
          <div className="flex items-center">
            <span className="text-red-700 font-medium">{error}</span>
          </div>
        </div>
      )}

      <form onSubmit={handleSubmit} className="bg-white rounded-xl shadow-lg p-8">
        {/* Step 1: Basic Info */}
        {currentStep === 1 && (
          <div className="space-y-6">
            <div>
              <label className="block text-sm font-semibold text-gray-700 mb-2">
                Organization *
              </label>
              <select
                value={formData.organizationId}
                onChange={(e) =>
                  setFormData({ ...formData, organizationId: e.target.value })
                }
                className="w-full border-2 border-gray-200 rounded-lg px-4 py-3 focus:border-blue-500 focus:outline-none transition-colors"
                required
              >
                <option value="">Select an organization</option>
                {organizations.map((org) => (
                  <option key={org.id} value={org.id}>
                    {org.name}
                  </option>
                ))}
              </select>
              <p className="text-sm text-gray-500 mt-1">
                Choose which organization this question belongs to
              </p>
            </div>

            <div>
              <label className="block text-sm font-semibold text-gray-700 mb-2">
                Question Type *
              </label>
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                {Object.entries({
                  multiple_choice: "Multiple Choice",
                  text: "Text Response",
                  rating: "Rating Scale",
                }).map(([value, label]) => (
                  <button
                    key={value}
                    type="button"
                    onClick={() => setFormData({ ...formData, questionType: value })}
                    className={`p-4 rounded-lg border-2 transition-all ${
                      formData.questionType === value
                        ? "border-blue-500 bg-blue-50"
                        : "border-gray-200 hover:border-gray-300"
                    }`}
                  >
                    <div className="text-3xl mb-2">{questionTypeIcons[value]}</div>
                    <div className="font-semibold">{label}</div>
                    <div className="text-xs text-gray-500 mt-1">
                      {value === "multiple_choice" && "Users select from options"}
                      {value === "text" && "Users type their answer"}
                      {value === "rating" && "Users rate on a scale"}
                    </div>
                  </button>
                ))}
              </div>
            </div>

            <div className="flex justify-end">
              <button
                type="button"
                onClick={() => setCurrentStep(2)}
                className="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium"
                disabled={!formData.organizationId}
              >
                Next: Question Details →
              </button>
            </div>
          </div>
        )}

        {/* Step 2: Question Details */}
        {currentStep === 2 && (
          <div className="space-y-6">
            <div>
              <label className="block text-sm font-semibold text-gray-700 mb-2">
                Your Question *
              </label>
              <textarea
                value={formData.questionText}
                onChange={(e) =>
                  setFormData({ ...formData, questionText: e.target.value })
                }
                className="w-full border-2 border-gray-200 rounded-lg px-4 py-3 focus:border-blue-500 focus:outline-none transition-colors"
                rows={3}
                placeholder="e.g., What is your favorite feature?"
                required
              />
              <p className="text-sm text-gray-500 mt-1">
                Make it clear and easy to understand
              </p>
            </div>

            {/* Multiple Choice Options */}
            {formData.questionType === "multiple_choice" && (
              <div>
                <label className="block text-sm font-semibold text-gray-700 mb-3">
                  Answer Options *
                </label>
                <div className="space-y-3">
                  {formData.options.map((option, index) => (
                    <div key={index} className="bg-gray-50 rounded-lg p-4 border-2 border-gray-200">
                      <div className="flex items-start gap-3">
                        <div className="w-8 h-8 bg-blue-100 text-blue-600 rounded-full flex items-center justify-center font-semibold flex-shrink-0 mt-1">
                          {String.fromCharCode(65 + index)}
                        </div>
                        <div className="flex-1 space-y-3">
                          <input
                            type="text"
                            value={option.text}
                            onChange={(e) => updateOption(index, "text", e.target.value)}
                            className="w-full border-2 border-gray-200 rounded-lg px-4 py-2 focus:border-blue-500 focus:outline-none"
                            placeholder={`Option ${index + 1}`}
                            required
                          />
                          <div>
                            <label className="block text-xs font-medium text-gray-600 mb-1">
                              Image URL (optional)
                            </label>
                            <input
                              type="url"
                              value={option.imageUrl}
                              onChange={(e) => updateOption(index, "imageUrl", e.target.value)}
                              className="w-full border-2 border-gray-200 rounded-lg px-4 py-2 focus:border-blue-500 focus:outline-none text-sm"
                              placeholder="https://example.com/image.jpg"
                            />
                          </div>
                          {option.imageUrl && (
                            <div className="mt-2">
                              <img
                                src={option.imageUrl}
                                alt={`Option ${index + 1}`}
                                className="w-32 h-32 object-cover rounded-lg border-2 border-gray-200"
                                onError={(e) => {
                                  e.target.style.display = 'none';
                                }}
                              />
                            </div>
                          )}
                        </div>
                        {formData.options.length > 2 && (
                          <button
                            type="button"
                            onClick={() => removeOption(index)}
                            className="text-red-600 hover:text-red-800 p-2"
                            title="Remove option"
                          >
                            ✕
                          </button>
                        )}
                      </div>
                    </div>
                  ))}
                </div>
                <button
                  type="button"
                  onClick={addOption}
                  className="mt-3 text-blue-600 hover:text-blue-800 font-medium flex items-center"
                >
                  + Add Another Option
                </button>
              </div>
            )}

            {/* Rating Scale Options */}
            {formData.questionType === "rating" && (
              <div className="space-y-4">
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-semibold text-gray-700 mb-2">
                      Minimum Rating *
                    </label>
                    <input
                      type="number"
                      value={formData.ratingMin}
                      onChange={(e) =>
                        setFormData({ ...formData, ratingMin: parseInt(e.target.value) })
                      }
                      className="w-full border-2 border-gray-200 rounded-lg px-4 py-2 focus:border-blue-500 focus:outline-none"
                      min="0"
                      max="10"
                      required
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-semibold text-gray-700 mb-2">
                      Maximum Rating *
                    </label>
                    <input
                      type="number"
                      value={formData.ratingMax}
                      onChange={(e) =>
                        setFormData({ ...formData, ratingMax: parseInt(e.target.value) })
                      }
                      className="w-full border-2 border-gray-200 rounded-lg px-4 py-2 focus:border-blue-500 focus:outline-none"
                      min="1"
                      max="10"
                      required
                    />
                  </div>
                </div>

                <div>
                  <label className="block text-sm font-semibold text-gray-700 mb-2">
                    Rating Style
                  </label>
                  <select
                    value={formData.ratingLabel}
                    onChange={(e) =>
                      setFormData({ ...formData, ratingLabel: e.target.value })
                    }
                    className="w-full border-2 border-gray-200 rounded-lg px-4 py-3 focus:border-blue-500 focus:outline-none"
                  >
                    <option value="stars">⭐ Stars</option>
                    <option value="hearts">❤️ Hearts</option>
                    <option value="thumbs">👍 Thumbs</option>
                    <option value="numbers">🔢 Numbers</option>
                  </select>
                </div>

                {/* Rating Preview */}
                <div className="bg-blue-50 border-2 border-blue-200 rounded-lg p-4">
                  <p className="text-sm font-medium text-blue-900 mb-2">Preview:</p>
                  <div className="flex gap-2">
                    {Array.from({ length: formData.ratingMax - formData.ratingMin + 1 }, (_, i) => (
                      <div key={i} className="text-2xl">
                        {formData.ratingLabel === 'stars' && '⭐'}
                        {formData.ratingLabel === 'hearts' && '❤️'}
                        {formData.ratingLabel === 'thumbs' && '👍'}
                        {formData.ratingLabel === 'numbers' && (
                          <span className="bg-blue-600 text-white w-10 h-10 rounded-full flex items-center justify-center text-sm font-bold">
                            {formData.ratingMin + i}
                          </span>
                        )}
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            )}

            {/* Text Response Info */}
            {formData.questionType === "text" && (
              <div className="bg-blue-50 border-2 border-blue-200 rounded-lg p-4">
                <p className="text-sm text-blue-900">
                  📝 Users will be able to type their own answer to this question.
                </p>
              </div>
            )}

            <div className="flex justify-between pt-4">
              <button
                type="button"
                onClick={() => setCurrentStep(1)}
                className="text-gray-600 hover:text-gray-800 font-medium"
              >
                ← Back
              </button>
              <button
                type="button"
                onClick={() => setCurrentStep(3)}
                className="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium"
                disabled={!formData.questionText}
              >
                Next: Review →
              </button>
            </div>
          </div>
        )}

        {/* Step 3: Review & Settings */}
        {currentStep === 3 && (
          <div className="space-y-6">
            <div className="bg-gray-50 rounded-lg p-6 border-2 border-gray-200">
              <h3 className="font-semibold text-lg mb-4">Question Preview</h3>
              <div className="bg-white rounded-lg p-4 border-2 border-gray-300">
                <p className="font-medium text-gray-900 mb-3">{formData.questionText}</p>
                
                {formData.questionType === "multiple_choice" && (
                  <div className="space-y-2">
                    {formData.options.map((option, index) => (
                      <div key={index} className="flex items-center gap-3 p-3 border-2 border-gray-200 rounded-lg">
                        <input type="radio" name="preview" disabled />
                        {option.imageUrl && (
                          <img src={option.imageUrl} alt="" className="w-16 h-16 object-cover rounded" />
                        )}
                        <span>{option.text}</span>
                      </div>
                    ))}
                  </div>
                )}

                {formData.questionType === "rating" && (
                  <div className="flex gap-2">
                    {Array.from({ length: formData.ratingMax - formData.ratingMin + 1 }, (_, i) => (
                      <div key={i} className="text-3xl cursor-pointer hover:scale-110 transition-transform">
                        {formData.ratingLabel === 'stars' && '⭐'}
                        {formData.ratingLabel === 'hearts' && '❤️'}
                        {formData.ratingLabel === 'thumbs' && '👍'}
                        {formData.ratingLabel === 'numbers' && (
                          <span className="bg-blue-600 text-white w-12 h-12 rounded-full flex items-center justify-center text-sm font-bold">
                            {formData.ratingMin + i}
                          </span>
                        )}
                      </div>
                    ))}
                  </div>
                )}

                {formData.questionType === "text" && (
                  <textarea
                    className="w-full border-2 border-gray-200 rounded-lg px-4 py-2"
                    rows={3}
                    placeholder="User will type their answer here..."
                    disabled
                  />
                )}
              </div>
            </div>

            <div className="bg-white rounded-lg p-4 border-2 border-gray-200">
              <label className="flex items-center cursor-pointer">
                <input
                  type="checkbox"
                  checked={formData.isActive}
                  onChange={(e) =>
                    setFormData({ ...formData, isActive: e.target.checked })
                  }
                  className="w-5 h-5 text-blue-600 rounded focus:ring-2 focus:ring-blue-500"
                />
                <span className="ml-3">
                  <span className="font-semibold text-gray-900">Active</span>
                  <span className="block text-sm text-gray-500">
                    This question will be shown to users
                  </span>
                </span>
              </label>
            </div>

            <div className="flex justify-between pt-4">
              <button
                type="button"
                onClick={() => setCurrentStep(2)}
                className="text-gray-600 hover:text-gray-800 font-medium"
              >
                ← Back
              </button>
              <button
                type="submit"
                disabled={loading}
                className="bg-green-600 text-white px-8 py-3 rounded-lg hover:bg-green-700 transition-colors font-medium disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
              >
                {loading ? (
                  <>
                    <svg className="animate-spin h-5 w-5" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none"/>
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"/>
                    </svg>
                    Saving...
                  </>
                ) : (
                  <>
                    ✓ {id ? "Update Question" : "Create Question"}
                  </>
                )}
              </button>
            </div>
          </div>
        )}
      </form>
    </div>
  );
}
</file>

<file path="frontend/src/pages/QuestionList.jsx">
import React, { useState, useEffect } from "react";
import { Link } from "react-router-dom";
import api from "../services/api";

export default function QuestionListPage() {
  const [questions, setQuestions] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState("all");
  const [searchTerm, setSearchTerm] = useState("");

  useEffect(() => {
    loadQuestions();
  }, []);

  async function loadQuestions() {
    try {
      const response = await api.getQuestions();
      setQuestions(response.data.questions || []);
    } catch (err) {
      console.error("Failed to load questions:", err);
    } finally {
      setLoading(false);
    }
  }

  async function handleDelete(id) {
    if (!confirm("Are you sure you want to delete this question? This action cannot be undone.")) return;

    try {
      await api.deleteQuestion(id);
      loadQuestions();
    } catch (err) {
      alert(err.message || "Failed to delete question");
    }
  }

  const filteredQuestions = questions.filter((q) => {
    const matchesSearch = q.question_text.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesFilter =
      filter === "all" ||
      (filter === "active" && q.is_active) ||
      (filter === "inactive" && !q.is_active) ||
      filter === q.question_type;
    return matchesSearch && matchesFilter;
  });

  const stats = {
    total: questions.length,
    active: questions.filter((q) => q.is_active).length,
    multipleChoice: questions.filter((q) => q.question_type === "multiple_choice").length,
    text: questions.filter((q) => q.question_type === "text").length,
    rating: questions.filter((q) => q.question_type === "rating").length,
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
          <p className="mt-4 text-gray-600">Loading questions...</p>
        </div>
      </div>
    );
  }

  return (
    <div>
      {/* Header */}
      <div className="mb-8">
        <div className="flex justify-between items-center">
          <div>
            <h1 className="text-3xl font-bold text-gray-900">Survey Questions</h1>
            <p className="text-gray-600 mt-2">Manage all your survey questions in one place</p>
          </div>
          <Link
            to="/questions/new"
            className="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium flex items-center gap-2 shadow-lg hover:shadow-xl"
          >
            <span className="text-xl">+</span> Create Question
          </Link>
        </div>
      </div>

      {/* Stats Cards */}
      <div className="grid grid-cols-1 md:grid-cols-5 gap-4 mb-6">
        <div className="bg-white rounded-lg shadow p-4 border-l-4 border-blue-500">
          <div className="text-sm text-gray-600">Total Questions</div>
          <div className="text-2xl font-bold text-gray-900">{stats.total}</div>
        </div>
        <div className="bg-white rounded-lg shadow p-4 border-l-4 border-green-500">
          <div className="text-sm text-gray-600">Active</div>
          <div className="text-2xl font-bold text-green-600">{stats.active}</div>
        </div>
        <div className="bg-white rounded-lg shadow p-4 border-l-4 border-purple-500">
          <div className="text-sm text-gray-600">📋 Multiple Choice</div>
          <div className="text-2xl font-bold text-purple-600">{stats.multipleChoice}</div>
        </div>
        <div className="bg-white rounded-lg shadow p-4 border-l-4 border-orange-500">
          <div className="text-sm text-gray-600">✍️ Text</div>
          <div className="text-2xl font-bold text-orange-600">{stats.text}</div>
        </div>
        <div className="bg-white rounded-lg shadow p-4 border-l-4 border-yellow-500">
          <div className="text-sm text-gray-600">⭐ Rating</div>
          <div className="text-2xl font-bold text-yellow-600">{stats.rating}</div>
        </div>
      </div>

      {/* Filters & Search */}
      <div className="bg-white rounded-lg shadow p-4 mb-6">
        <div className="flex flex-col md:flex-row gap-4">
          <div className="flex-1">
            <input
              type="text"
              placeholder="🔍 Search questions..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full border-2 border-gray-200 rounded-lg px-4 py-2 focus:border-blue-500 focus:outline-none"
            />
          </div>
          <div className="flex gap-2 flex-wrap">
            {[
              { value: "all", label: "All" },
              { value: "active", label: "Active" },
              { value: "inactive", label: "Inactive" },
              { value: "multiple_choice", label: "Multiple Choice" },
              { value: "text", label: "Text" },
              { value: "rating", label: "Rating" },
            ].map((f) => (
              <button
                key={f.value}
                onClick={() => setFilter(f.value)}
                className={`px-4 py-2 rounded-lg font-medium transition-colors ${
                  filter === f.value
                    ? "bg-blue-600 text-white"
                    : "bg-gray-100 text-gray-700 hover:bg-gray-200"
                }`}
              >
                {f.label}
              </button>
            ))}
          </div>
        </div>
      </div>

      {/* Questions List */}
      {filteredQuestions.length === 0 ? (
        <div className="bg-white rounded-lg shadow p-12 text-center">
          <div className="text-6xl mb-4">📝</div>
          <h3 className="text-xl font-semibold text-gray-900 mb-2">
            {searchTerm || filter !== "all" ? "No questions found" : "No questions yet"}
          </h3>
          <p className="text-gray-600 mb-6">
            {searchTerm || filter !== "all"
              ? "Try adjusting your search or filters"
              : "Create your first question to get started"}
          </p>
          {!searchTerm && filter === "all" && (
            <Link
              to="/questions/new"
              className="inline-block bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium"
            >
              Create Your First Question
            </Link>
          )}
        </div>
      ) : (
        <div className="grid gap-4">
          {filteredQuestions.map((q) => (
            <div
              key={q.id}
              className="bg-white rounded-lg shadow hover:shadow-lg transition-shadow border-2 border-gray-100 hover:border-blue-200"
            >
              <div className="p-6">
                <div className="flex items-start justify-between">
                  <div className="flex-1">
                    <div className="flex items-center gap-3 mb-3">
                      <span className="text-2xl">
                        {q.question_type === "multiple_choice" && "📋"}
                        {q.question_type === "text" && "✍️"}
                        {q.question_type === "rating" && "⭐"}
                      </span>
                      <div>
                        <h3 className="text-lg font-semibold text-gray-900">
                          {q.question_text}
                        </h3>
                        <p className="text-sm text-gray-500">
                          {q.organization_name}
                        </p>
                      </div>
                    </div>

                    {/* Question Details */}
                    <div className="flex items-center gap-4 text-sm">
                      <span className="inline-flex items-center px-3 py-1 rounded-full bg-blue-100 text-blue-800 font-medium">
                        {q.question_type === "multiple_choice" && "Multiple Choice"}
                        {q.question_type === "text" && "Text Response"}
                        {q.question_type === "rating" && "Rating Scale"}
                      </span>
                      <span
                        className={`inline-flex items-center px-3 py-1 rounded-full font-medium ${
                          q.is_active
                            ? "bg-green-100 text-green-800"
                            : "bg-gray-100 text-gray-800"
                        }`}
                      >
                        {q.is_active ? "✓ Active" : "○ Inactive"}
                      </span>
                      {q.question_type === "multiple_choice" && (
                        <span className="text-gray-600">
                          {q.options?.length || 0} options
                        </span>
                      )}
                    </div>

                    {/* Options Preview for Multiple Choice */}
                    {q.question_type === "multiple_choice" && q.options && (
                      <div className="mt-4 flex flex-wrap gap-2">
                        {q.options.slice(0, 3).map((opt, idx) => {
                          const option = typeof opt === 'string' ? { text: opt, imageUrl: '' } : opt;
                          return (
                            <div
                              key={idx}
                              className="inline-flex items-center gap-2 px-3 py-1 bg-gray-50 border border-gray-200 rounded-lg text-sm"
                            >
                              {option.imageUrl && (
                                <img src={option.imageUrl} alt="" className="w-6 h-6 rounded object-cover" />
                              )}
                              <span className="text-gray-700">{option.text}</span>
                            </div>
                          );
                        })}
                        {q.options.length > 3 && (
                          <span className="text-gray-500 text-sm">
                            +{q.options.length - 3} more
                          </span>
                        )}
                      </div>
                    )}
                  </div>

                  {/* Actions */}
                  <div className="flex items-center gap-2 ml-4">
                    <Link
                      to={`/questions/${q.id}/edit`}
                      className="p-2 text-blue-600 hover:bg-blue-50 rounded-lg transition-colors"
                      title="Edit question"
                    >
                      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                      </svg>
                    </Link>
                    <button
                      onClick={() => handleDelete(q.id)}
                      className="p-2 text-red-600 hover:bg-red-50 rounded-lg transition-colors"
                      title="Delete question"
                    >
                      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                      </svg>
                    </button>
                  </div>
                </div>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* Results count */}
      {filteredQuestions.length > 0 && (
        <div className="mt-6 text-center text-gray-600">
          Showing {filteredQuestions.length} of {questions.length} questions
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/pages/Register.jsx">
// ============================================
// frontend/src/pages/Register.jsx (Complete)
// ============================================
import React, { useState, useContext } from "react";
import { useNavigate, Link } from "react-router-dom";
import { AuthContext } from "../context/AuthContext";

export default function RegisterPage() {
  const navigate = useNavigate();
  const { register } = useContext(AuthContext);
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [fullName, setFullName] = useState("");
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);

  async function handleSubmit(e) {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      await register(email, password, fullName);
      navigate("/dashboard");
    } catch (err) {
      setError(err.message || "Registration failed");
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="bg-white p-8 rounded-lg shadow-md w-full max-w-md">
        <h1 className="text-2xl font-bold mb-6 text-center">Register</h1>

        {error && (
          <div className="bg-red-50 text-red-600 p-3 rounded mb-4 text-sm">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label className="block text-gray-700 mb-2">Full Name</label>
            <input
              type="text"
              value={fullName}
              onChange={(e) => setFullName(e.target.value)}
              className="w-full border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              required
            />
          </div>

          <div className="mb-4">
            <label className="block text-gray-700 mb-2">Email</label>
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              required
            />
          </div>

          <div className="mb-6">
            <label className="block text-gray-700 mb-2">Password</label>
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              required
              minLength={8}
            />
            <p className="text-xs text-gray-500 mt-1">
              Minimum 8 characters
            </p>
          </div>

          <button
            type="submit"
            disabled={loading}
            className="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700 disabled:opacity-50"
          >
            {loading ? "Creating account..." : "Register"}
          </button>
        </form>

        <p className="mt-4 text-center text-gray-600 text-sm">
          Already have an account?{" "}
          <Link to="/login" className="text-blue-600 hover:underline">
            Login
          </Link>
        </p>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/pages/ResetPassword.jsx">
import React, { useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';

export default function ResetPasswordPage() {
  const navigate = useNavigate();
  const [newPassword, setNewPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [success, setSuccess] = useState(false);
  const [error, setError] = useState('');

  // Get token from URL
  const urlParams = new URLSearchParams(window.location.search);
  const token = urlParams.get('token');

  async function handleSubmit(e) {
    e.preventDefault();
    setError('');

    if (newPassword !== confirmPassword) {
      setError('Passwords do not match');
      return;
    }

    if (newPassword.length < 8) {
      setError('Password must be at least 8 characters');
      return;
    }

    if (!token) {
      setError('Invalid reset link');
      return;
    }

    setLoading(true);

    try {
      const response = await fetch('http://localhost:5000/api/auth/reset-password', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ token, newPassword }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || 'Reset failed');
      }

      setSuccess(true);
      setTimeout(() => navigate('/login'), 2000);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }

  if (!token) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-100">
        <div className="bg-white p-8 rounded-lg shadow-md w-full max-w-md">
          <div className="text-center">
            <div className="text-6xl mb-4">❌</div>
            <h2 className="text-2xl font-bold mb-4">Invalid Reset Link</h2>
            <p className="text-gray-600 mb-6">
              This password reset link is invalid or has expired.
            </p>
            <Link
              to="/forgot-password"
              className="inline-block bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700"
            >
              Request New Link
            </Link>
          </div>
        </div>
      </div>
    );
  }

  if (success) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-100">
        <div className="bg-white p-8 rounded-lg shadow-md w-full max-w-md">
          <div className="text-center">
            <div className="text-6xl mb-4">✅</div>
            <h2 className="text-2xl font-bold mb-4">Password Reset Complete!</h2>
            <p className="text-gray-600 mb-6">
              Your password has been successfully reset. Redirecting to login...
            </p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="bg-white p-8 rounded-lg shadow-md w-full max-w-md">
        <h1 className="text-2xl font-bold mb-2 text-center">Reset Your Password</h1>
        <p className="text-gray-600 text-center mb-6">
          Enter your new password below
        </p>

        {error && (
          <div className="bg-red-50 text-red-600 p-3 rounded mb-4 text-sm">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label className="block text-gray-700 mb-2">New Password</label>
            <input
              type="password"
              value={newPassword}
              onChange={(e) => setNewPassword(e.target.value)}
              className="w-full border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="Minimum 8 characters"
              required
              minLength={8}
            />
          </div>

          <div className="mb-6">
            <label className="block text-gray-700 mb-2">Confirm Password</label>
            <input
              type="password"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              className="w-full border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="Re-enter password"
              required
              minLength={8}
            />
          </div>

          <button
            type="submit"
            disabled={loading}
            className="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700 disabled:opacity-50"
          >
            {loading ? 'Resetting...' : 'Reset Password'}
          </button>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/services/api.js">
// ============================================
// frontend/src/services/api.js (Merged & Updated)
// ============================================
const API_BASE = import.meta.env.VITE_API_BASE || "http://localhost:5000/api";

class ApiService {
  constructor() {
    this.baseUrl = API_BASE;
    this.token = localStorage.getItem("accessToken");
  }

  setToken(token) {
    this.token = token;
    if (token) {
      localStorage.setItem("accessToken", token);
    } else {
      localStorage.removeItem("accessToken");
    }
  }

  async request(method, endpoint, data = null) {
    const headers = {
      "Content-Type": "application/json",
    };

    if (this.token) {
      headers.Authorization = `Bearer ${this.token}`;
    }

    const config = {
      method,
      headers,
    };

    if (data) {
      config.body = JSON.stringify(data);
    }

    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, config);
      const json = await response.json();

      if (!response.ok) {
        throw new Error(json.message || "Request failed");
      }

      return json;
    } catch (error) {
      throw error;
    }
  }

  // ===================== Auth =====================
  async register(email, password, fullName) {
    const response = await this.request("POST", "/auth/register", {
      email,
      password,
      fullName,
    });
    this.setToken(response.data.accessToken);
    return response;
  }

  async login(email, password) {
    const response = await this.request("POST", "/auth/login", {
      email,
      password,
    });
    this.setToken(response.data.accessToken);
    return response;
  }

  async logout(refreshToken) {
    await this.request("POST", "/auth/logout", { refreshToken });
    this.setToken(null);
  }

  async getCurrentUser() {
    return this.request("GET", "/auth/me");
  }

  // ===================== Organizations =====================
  async createOrganization(name, slug) {
    return this.request("POST", "/organizations", { name, slug });
  }

  async getOrganizations(page = 1, limit = 10) {
    return this.request("GET", `/organizations?page=${page}&limit=${limit}`);
  }

  async getOrganization(id) {
    return this.request("GET", `/organizations/${id}`);
  }

  async updateOrganization(id, data) {
    return this.request("PUT", `/organizations/${id}`, data);
  }

  async deleteOrganization(id) {
    return this.request("DELETE", `/organizations/${id}`);
  }

  // ===================== Questions =====================
  async createQuestion(data) {
    return this.request("POST", "/questions", data);
  }

  async getQuestions(filters = {}) {
    const params = new URLSearchParams(filters).toString();
    return this.request("GET", `/questions?${params}`);
  }

  async getQuestion(id) {
    return this.request("GET", `/questions/${id}`);
  }

  async updateQuestion(id, data) {
    return this.request("PUT", `/questions/${id}`, data);
  }

  async deleteQuestion(id) {
    return this.request("DELETE", `/questions/${id}`);
  }

  // ===================== Analytics =====================
  async getQuestionAnalytics(questionId, filters = {}) {
    const params = new URLSearchParams(filters).toString();
    return this.request(
      "GET",
      `/analytics/questions/${questionId}?${params}`
    );
  }

  async getOrganizationAnalytics(organizationId) {
    return this.request(
      "GET",
      `/analytics/organizations/${organizationId}`
    );
  }

  // ===================== Tenants =====================
  async createTenant(data) {
    return this.request("POST", "/tenants", data);
  }

  async getTenants(page = 1, limit = 10) {
    return this.request("GET", `/tenants?page=${page}&limit=${limit}`);
  }

  // ===================== API Keys =====================
  async createApiKey(tenantId, name) {
    return this.request("POST", `/tenants/${tenantId}/keys`, { name });
  }

  async listApiKeys(tenantId) {
    return this.request("GET", `/tenants/${tenantId}/keys`);
  }

  async revokeApiKey(tenantId, keyId) {
    return this.request("DELETE", `/tenants/${tenantId}/keys/${keyId}`);
  }

  // ===================== Surveys =====================
  async createSurvey(data) {
    return this.request("POST", "/surveys", data);
  }

  async getSurveys(filters = {}) {
    const params = new URLSearchParams(filters).toString();
    return this.request("GET", `/surveys?${params}`);
  }

  async publishSurvey(surveyId) {
    return this.request("POST", `/surveys/${surveyId}/publish`);
  }

  async getSurveyResults(surveyId, filters = {}) {
    const params = new URLSearchParams(filters).toString();
    return this.request(
      "GET",
      `/surveys/${surveyId}/results?${params}`
    );
  }

  async getEmbedCode(surveyId) {
    return this.request("GET", `/surveys/${surveyId}/embed`);
  }
}

export default new ApiService();
</file>

<file path="frontend/src/App.jsx">
// frontend/src/App.jsx - UPDATED with Dashboard Shell
import React from "react";
import { BrowserRouter, Routes, Route, Navigate } from "react-router-dom";
import { AuthProvider } from "./context/AuthContext";
import ProtectedRoute from "./components/ProtectedRoute";
import ErrorBoundary from "./components/ui/ErrorBoundary";
import DashboardLayout from "./components/layout/DashboardLayout";

// Pages
import LoginPage from "./pages/Login";
import RegisterPage from "./pages/Register";
import ForgotPasswordPage from "./pages/ForgotPassword";
import ResetPasswordPage from "./pages/ResetPassword";
import DashboardPage from "./pages/Dashboard";
import QuestionBuilderPage from "./pages/QuestionBuilder";
import QuestionListPage from "./pages/QuestionList";
import AnalyticsPage from "./pages/Analytics";
import OrganizationsPage from "./pages/Organizations";
import { NotFound, Unauthorized } from "./pages/errors/NotFound";

// Placeholder pages for future features
const PlaceholderPage = ({ title }) => (
  <div className="text-center py-12">
    <h1 className="text-3xl font-bold text-gray-900 mb-4">{title}</h1>
    <p className="text-gray-600 mb-6">This feature is coming soon!</p>
    <div className="inline-flex items-center gap-2 px-4 py-2 bg-purple-100 text-purple-700 rounded-lg">
      <span className="animate-pulse">🚧</span>
      <span className="font-medium">Under Development</span>
    </div>
  </div>
);

export default function App() {
  return (
    <ErrorBoundary>
      <AuthProvider>
        <BrowserRouter>
          <Routes>
            {/* Public routes */}
            <Route path="/login" element={<LoginPage />} />
            <Route path="/register" element={<RegisterPage />} />
            <Route path="/forgot-password" element={<ForgotPasswordPage />} />
            <Route path="/reset-password" element={<ResetPasswordPage />} />
            <Route path="/unauthorized" element={<Unauthorized />} />

            {/* Protected routes with dashboard layout */}
            <Route
              path="/"
              element={
                <ProtectedRoute>
                  <DashboardLayout />
                </ProtectedRoute>
              }
            >
              {/* Main dashboard */}
              <Route index element={<Navigate to="/dashboard" replace />} />
              <Route path="dashboard" element={<DashboardPage />} />

              {/* Organizations */}
              <Route path="organizations" element={<OrganizationsPage />} />

              {/* Questions */}
              <Route path="questions" element={<QuestionListPage />} />
              <Route path="questions/new" element={<QuestionBuilderPage />} />
              <Route path="questions/:id/edit" element={<QuestionBuilderPage />} />

              {/* Analytics */}
              <Route path="analytics" element={<PlaceholderPage title="Analytics" />} />
              <Route path="analytics/:questionId" element={<AnalyticsPage />} />

              {/* Surveys (placeholder) */}
              <Route path="surveys" element={<PlaceholderPage title="Surveys" />} />

              {/* API Keys (placeholder) */}
              <Route path="api-keys" element={<PlaceholderPage title="API Keys" />} />

              {/* Billing (placeholder) */}
              <Route path="billing" element={<PlaceholderPage title="Billing" />} />

              {/* Webhooks (placeholder) */}
              <Route path="webhooks" element={<PlaceholderPage title="Webhooks" />} />

              {/* Settings */}
              <Route path="settings" element={<PlaceholderPage title="Settings" />} />
              <Route path="settings/profile" element={<PlaceholderPage title="Profile Settings" />} />
            </Route>

            {/* 404 catch-all */}
            <Route path="*" element={<NotFound />} />
          </Routes>
        </BrowserRouter>
      </AuthProvider>
    </ErrorBoundary>
  );
}
</file>

<file path="frontend/src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: sans-serif;
}
</file>

<file path="frontend/src/main.jsx">
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./index.css";

ReactDOM.createRoot(document.getElementById("root")).render(<App />);
</file>

<file path="frontend/Dockerfile">
FROM node:18-alpine AS base
WORKDIR /app

# Development
FROM base AS dev
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 5173
CMD ["npm", "run", "dev", "--", "--host"]

# Build stage
FROM base AS build
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Production
FROM nginx:alpine AS prod
COPY --from=build /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
</file>

<file path="frontend/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>
  <body class="bg-gray-100">
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="frontend/nginx.conf">
server {
    listen 80;
    server_name _;
    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $uri $uri/ /index.html;
    }

    location /api {
        proxy_pass http://api:5000/api;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
</file>

<file path="frontend/package.json">
{
  "name": "dashboard-frontend",
  "version": "2.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint src --ext js,jsx --report-unused-disable-directives --max-warnings 0"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.23.0"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.3.0",
    "autoprefixer": "^10.4.17",
    "eslint": "^8.57.0",
    "eslint-plugin-react": "^7.34.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "postcss": "^8.4.36",
    "tailwindcss": "^3.4.0",
    "vite": "^5.2.0"
  },
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  }
}
</file>

<file path="frontend/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {}
  }
};
</file>

<file path="frontend/tailwind.config.js">
export default {
  content: ["./index.html", "./src/**/*.{js,jsx}"],
  theme: { extend: {} },
  plugins: []
};
</file>

<file path="frontend/vite.config.js">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  server: { port: 5173 }
});
</file>

<file path="microsurvey-mock/index.js">
// microsurvey-mock/index.js
import express from 'express';
import cors from 'cors';
import { v4 as uuidv4 } from 'uuid';

const app = express();
app.use(cors());
app.use(express.json());

const surveys = new Map();
const responses = new Map();

app.get('/health', (req, res) => {
  res.json({ status: 'ok' });
});

app.post('/v1/surveys', (req, res) => {
  const survey = {
    id: uuidv4(),
    surveyId: uuidv4(),
    survey_key: `survey_${Date.now()}`,
    surveyKey: `survey_${Date.now()}`,
    ...req.body,
    createdAt: new Date().toISOString(),
  };
  surveys.set(survey.id, survey);
  res.status(201).json(survey);
});

app.get('/v1/surveys/:id', (req, res) => {
  const survey = surveys.get(req.params.id);
  if (!survey) return res.status(404).json({ error: 'Not found' });
  res.json(survey);
});

app.put('/v1/surveys/:id', (req, res) => {
  const survey = surveys.get(req.params.id);
  if (!survey) return res.status(404).json({ error: 'Not found' });
  Object.assign(survey, req.body, { updatedAt: new Date().toISOString() });
  surveys.set(req.params.id, survey);
  res.json(survey);
});

app.post('/v1/surveys/:key/responses', (req, res) => {
  const responseId = uuidv4();
  const response = {
    id: responseId,
    surveyKey: req.params.key,
    ...req.body,
    submittedAt: new Date().toISOString(),
  };
  
  if (!responses.has(req.params.key)) {
    responses.set(req.params.key, []);
  }
  responses.get(req.params.key).push(response);
  
  res.status(201).json(response);
});

app.get('/v1/surveys/:id/results', (req, res) => {
  const survey = surveys.get(req.params.id);
  if (!survey) return res.status(404).json({ error: 'Not found' });
  
  const surveyResponses = responses.get(survey.survey_key) || [];
  
  res.json({
    surveyId: survey.id,
    totalResponses: surveyResponses.length,
    responses: surveyResponses,
    aggregated: {
      byQuestion: {},
    },
  });
});

app.post('/v1/surveys/:id/export', (req, res) => {
  res.json({
    exportId: uuidv4(),
    status: 'pending',
    format: req.body.format || 'csv',
  });
});

const PORT = process.env.PORT || 4000;
app.listen(PORT, () => {
  console.log(`Mock Micro-Survey running on port ${PORT}`);
});

// microsurvey-mock/package.json
{
  "name": "microsurvey-mock",
  "version": "1.0.0",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "start": "node index.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "uuid": "^9.0.1"
  }
}

// microsurvey-mock/Dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
EXPOSE 4000
CMD ["npm", "start"]
</file>

<file path="public/widget.js">
// ============================================
// FILE: public/widget.js
// Standalone survey embed widget (no React dependency)
// ============================================
(function() {
  'use strict';

  const API_BASE = document.currentScript.getAttribute('data-api-url') || 'http://localhost:5000/api';
  const SURVEY_KEY = document.currentScript.getAttribute('data-survey-key');
  
  if (!SURVEY_KEY) {
    console.error('[MicroSurvey] Missing data-survey-key attribute');
    return;
  }

  // Widget state
  let surveyData = null;
  let currentQuestionIndex = 0;
  let answers = {};
  let containerId = `microsurvey-${SURVEY_KEY}`;

  // Callbacks
  const callbacks = {
    onOpen: window.microSurveyOnOpen || function() {},
    onSubmit: window.microSurveyOnSubmit || function() {},
    onComplete: window.microSurveyOnComplete || function() {},
  };

  // Fetch survey data
  async function loadSurvey() {
    try {
      const response = await fetch(`${API_BASE}/embed/${SURVEY_KEY}`);
      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.message || 'Failed to load survey');
      }
      
      surveyData = data.data;
      render();
      callbacks.onOpen(surveyData);
    } catch (error) {
      console.error('[MicroSurvey] Load error:', error);
      renderError('Failed to load survey. Please try again later.');
    }
  }

  // Submit survey response
  async function submitSurvey() {
    try {
      const response = await fetch(`${API_BASE}/embed/${SURVEY_KEY}/responses`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          answers: Object.keys(answers).map(questionId => ({
            questionId,
            answer: answers[questionId],
          })),
          metadata: {
            sessionId: getSessionId(),
            completedAt: new Date().toISOString(),
          },
        }),
      });

      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.message || 'Failed to submit response');
      }

      callbacks.onSubmit(answers);
      renderThankYou();
      callbacks.onComplete(answers);
    } catch (error) {
      console.error('[MicroSurvey] Submit error:', error);
      renderError('Failed to submit response. Please try again.');
    }
  }

  // Get or create session ID
  function getSessionId() {
    let sessionId = sessionStorage.getItem('microsurvey_session');
    if (!sessionId) {
      sessionId = `sess_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      sessionStorage.setItem('microsurvey_session', sessionId);
    }
    return sessionId;
  }

  // Render functions
  function render() {
    const container = document.getElementById(containerId);
    if (!container) {
      console.error(`[MicroSurvey] Container #${containerId} not found`);
      return;
    }

    if (!surveyData || !surveyData.questions || surveyData.questions.length === 0) {
      container.innerHTML = '<div class="ms-error">No questions available</div>';
      return;
    }

    const question = surveyData.questions[currentQuestionIndex];
    const isLastQuestion = currentQuestionIndex === surveyData.questions.length - 1;
    const progress = ((currentQuestionIndex + 1) / surveyData.questions.length) * 100;

    container.innerHTML = `
      <div class="ms-widget">
        <div class="ms-header">
          <h3 class="ms-title">${escapeHtml(surveyData.title)}</h3>
          ${surveyData.config?.showProgressBar !== false ? `
            <div class="ms-progress">
              <div class="ms-progress-bar" style="width: ${progress}%"></div>
            </div>
          ` : ''}
        </div>
        
        <div class="ms-body">
          <div class="ms-question">
            <h4 class="ms-question-text">
              ${escapeHtml(question.text)}
              ${question.required ? '<span class="ms-required">*</span>' : ''}
            </h4>
            
            <div class="ms-answer">
              ${renderQuestion(question)}
            </div>
          </div>
        </div>
        
        <div class="ms-footer">
          ${currentQuestionIndex > 0 && surveyData.config?.allowBack !== false ? `
            <button class="ms-btn ms-btn-secondary" onclick="window.microSurveyPrev()">
              ← Previous
            </button>
          ` : ''}
          
          <button class="ms-btn ms-btn-primary" onclick="window.microSurveyNext()">
            ${isLastQuestion ? 'Submit' : 'Next →'}
          </button>
        </div>
      </div>
    `;

    injectStyles();
  }

  function renderQuestion(question) {
    switch (question.type) {
      case 'multiple_choice':
        return question.options.map((opt, idx) => {
          const option = typeof opt === 'string' ? { text: opt, imageUrl: '' } : opt;
          const checked = answers[question.id] === option.text ? 'checked' : '';
          return `
            <label class="ms-option ${option.imageUrl ? 'ms-option-with-image' : ''}">
              <input type="radio" name="q_${question.id}" value="${escapeHtml(option.text)}" ${checked} 
                onchange="window.microSurveyAnswer('${question.id}', this.value)">
              ${option.imageUrl ? `<img src="${escapeHtml(option.imageUrl)}" alt="" class="ms-option-image">` : ''}
              <span>${escapeHtml(option.text)}</span>
            </label>
          `;
        }).join('');

      case 'rating':
        const min = question.options?.[0]?.min || 1;
        const max = question.options?.[0]?.max || 5;
        const label = question.options?.[0]?.label || 'stars';
        const icons = {
          stars: '⭐',
          hearts: '❤️',
          thumbs: '👍',
        };
        const icon = icons[label] || '⭐';
        
        return Array.from({ length: max - min + 1 }, (_, i) => {
          const value = min + i;
          const selected = answers[question.id] === value ? 'ms-rating-selected' : '';
          return `
            <button class="ms-rating-btn ${selected}" onclick="window.microSurveyAnswer('${question.id}', ${value})">
              ${label === 'numbers' ? value : icon}
            </button>
          `;
        }).join('');

      case 'text':
        return `
          <textarea class="ms-textarea" rows="4" 
            placeholder="Type your answer here..."
            onchange="window.microSurveyAnswer('${question.id}', this.value)">${answers[question.id] || ''}</textarea>
        `;

      case 'yes_no':
        return `
          <div class="ms-yesno">
            <button class="ms-yesno-btn ${answers[question.id] === 'yes' ? 'ms-selected' : ''}" 
              onclick="window.microSurveyAnswer('${question.id}', 'yes')">
              Yes
            </button>
            <button class="ms-yesno-btn ${answers[question.id] === 'no' ? 'ms-selected' : ''}" 
              onclick="window.microSurveyAnswer('${question.id}', 'no')">
              No
            </button>
          </div>
        `;

      default:
        return '<p class="ms-error">Unknown question type</p>';
    }
  }

  function renderThankYou() {
    const container = document.getElementById(containerId);
    container.innerHTML = `
      <div class="ms-widget ms-thank-you">
        <div class="ms-thank-you-icon">✓</div>
        <h3>Thank you!</h3>
        <p>Your response has been recorded.</p>
      </div>
    `;
  }

  function renderError(message) {
    const container = document.getElementById(containerId);
    container.innerHTML = `
      <div class="ms-widget">
        <div class="ms-error">⚠️ ${escapeHtml(message)}</div>
      </div>
    `;
  }

  function injectStyles() {
    if (document.getElementById('microsurvey-styles')) return;

    const style = document.createElement('style');
    style.id = 'microsurvey-styles';
    style.textContent = `
      .ms-widget { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; max-width: 600px; margin: 0 auto; background: #fff; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); padding: 24px; }
      .ms-header { margin-bottom: 24px; }
      .ms-title { margin: 0 0 16px 0; font-size: 24px; font-weight: 600; color: #1a1a1a; }
      .ms-progress { height: 4px; background: #e5e7eb; border-radius: 2px; overflow: hidden; }
      .ms-progress-bar { height: 100%; background: #3b82f6; transition: width 0.3s; }
      .ms-question-text { font-size: 18px; font-weight: 500; margin: 0 0 16px 0; color: #374151; }
      .ms-required { color: #ef4444; }
      .ms-option { display: flex; align-items: center; padding: 12px; margin: 8px 0; border: 2px solid #e5e7eb; border-radius: 8px; cursor: pointer; transition: all 0.2s; }
      .ms-option:hover { border-color: #3b82f6; background: #eff6ff; }
      .ms-option input { margin-right: 12px; }
      .ms-option-image { width: 60px; height: 60px; object-fit: cover; border-radius: 6px; margin-right: 12px; }
      .ms-textarea { width: 100%; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-family: inherit; font-size: 14px; resize: vertical; }
      .ms-rating-btn { padding: 12px 16px; margin: 4px; border: 2px solid #e5e7eb; background: #fff; border-radius: 8px; cursor: pointer; font-size: 20px; transition: all 0.2s; }
      .ms-rating-btn:hover { border-color: #3b82f6; transform: scale(1.1); }
      .ms-rating-selected { border-color: #3b82f6; background: #eff6ff; }
      .ms-yesno { display: flex; gap: 12px; }
      .ms-yesno-btn { flex: 1; padding: 16px; border: 2px solid #e5e7eb; background: #fff; border-radius: 8px; font-size: 16px; font-weight: 500; cursor: pointer; transition: all 0.2s; }
      .ms-yesno-btn:hover { border-color: #3b82f6; }
      .ms-selected { border-color: #3b82f6; background: #eff6ff; color: #3b82f6; }
      .ms-footer { display: flex; justify-content: space-between; margin-top: 24px; gap: 12px; }
      .ms-btn { padding: 12px 24px; border: none; border-radius: 8px; font-size: 16px; font-weight: 500; cursor: pointer; transition: all 0.2s; }
      .ms-btn-primary { background: #3b82f6; color: #fff; }
      .ms-btn-primary:hover { background: #2563eb; }
      .ms-btn-secondary { background: #f3f4f6; color: #374151; }
      .ms-btn-secondary:hover { background: #e5e7eb; }
      .ms-thank-you { text-align: center; padding: 40px 24px; }
      .ms-thank-you-icon { font-size: 64px; color: #10b981; margin-bottom: 16px; }
      .ms-error { color: #ef4444; padding: 16px; background: #fef2f2; border-radius: 8px; text-align: center; }
    `;
    document.head.appendChild(style);
  }

  // Utility functions
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Global functions
  window.microSurveyAnswer = function(questionId, value) {
    answers[questionId] = value;
  };

  window.microSurveyNext = function() {
    const question = surveyData.questions[currentQuestionIndex];
    
    if (question.required && !answers[question.id]) {
      alert('Please answer this question before continuing.');
      return;
    }

    if (currentQuestionIndex === surveyData.questions.length - 1) {
      submitSurvey();
    } else {
      currentQuestionIndex++;
      render();
    }
  };

  window.microSurveyPrev = function() {
    if (currentQuestionIndex > 0) {
      currentQuestionIndex--;
      render();
    }
  };

  // Initialize
  loadSurvey();
})();
</file>

<file path=".gitignore">
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
package-lock.json
yarn.lock

# Environment
.env
.env.local
.env.*.local

# Logs
logs/
*.log
pids/
*.pid
*.seed
*.pid.lock

# Build outputs
dist/
build/
coverage/
.nyc_output

# OS
.DS_Store
Thumbs.db

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# Testing
.coverage
htmlcov/

# Backups
backups/
*.backup

# Temporary
tmp/
temp/
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    container_name: dashboard-postgres
    environment:
      POSTGRES_DB: dashboard
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - dashboard-network

  redis:
    image: redis:7-alpine
    container_name: dashboard-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
    networks:
      - dashboard-network

  microsurvey-mock:
    build:
      context: ./microsurvey-mock
      dockerfile: Dockerfile
    container_name: microsurvey-mock
    ports:
      - "4000:4000"
    environment:
      PORT: 4000
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:4000/health"]
      interval: 10s
      timeout: 5s
      retries: 3
    networks:
      - dashboard-network

  api:
    build:
      context: ./backend
      dockerfile: Dockerfile
      target: dev
    container_name: dashboard-api
    ports:
      - "5000:5000"
    environment:
      NODE_ENV: development
      PORT: 5000
      DATABASE_URL: postgresql://postgres:${POSTGRES_PASSWORD:-postgres}@postgres:5432/dashboard
      REDIS_URL: redis://redis:6379/0
      JWT_SECRET: ${JWT_SECRET:-dev_secret_change_in_production_min_32_chars}
      API_KEY_PEPPER: ${API_KEY_PEPPER:-dev_pepper_change_in_production}
      CORS_ORIGINS: http://localhost:5173,http://localhost:3000
      MICROSURVEY_BASE_URL: http://microsurvey-mock:4000
      MICROSURVEY_API_KEY: mock_api_key
      USE_MOCK_MICROSURVEY: "true"
    volumes:
      - ./backend:/app
      - /app/node_modules
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      microsurvey-mock:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:5000/api/health"]
      interval: 15s
      timeout: 5s
      retries: 3
      start_period: 30s
    networks:
      - dashboard-network
    command: sh -c "npm run migrate && npm run dev"

  worker:
    build:
      context: ./backend
      dockerfile: Dockerfile
      target: dev
    container_name: dashboard-worker
    environment:
      NODE_ENV: development
      DATABASE_URL: postgresql://postgres:${POSTGRES_PASSWORD:-postgres}@postgres:5432/dashboard
      REDIS_URL: redis://redis:6379/0
      JWT_SECRET: ${JWT_SECRET:-dev_secret_change_in_production_min_32_chars}
      API_KEY_PEPPER: ${API_KEY_PEPPER:-dev_pepper_change_in_production}
      MICROSURVEY_BASE_URL: http://microsurvey-mock:4000
      MICROSURVEY_API_KEY: mock_api_key
    volumes:
      - ./backend:/app
      - /app/node_modules
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      api:
        condition: service_healthy
    networks:
      - dashboard-network
    command: node src/workers/surveyWorker.js

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      target: dev
    container_name: dashboard-frontend
    ports:
      - "5173:5173"
    environment:
      VITE_API_BASE: http://localhost:5000/api
    volumes:
      - ./frontend:/app
      - /app/node_modules
    depends_on:
      - api
    networks:
      - dashboard-network
    command: npm run dev -- --host

volumes:
  postgres_data:
  redis_data:

networks:
  dashboard-network:
    driver: bridge
</file>

<file path="Makefile">
# Colors
GREEN=\033[0;32m
YELLOW=\033[1;33m
RED=\033[0;31m
NC=\033[0m

docker-up: ## Start all services with Docker
	@echo "$(GREEN)🐳 Starting Docker services...$(NC)"
	docker compose up -d
	@echo "$(YELLOW)⏳ Waiting for services to be healthy...$(NC)"
	@docker compose ps
	@sleep 8
	@echo "$(GREEN)✅ Services started!$(NC)"
	@$(MAKE) migrate

docker-down: ## Stop all Docker services
	@echo "$(YELLOW)🛑 Stopping Docker services...$(NC)"
	docker compose down
	@echo "$(GREEN)✅ Services stopped!$(NC)"

docker-build: ## Build Docker images
	@echo "$(GREEN)🔨 Building Docker images...$(NC)"
	docker compose build
	@echo "$(GREEN)✅ Build complete!$(NC)"

docker-restart: ## Restart Docker services
	@echo "$(YELLOW)🔁 Restarting Docker services...$(NC)"
	docker compose down
	docker compose up -d
	@echo "$(GREEN)✅ Restart complete!$(NC)"
</file>

<file path="package.json">
{
  "devDependencies": {
    "supertest": "^7.1.4"
  }
}
</file>

<file path="smoke.sh">
#!/bin/bash
# ============================================
# Smoke Tests - Verify Critical Endpoints
# ============================================

set -e

API_URL="${API_URL:-http://localhost:5000/api}"
FRONTEND_URL="${FRONTEND_URL:-http://localhost:5173}"

echo "🧪 Running smoke tests..."
echo "API URL: $API_URL"
echo ""

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m'

# Test counter
TESTS_PASSED=0
TESTS_FAILED=0

test_endpoint() {
  local name="$1"
  local method="$2"
  local endpoint="$3"
  local expected_code="$4"
  local data="$5"
  
  echo -n "Testing: $name ... "
  
  if [ "$method" = "GET" ]; then
    response=$(curl -s -w "\n%{http_code}" "$API_URL$endpoint")
  else
    response=$(curl -s -w "\n%{http_code}" -X "$method" -H "Content-Type: application/json" -d "$data" "$API_URL$endpoint")
  fi
  
  http_code=$(echo "$response" | tail -n1)
  body=$(echo "$response" | sed '$d')
  
  if [ "$http_code" = "$expected_code" ]; then
    echo -e "${GREEN}✓ PASS${NC} (HTTP $http_code)"
    ((TESTS_PASSED++))
    return 0
  else
    echo -e "${RED}✗ FAIL${NC} (Expected $expected_code, got $http_code)"
    echo "Response: $body"
    ((TESTS_FAILED++))
    return 1
  fi
}

echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "1️⃣  Health & Core Endpoints"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

test_endpoint "Health check" "GET" "/health" "200"
test_endpoint "Root endpoint" "GET" "/" "200"

echo ""
echo "2️⃣  Authentication Flow"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

# Register a test user
TIMESTAMP=$(date +%s)
TEST_EMAIL="smoketest-${TIMESTAMP}@example.com"
TEST_PASSWORD="TestPass123!"
TEST_NAME="Smoke Test User"

REGISTER_DATA="{\"email\":\"$TEST_EMAIL\",\"password\":\"$TEST_PASSWORD\",\"fullName\":\"$TEST_NAME\"}"

echo -n "Testing: User registration ... "
REGISTER_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -H "Content-Type: application/json" -d "$REGISTER_DATA" "$API_URL/auth/register")
REGISTER_CODE=$(echo "$REGISTER_RESPONSE" | tail -n1)
REGISTER_BODY=$(echo "$REGISTER_RESPONSE" | sed '$d')

if [ "$REGISTER_CODE" = "201" ]; then
  echo -e "${GREEN}✓ PASS${NC} (HTTP $REGISTER_CODE)"
  ACCESS_TOKEN=$(echo "$REGISTER_BODY" | grep -o '"accessToken":"[^"]*' | cut -d'"' -f4)
  ((TESTS_PASSED++))
else
  echo -e "${RED}✗ FAIL${NC} (Expected 201, got $REGISTER_CODE)"
  echo "Response: $REGISTER_BODY"
  ((TESTS_FAILED++))
  exit 1
fi

# Test login
LOGIN_DATA="{\"email\":\"$TEST_EMAIL\",\"password\":\"$TEST_PASSWORD\"}"
test_endpoint "User login" "POST" "/auth/login" "200" "$LOGIN_DATA"

# Test protected endpoint
echo -n "Testing: Protected endpoint (GET /auth/me) ... "
ME_RESPONSE=$(curl -s -w "\n%{http_code}" -H "Authorization: Bearer $ACCESS_TOKEN" "$API_URL/auth/me")
ME_CODE=$(echo "$ME_RESPONSE" | tail -n1)

if [ "$ME_CODE" = "200" ]; then
  echo -e "${GREEN}✓ PASS${NC} (HTTP $ME_CODE)"
  ((TESTS_PASSED++))
else
  echo -e "${RED}✗ FAIL${NC} (Expected 200, got $ME_CODE)"
  ((TESTS_FAILED++))
fi

echo ""
echo "3️⃣  Tenant & Survey Management"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

# Create tenant
TENANT_DATA="{\"name\":\"Smoke Test Tenant\",\"slug\":\"smoke-${TIMESTAMP}\",\"email\":\"tenant@example.com\"}"
echo -n "Testing: Create tenant ... "
TENANT_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -H "Authorization: Bearer $ACCESS_TOKEN" -H "Content-Type: application/json" -d "$TENANT_DATA" "$API_URL/tenants")
TENANT_CODE=$(echo "$TENANT_RESPONSE" | tail -n1)
TENANT_BODY=$(echo "$TENANT_RESPONSE" | sed '$d')

if [ "$TENANT_CODE" = "201" ]; then
  echo -e "${GREEN}✓ PASS${NC} (HTTP $TENANT_CODE)"
  TENANT_ID=$(echo "$TENANT_BODY" | grep -o '"id":"[^"]*' | head -1 | cut -d'"' -f4)
  ((TESTS_PASSED++))
else
  echo -e "${RED}✗ FAIL${NC} (Expected 201, got $TENANT_CODE)"
  echo "Response: $TENANT_BODY"
  ((TESTS_FAILED++))
  TENANT_ID=""
fi

# Create API key for tenant
if [ -n "$TENANT_ID" ]; then
  API_KEY_DATA="{\"name\":\"Smoke Test Key\"}"
  echo -n "Testing: Create API key ... "
  KEY_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -H "Authorization: Bearer $ACCESS_TOKEN" -H "Content-Type: application/json" -d "$API_KEY_DATA" "$API_URL/tenants/$TENANT_ID/keys")
  KEY_CODE=$(echo "$KEY_RESPONSE" | tail -n1)
  
  if [ "$KEY_CODE" = "201" ]; then
    echo -e "${GREEN}✓ PASS${NC} (HTTP $KEY_CODE)"
    ((TESTS_PASSED++))
  else
    echo -e "${RED}✗ FAIL${NC} (Expected 201, got $KEY_CODE)"
    ((TESTS_FAILED++))
  fi
fi

# Create organization (required for surveys)
ORG_DATA="{\"name\":\"Smoke Test Org\",\"slug\":\"smoke-org-${TIMESTAMP}\"}"
echo -n "Testing: Create organization ... "
ORG_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -H "Authorization: Bearer $ACCESS_TOKEN" -H "Content-Type: application/json" -d "$ORG_DATA" "$API_URL/organizations")
ORG_CODE=$(echo "$ORG_RESPONSE" | tail -n1)
ORG_BODY=$(echo "$ORG_RESPONSE" | sed '$d')

if [ "$ORG_CODE" = "201" ]; then
  echo -e "${GREEN}✓ PASS${NC} (HTTP $ORG_CODE)"
  ORG_ID=$(echo "$ORG_BODY" | grep -o '"id":"[^"]*' | head -1 | cut -d'"' -f4)
  ((TESTS_PASSED++))
else
  echo -e "${RED}✗ FAIL${NC} (Expected 201, got $ORG_CODE)"
  echo "Response: $ORG_BODY"
  ((TESTS_FAILED++))
  ORG_ID=""
fi

# Create survey
if [ -n "$TENANT_ID" ]; then
  SURVEY_DATA="{\"tenantId\":\"$TENANT_ID\",\"organizationId\":\"$ORG_ID\",\"title\":\"Smoke Test Survey\",\"description\":\"Test survey\",\"surveyType\":\"poll\"}"
  echo -n "Testing: Create survey ... "
  SURVEY_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -H "Authorization: Bearer $ACCESS_TOKEN" -H "Content-Type: application/json" -d "$SURVEY_DATA" "$API_URL/surveys")
  SURVEY_CODE=$(echo "$SURVEY_RESPONSE" | tail -n1)
  SURVEY_BODY=$(echo "$SURVEY_RESPONSE" | sed '$d')
  
  if [ "$SURVEY_CODE" = "201" ]; then
    echo -e "${GREEN}✓ PASS${NC} (HTTP $SURVEY_CODE)"
    SURVEY_ID=$(echo "$SURVEY_BODY" | grep -o '"id":"[^"]*' | head -1 | cut -d'"' -f4)
    SURVEY_KEY=$(echo "$SURVEY_BODY" | grep -o '"survey_key":"[^"]*' | head -1 | cut -d'"' -f4)
    ((TESTS_PASSED++))
  else
    echo -e "${RED}✗ FAIL${NC} (Expected 201, got $SURVEY_CODE)"
    echo "Response: $SURVEY_BODY"
    ((TESTS_FAILED++))
    SURVEY_ID=""
  fi
fi

echo ""
echo "4️⃣  Question Management"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

if [ -n "$ORG_ID" ]; then
  QUESTION_DATA="{\"organizationId\":\"$ORG_ID\",\"questionText\":\"What is your favorite color?\",\"questionType\":\"multiple_choice\",\"options\":[\"Red\",\"Blue\",\"Green\"],\"isActive\":true}"
  echo -n "Testing: Create question ... "
  QUESTION_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -H "Authorization: Bearer $ACCESS_TOKEN" -H "Content-Type: application/json" -d "$QUESTION_DATA" "$API_URL/questions")
  QUESTION_CODE=$(echo "$QUESTION_RESPONSE" | tail -n1)
  QUESTION_BODY=$(echo "$QUESTION_RESPONSE" | sed '$d')
  
  if [ "$QUESTION_CODE" = "201" ]; then
    echo -e "${GREEN}✓ PASS${NC} (HTTP $QUESTION_CODE)"
    QUESTION_ID=$(echo "$QUESTION_BODY" | grep -o '"id":"[^"]*' | head -1 | cut -d'"' -f4)
    ((TESTS_PASSED++))
  else
    echo -e "${RED}✗ FAIL${NC} (Expected 201, got $QUESTION_CODE)"
    echo "Response: $QUESTION_BODY"
    ((TESTS_FAILED++))
    QUESTION_ID=""
  fi
  
  # List questions
  if [ -n "$QUESTION_ID" ]; then
    echo -n "Testing: List questions ... "
    LIST_RESPONSE=$(curl -s -w "\n%{http_code}" -H "Authorization: Bearer $ACCESS_TOKEN" "$API_URL/questions")
    LIST_CODE=$(echo "$LIST_RESPONSE" | tail -n1)
    
    if [ "$LIST_CODE" = "200" ]; then
      echo -e "${GREEN}✓ PASS${NC} (HTTP $LIST_CODE)"
      ((TESTS_PASSED++))
    else
      echo -e "${RED}✗ FAIL${NC} (Expected 200, got $LIST_CODE)"
      ((TESTS_FAILED++))
    fi
  fi
fi

echo ""
echo "5️⃣  Micro-Survey Integration"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

# Test Micro-Survey mock health
echo -n "Testing: Micro-Survey mock health ... "
MS_HEALTH=$(curl -s -w "\n%{http_code}" "http://localhost:4000/health" 2>/dev/null || echo "000")
MS_CODE=$(echo "$MS_HEALTH" | tail -n1)

if [ "$MS_CODE" = "200" ]; then
  echo -e "${GREEN}✓ PASS${NC} (HTTP $MS_CODE)"
  ((TESTS_PASSED++))
else
  echo -e "${RED}✗ FAIL${NC} (Expected 200, got $MS_CODE)"
  echo "Note: Micro-Survey mock may not be running"
  ((TESTS_FAILED++))
fi

# Submit response to survey (if survey exists)
if [ -n "$SURVEY_KEY" ]; then
  RESPONSE_DATA="{\"answers\":[{\"questionId\":\"q1\",\"answer\":\"Blue\"}]}"
  echo -n "Testing: Submit survey response ... "
  RESPONSE_RESULT=$(curl -s -w "\n%{http_code}" -X POST -H "Content-Type: application/json" -d "$RESPONSE_DATA" "http://localhost:4000/v1/surveys/$SURVEY_KEY/responses" 2>/dev/null || echo "000")
  RESPONSE_CODE=$(echo "$RESPONSE_RESULT" | tail -n1)
  
  if [ "$RESPONSE_CODE" = "201" ]; then
    echo -e "${GREEN}✓ PASS${NC} (HTTP $RESPONSE_CODE)"
    ((TESTS_PASSED++))
  else
    echo -e "${RED}✗ FAIL${NC} (Expected 201, got $RESPONSE_CODE)"
    ((TESTS_FAILED++))
  fi
fi

echo ""
echo "6️⃣  Frontend Health (Optional)"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

echo -n "Testing: Frontend availability ... "
FRONTEND_RESPONSE=$(curl -s -w "\n%{http_code}" "$FRONTEND_URL" 2>/dev/null || echo "000")
FRONTEND_CODE=$(echo "$FRONTEND_RESPONSE" | tail -n1)

if [ "$FRONTEND_CODE" = "200" ]; then
  echo -e "${GREEN}✓ PASS${NC} (HTTP $FRONTEND_CODE)"
  ((TESTS_PASSED++))
else
  echo -e "${RED}✗ FAIL${NC} (Expected 200, got $FRONTEND_CODE)"
  echo "Note: Frontend may not be running"
  ((TESTS_FAILED++))
fi

echo ""
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "📊 SMOKE TEST RESULTS"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo -e "Passed: ${GREEN}$TESTS_PASSED${NC}"
echo -e "Failed: ${RED}$TESTS_FAILED${NC}"
echo "Total:  $((TESTS_PASSED + TESTS_FAILED))"
echo ""

if [ $TESTS_FAILED -eq 0 ]; then
  echo -e "${GREEN}✅ All smoke tests passed!${NC}"
  exit 0
else
  echo -e "${RED}❌ Some tests failed. Check logs above.${NC}"
  exit 1
fi
</file>

</files>
